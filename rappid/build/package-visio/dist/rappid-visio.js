/*! JointJS+ v3.6.3 - HTML5 Diagramming Framework

Copyright (c) 2022 client IO

 2022-12-09 


This Source Code Form is subject to the terms of the JointJS+ License
, v. 2.0. If a copy of the JointJS+ License was not distributed with this
file, You can obtain one at http://jointjs.com/license/rappid_v2.txt
 or from the JointJS+ archive as was distributed by client IO. See the LICENSE file.*/


(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('jointjs'), require('hot-formula-parser'), require('jszip')) :
  typeof define === 'function' && define.amd ? define(['exports', 'jointjs', 'hot-formula-parser', 'jszip'], factory) :
  (global = global || self, factory((global.joint = global.joint || {}, global.joint.format = global.joint.format || {}, global.joint.format.Visio = global.joint.format.Visio || {}), global.joint, global.formulaParser, global.JSZip));
}(this, (function (exports, jointjs, hotFormulaParser, jszip) { 'use strict';

  jszip = jszip && Object.prototype.hasOwnProperty.call(jszip, 'default') ? jszip['default'] : jszip;

  function _asyncIterator(iterable) {
    var method,
      async,
      sync,
      retry = 2;
    for ("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) {
      if (async && null != (method = iterable[async])) return method.call(iterable);
      if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable));
      async = "@@asyncIterator", sync = "@@iterator";
    }
    throw new TypeError("Object is not async iterable");
  }
  function AsyncFromSyncIterator(s) {
    function AsyncFromSyncIteratorContinuation(r) {
      if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object."));
      var done = r.done;
      return Promise.resolve(r.value).then(function (value) {
        return {
          value: value,
          done: done
        };
      });
    }
    return AsyncFromSyncIterator = function (s) {
      this.s = s, this.n = s.next;
    }, AsyncFromSyncIterator.prototype = {
      s: null,
      n: null,
      next: function () {
        return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));
      },
      return: function (value) {
        var ret = this.s.return;
        return void 0 === ret ? Promise.resolve({
          value: value,
          done: !0
        }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments));
      },
      throw: function (value) {
        var thr = this.s.return;
        return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments));
      }
    }, new AsyncFromSyncIterator(s);
  }
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _regeneratorRuntime() {
    _regeneratorRuntime = function () {
      return exports;
    };
    var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
      return Object.defineProperty(obj, key, {
        value: value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), obj[key];
    }
    try {
      define({}, "");
    } catch (err) {
      define = function (obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
      return generator._invoke = function (innerFn, self, context) {
        var state = "suspendedStart";
        return function (method, arg) {
          if ("executing" === state) throw new Error("Generator is already running");
          if ("completed" === state) {
            if ("throw" === method) throw arg;
            return doneResult();
          }
          for (context.method = method, context.arg = arg;;) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel) continue;
                return delegateResult;
              }
            }
            if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
              if ("suspendedStart" === state) throw state = "completed", context.arg;
              context.dispatchException(context.arg);
            } else "return" === context.method && context.abrupt("return", context.arg);
            state = "executing";
            var record = tryCatch(innerFn, self, context);
            if ("normal" === record.type) {
              if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
              return {
                value: record.arg,
                done: context.done
              };
            }
            "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
          }
        };
      }(innerFn, self, context), generator;
    }
    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }
    exports.wrap = wrap;
    var ContinueSentinel = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function () {
      return this;
    });
    var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if ("throw" !== record.type) {
          var result = record.arg,
            value = result.value;
          return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          }) : PromiseImpl.resolve(value).then(function (unwrapped) {
            result.value = unwrapped, resolve(result);
          }, function (error) {
            return invoke("throw", error, resolve, reject);
          });
        }
        reject(record.arg);
      }
      var previousPromise;
      this._invoke = function (method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      };
    }
    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];
      if (undefined === method) {
        if (context.delegate = null, "throw" === context.method) {
          if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
          context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }
        return ContinueSentinel;
      }
      var record = tryCatch(method, delegate.iterator, context.arg);
      if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
      var info = record.arg;
      return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
    }
    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };
      1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal", delete record.arg, entry.completion = record;
    }
    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
    }
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) return iteratorMethod.call(iterable);
        if ("function" == typeof iterable.next) return iterable;
        if (!isNaN(iterable.length)) {
          var i = -1,
            next = function next() {
              for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
              return next.value = undefined, next.done = !0, next;
            };
          return next.next = next;
        }
      }
      return {
        next: doneResult
      };
    }
    function doneResult() {
      return {
        value: undefined,
        done: !0
      };
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
      var ctor = "function" == typeof genFun && genFun.constructor;
      return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports.mark = function (genFun) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports.awrap = function (arg) {
      return {
        __await: arg
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
      return this;
    }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      void 0 === PromiseImpl && (PromiseImpl = Promise);
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
      return this;
    }), define(Gp, "toString", function () {
      return "[object Generator]";
    }), exports.keys = function (object) {
      var keys = [];
      for (var key in object) keys.push(key);
      return keys.reverse(), function next() {
        for (; keys.length;) {
          var key = keys.pop();
          if (key in object) return next.value = key, next.done = !1, next;
        }
        return next.done = !0, next;
      };
    }, exports.values = values, Context.prototype = {
      constructor: Context,
      reset: function (skipTempReset) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
      },
      stop: function () {
        this.done = !0;
        var rootRecord = this.tryEntries[0].completion;
        if ("throw" === rootRecord.type) throw rootRecord.arg;
        return this.rval;
      },
      dispatchException: function (exception) {
        if (this.done) throw exception;
        var context = this;
        function handle(loc, caught) {
          return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i],
            record = entry.completion;
          if ("root" === entry.tryLoc) return handle("end");
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            } else {
              if (!hasFinally) throw new Error("try statement without catch or finally");
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            }
          }
        }
      },
      abrupt: function (type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
        var record = finallyEntry ? finallyEntry.completion : {};
        return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
      },
      complete: function (record, afterLoc) {
        if ("throw" === record.type) throw record.arg;
        return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
      },
      finish: function (finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
        }
      },
      catch: function (tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if ("throw" === record.type) {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function (iterable, resultName, nextLoc) {
        return this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
      }
    }, exports;
  }
  function _typeof(obj) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
  }
  function _wrapRegExp() {
    _wrapRegExp = function (re, groups) {
      return new BabelRegExp(re, void 0, groups);
    };
    var _super = RegExp.prototype,
      _groups = new WeakMap();
    function BabelRegExp(re, flags, groups) {
      var _this = new RegExp(re, flags);
      return _groups.set(_this, groups || _groups.get(re)), _setPrototypeOf(_this, BabelRegExp.prototype);
    }
    function buildGroups(result, re) {
      var g = _groups.get(re);
      return Object.keys(g).reduce(function (groups, name) {
        var i = g[name];
        if ("number" == typeof i) groups[name] = result[i];else {
          for (var k = 0; void 0 === result[i[k]] && k + 1 < i.length;) k++;
          groups[name] = result[i[k]];
        }
        return groups;
      }, Object.create(null));
    }
    return _inherits(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function (str) {
      var result = _super.exec.call(this, str);
      return result && (result.groups = buildGroups(result, this)), result;
    }, BabelRegExp.prototype[Symbol.replace] = function (str, substitution) {
      if ("string" == typeof substitution) {
        var groups = _groups.get(this);
        return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) {
          return "$" + groups[name];
        }));
      }
      if ("function" == typeof substitution) {
        var _this = this;
        return _super[Symbol.replace].call(this, str, function () {
          var args = arguments;
          return "object" != typeof args[args.length - 1] && (args = [].slice.call(args)).push(buildGroups(args, _this)), substitution.apply(this, args);
        });
      }
      return _super[Symbol.replace].call(this, str, substitution);
    }, _wrapRegExp.apply(this, arguments);
  }
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
        args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _objectDestructuringEmpty(obj) {
    if (obj == null) throw new TypeError("Cannot destructure " + obj);
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }
  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self);
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }
    return object;
  }
  function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get.bind();
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);
        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);
        if (desc.get) {
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }
        return desc.value;
      };
    }
    return _get.apply(this, arguments);
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _toArray(arr) {
    return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        var F = function () {};
        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true,
      didErr = false,
      err;
    return {
      s: function () {
        it = it.call(o);
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var check = function (it) {
    return it && it.Math == Math && it;
  };

  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global_1 =
    // eslint-disable-next-line es/no-global-this -- safe
    check(typeof globalThis == 'object' && globalThis) ||
    check(typeof window == 'object' && window) ||
    // eslint-disable-next-line no-restricted-globals -- safe
    check(typeof self == 'object' && self) ||
    check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
    // eslint-disable-next-line no-new-func -- fallback
    (function () { return this; })() || Function('return this')();

  var fails = function (exec) {
    try {
      return !!exec();
    } catch (error) {
      return true;
    }
  };

  // Detect IE8's incomplete defineProperty implementation
  var descriptors = !fails(function () {
    // eslint-disable-next-line es/no-object-defineproperty -- required for testing
    return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
  });

  var functionBindNative = !fails(function () {
    // eslint-disable-next-line es/no-function-prototype-bind -- safe
    var test = (function () { /* empty */ }).bind();
    // eslint-disable-next-line no-prototype-builtins -- safe
    return typeof test != 'function' || test.hasOwnProperty('prototype');
  });

  var call = Function.prototype.call;

  var functionCall = functionBindNative ? call.bind(call) : function () {
    return call.apply(call, arguments);
  };

  var $propertyIsEnumerable = {}.propertyIsEnumerable;
  // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

  // Nashorn ~ JDK8 bug
  var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

  // `Object.prototype.propertyIsEnumerable` method implementation
  // https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
  var f = NASHORN_BUG ? function propertyIsEnumerable(V) {
    var descriptor = getOwnPropertyDescriptor(this, V);
    return !!descriptor && descriptor.enumerable;
  } : $propertyIsEnumerable;

  var objectPropertyIsEnumerable = {
  	f: f
  };

  var createPropertyDescriptor = function (bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };

  var FunctionPrototype = Function.prototype;
  var call$1 = FunctionPrototype.call;
  var uncurryThisWithBind = functionBindNative && FunctionPrototype.bind.bind(call$1, call$1);

  var functionUncurryThisRaw = function (fn) {
    return functionBindNative ? uncurryThisWithBind(fn) : function () {
      return call$1.apply(fn, arguments);
    };
  };

  var toString = functionUncurryThisRaw({}.toString);
  var stringSlice = functionUncurryThisRaw(''.slice);

  var classofRaw = function (it) {
    return stringSlice(toString(it), 8, -1);
  };

  var functionUncurryThis = function (fn) {
    // Nashorn bug:
    //   https://github.com/zloirock/core-js/issues/1128
    //   https://github.com/zloirock/core-js/issues/1130
    if (classofRaw(fn) === 'Function') return functionUncurryThisRaw(fn);
  };

  var $Object = Object;
  var split = functionUncurryThis(''.split);

  // fallback for non-array-like ES3 and non-enumerable old V8 strings
  var indexedObject = fails(function () {
    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
    // eslint-disable-next-line no-prototype-builtins -- safe
    return !$Object('z').propertyIsEnumerable(0);
  }) ? function (it) {
    return classofRaw(it) == 'String' ? split(it, '') : $Object(it);
  } : $Object;

  // we can't use just `it == null` since of `document.all` special case
  // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
  var isNullOrUndefined = function (it) {
    return it === null || it === undefined;
  };

  var $TypeError = TypeError;

  // `RequireObjectCoercible` abstract operation
  // https://tc39.es/ecma262/#sec-requireobjectcoercible
  var requireObjectCoercible = function (it) {
    if (isNullOrUndefined(it)) throw $TypeError("Can't call method on " + it);
    return it;
  };

  // toObject with fallback for non-array-like ES3 strings



  var toIndexedObject = function (it) {
    return indexedObject(requireObjectCoercible(it));
  };

  var documentAll = typeof document == 'object' && document.all;

  // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
  var IS_HTMLDDA = typeof documentAll == 'undefined' && documentAll !== undefined;

  var documentAll_1 = {
    all: documentAll,
    IS_HTMLDDA: IS_HTMLDDA
  };

  var documentAll$1 = documentAll_1.all;

  // `IsCallable` abstract operation
  // https://tc39.es/ecma262/#sec-iscallable
  var isCallable = documentAll_1.IS_HTMLDDA ? function (argument) {
    return typeof argument == 'function' || argument === documentAll$1;
  } : function (argument) {
    return typeof argument == 'function';
  };

  var documentAll$2 = documentAll_1.all;

  var isObject = documentAll_1.IS_HTMLDDA ? function (it) {
    return typeof it == 'object' ? it !== null : isCallable(it) || it === documentAll$2;
  } : function (it) {
    return typeof it == 'object' ? it !== null : isCallable(it);
  };

  var aFunction = function (argument) {
    return isCallable(argument) ? argument : undefined;
  };

  var getBuiltIn = function (namespace, method) {
    return arguments.length < 2 ? aFunction(global_1[namespace]) : global_1[namespace] && global_1[namespace][method];
  };

  var objectIsPrototypeOf = functionUncurryThis({}.isPrototypeOf);

  var engineUserAgent = getBuiltIn('navigator', 'userAgent') || '';

  var process = global_1.process;
  var Deno$1 = global_1.Deno;
  var versions = process && process.versions || Deno$1 && Deno$1.version;
  var v8 = versions && versions.v8;
  var match, version;

  if (v8) {
    match = v8.split('.');
    // in old Chrome, versions of V8 isn't V8 = Chrome / 10
    // but their correct versions are not interesting for us
    version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
  }

  // BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
  // so check `userAgent` even if `.v8` exists, but 0
  if (!version && engineUserAgent) {
    match = engineUserAgent.match(/Edge\/(\d+)/);
    if (!match || match[1] >= 74) {
      match = engineUserAgent.match(/Chrome\/(\d+)/);
      if (match) version = +match[1];
    }
  }

  var engineV8Version = version;

  /* eslint-disable es/no-symbol -- required for testing */



  // eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
  var symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails(function () {
    var symbol = Symbol();
    // Chrome 38 Symbol has incorrect toString conversion
    // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
    return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
      // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      !Symbol.sham && engineV8Version && engineV8Version < 41;
  });

  /* eslint-disable es/no-symbol -- required for testing */


  var useSymbolAsUid = symbolConstructorDetection
    && !Symbol.sham
    && typeof Symbol.iterator == 'symbol';

  var $Object$1 = Object;

  var isSymbol = useSymbolAsUid ? function (it) {
    return typeof it == 'symbol';
  } : function (it) {
    var $Symbol = getBuiltIn('Symbol');
    return isCallable($Symbol) && objectIsPrototypeOf($Symbol.prototype, $Object$1(it));
  };

  var $String = String;

  var tryToString = function (argument) {
    try {
      return $String(argument);
    } catch (error) {
      return 'Object';
    }
  };

  var $TypeError$1 = TypeError;

  // `Assert: IsCallable(argument) is true`
  var aCallable = function (argument) {
    if (isCallable(argument)) return argument;
    throw $TypeError$1(tryToString(argument) + ' is not a function');
  };

  // `GetMethod` abstract operation
  // https://tc39.es/ecma262/#sec-getmethod
  var getMethod = function (V, P) {
    var func = V[P];
    return isNullOrUndefined(func) ? undefined : aCallable(func);
  };

  var $TypeError$2 = TypeError;

  // `OrdinaryToPrimitive` abstract operation
  // https://tc39.es/ecma262/#sec-ordinarytoprimitive
  var ordinaryToPrimitive = function (input, pref) {
    var fn, val;
    if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = functionCall(fn, input))) return val;
    if (isCallable(fn = input.valueOf) && !isObject(val = functionCall(fn, input))) return val;
    if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = functionCall(fn, input))) return val;
    throw $TypeError$2("Can't convert object to primitive value");
  };

  // eslint-disable-next-line es/no-object-defineproperty -- safe
  var defineProperty = Object.defineProperty;

  var defineGlobalProperty = function (key, value) {
    try {
      defineProperty(global_1, key, { value: value, configurable: true, writable: true });
    } catch (error) {
      global_1[key] = value;
    } return value;
  };

  var SHARED = '__core-js_shared__';
  var store = global_1[SHARED] || defineGlobalProperty(SHARED, {});

  var sharedStore = store;

  var shared = createCommonjsModule(function (module) {
  (module.exports = function (key, value) {
    return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
  })('versions', []).push({
    version: '3.25.5',
    mode:  'global',
    copyright: 'Â© 2014-2022 Denis Pushkarev (zloirock.ru)',
    license: 'https://github.com/zloirock/core-js/blob/v3.25.5/LICENSE',
    source: 'https://github.com/zloirock/core-js'
  });
  });

  var $Object$2 = Object;

  // `ToObject` abstract operation
  // https://tc39.es/ecma262/#sec-toobject
  var toObject = function (argument) {
    return $Object$2(requireObjectCoercible(argument));
  };

  var hasOwnProperty = functionUncurryThis({}.hasOwnProperty);

  // `HasOwnProperty` abstract operation
  // https://tc39.es/ecma262/#sec-hasownproperty
  // eslint-disable-next-line es/no-object-hasown -- safe
  var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
    return hasOwnProperty(toObject(it), key);
  };

  var id = 0;
  var postfix = Math.random();
  var toString$1 = functionUncurryThis(1.0.toString);

  var uid = function (key) {
    return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$1(++id + postfix, 36);
  };

  var WellKnownSymbolsStore = shared('wks');
  var Symbol$1 = global_1.Symbol;
  var symbolFor = Symbol$1 && Symbol$1['for'];
  var createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;

  var wellKnownSymbol = function (name) {
    if (!hasOwnProperty_1(WellKnownSymbolsStore, name) || !(symbolConstructorDetection || typeof WellKnownSymbolsStore[name] == 'string')) {
      var description = 'Symbol.' + name;
      if (symbolConstructorDetection && hasOwnProperty_1(Symbol$1, name)) {
        WellKnownSymbolsStore[name] = Symbol$1[name];
      } else if (useSymbolAsUid && symbolFor) {
        WellKnownSymbolsStore[name] = symbolFor(description);
      } else {
        WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
      }
    } return WellKnownSymbolsStore[name];
  };

  var $TypeError$3 = TypeError;
  var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

  // `ToPrimitive` abstract operation
  // https://tc39.es/ecma262/#sec-toprimitive
  var toPrimitive = function (input, pref) {
    if (!isObject(input) || isSymbol(input)) return input;
    var exoticToPrim = getMethod(input, TO_PRIMITIVE);
    var result;
    if (exoticToPrim) {
      if (pref === undefined) pref = 'default';
      result = functionCall(exoticToPrim, input, pref);
      if (!isObject(result) || isSymbol(result)) return result;
      throw $TypeError$3("Can't convert object to primitive value");
    }
    if (pref === undefined) pref = 'number';
    return ordinaryToPrimitive(input, pref);
  };

  // `ToPropertyKey` abstract operation
  // https://tc39.es/ecma262/#sec-topropertykey
  var toPropertyKey = function (argument) {
    var key = toPrimitive(argument, 'string');
    return isSymbol(key) ? key : key + '';
  };

  var document$1 = global_1.document;
  // typeof document.createElement is 'object' in old IE
  var EXISTS = isObject(document$1) && isObject(document$1.createElement);

  var documentCreateElement = function (it) {
    return EXISTS ? document$1.createElement(it) : {};
  };

  // Thanks to IE8 for its funny defineProperty
  var ie8DomDefine = !descriptors && !fails(function () {
    // eslint-disable-next-line es/no-object-defineproperty -- required for testing
    return Object.defineProperty(documentCreateElement('div'), 'a', {
      get: function () { return 7; }
    }).a != 7;
  });

  // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
  var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
  var f$1 = descriptors ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
    O = toIndexedObject(O);
    P = toPropertyKey(P);
    if (ie8DomDefine) try {
      return $getOwnPropertyDescriptor(O, P);
    } catch (error) { /* empty */ }
    if (hasOwnProperty_1(O, P)) return createPropertyDescriptor(!functionCall(objectPropertyIsEnumerable.f, O, P), O[P]);
  };

  var objectGetOwnPropertyDescriptor = {
  	f: f$1
  };

  // V8 ~ Chrome 36-
  // https://bugs.chromium.org/p/v8/issues/detail?id=3334
  var v8PrototypeDefineBug = descriptors && fails(function () {
    // eslint-disable-next-line es/no-object-defineproperty -- required for testing
    return Object.defineProperty(function () { /* empty */ }, 'prototype', {
      value: 42,
      writable: false
    }).prototype != 42;
  });

  var $String$1 = String;
  var $TypeError$4 = TypeError;

  // `Assert: Type(argument) is Object`
  var anObject = function (argument) {
    if (isObject(argument)) return argument;
    throw $TypeError$4($String$1(argument) + ' is not an object');
  };

  var $TypeError$5 = TypeError;
  // eslint-disable-next-line es/no-object-defineproperty -- safe
  var $defineProperty = Object.defineProperty;
  // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
  var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
  var ENUMERABLE = 'enumerable';
  var CONFIGURABLE = 'configurable';
  var WRITABLE = 'writable';

  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  var f$2 = descriptors ? v8PrototypeDefineBug ? function defineProperty(O, P, Attributes) {
    anObject(O);
    P = toPropertyKey(P);
    anObject(Attributes);
    if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
      var current = $getOwnPropertyDescriptor$1(O, P);
      if (current && current[WRITABLE]) {
        O[P] = Attributes.value;
        Attributes = {
          configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
          enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
          writable: false
        };
      }
    } return $defineProperty(O, P, Attributes);
  } : $defineProperty : function defineProperty(O, P, Attributes) {
    anObject(O);
    P = toPropertyKey(P);
    anObject(Attributes);
    if (ie8DomDefine) try {
      return $defineProperty(O, P, Attributes);
    } catch (error) { /* empty */ }
    if ('get' in Attributes || 'set' in Attributes) throw $TypeError$5('Accessors not supported');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
  };

  var objectDefineProperty = {
  	f: f$2
  };

  var createNonEnumerableProperty = descriptors ? function (object, key, value) {
    return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };

  var FunctionPrototype$1 = Function.prototype;
  // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
  var getDescriptor = descriptors && Object.getOwnPropertyDescriptor;

  var EXISTS$1 = hasOwnProperty_1(FunctionPrototype$1, 'name');
  // additional protection from minified / mangled / dropped function names
  var PROPER = EXISTS$1 && (function something() { /* empty */ }).name === 'something';
  var CONFIGURABLE$1 = EXISTS$1 && (!descriptors || (descriptors && getDescriptor(FunctionPrototype$1, 'name').configurable));

  var functionName = {
    EXISTS: EXISTS$1,
    PROPER: PROPER,
    CONFIGURABLE: CONFIGURABLE$1
  };

  var functionToString = functionUncurryThis(Function.toString);

  // this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
  if (!isCallable(sharedStore.inspectSource)) {
    sharedStore.inspectSource = function (it) {
      return functionToString(it);
    };
  }

  var inspectSource = sharedStore.inspectSource;

  var WeakMap$1 = global_1.WeakMap;

  var weakMapBasicDetection = isCallable(WeakMap$1) && /native code/.test(String(WeakMap$1));

  var keys = shared('keys');

  var sharedKey = function (key) {
    return keys[key] || (keys[key] = uid(key));
  };

  var hiddenKeys = {};

  var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
  var TypeError$1 = global_1.TypeError;
  var WeakMap$2 = global_1.WeakMap;
  var set, get, has;

  var enforce = function (it) {
    return has(it) ? get(it) : set(it, {});
  };

  var getterFor = function (TYPE) {
    return function (it) {
      var state;
      if (!isObject(it) || (state = get(it)).type !== TYPE) {
        throw TypeError$1('Incompatible receiver, ' + TYPE + ' required');
      } return state;
    };
  };

  if (weakMapBasicDetection || sharedStore.state) {
    var store$1 = sharedStore.state || (sharedStore.state = new WeakMap$2());
    /* eslint-disable no-self-assign -- prototype methods protection */
    store$1.get = store$1.get;
    store$1.has = store$1.has;
    store$1.set = store$1.set;
    /* eslint-enable no-self-assign -- prototype methods protection */
    set = function (it, metadata) {
      if (store$1.has(it)) throw TypeError$1(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it;
      store$1.set(it, metadata);
      return metadata;
    };
    get = function (it) {
      return store$1.get(it) || {};
    };
    has = function (it) {
      return store$1.has(it);
    };
  } else {
    var STATE = sharedKey('state');
    hiddenKeys[STATE] = true;
    set = function (it, metadata) {
      if (hasOwnProperty_1(it, STATE)) throw TypeError$1(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it;
      createNonEnumerableProperty(it, STATE, metadata);
      return metadata;
    };
    get = function (it) {
      return hasOwnProperty_1(it, STATE) ? it[STATE] : {};
    };
    has = function (it) {
      return hasOwnProperty_1(it, STATE);
    };
  }

  var internalState = {
    set: set,
    get: get,
    has: has,
    enforce: enforce,
    getterFor: getterFor
  };

  var makeBuiltIn_1 = createCommonjsModule(function (module) {
  var CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;



  var enforceInternalState = internalState.enforce;
  var getInternalState = internalState.get;
  // eslint-disable-next-line es/no-object-defineproperty -- safe
  var defineProperty = Object.defineProperty;

  var CONFIGURABLE_LENGTH = descriptors && !fails(function () {
    return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
  });

  var TEMPLATE = String(String).split('String');

  var makeBuiltIn = module.exports = function (value, name, options) {
    if (String(name).slice(0, 7) === 'Symbol(') {
      name = '[' + String(name).replace(/^Symbol\(([^)]*)\)/, '$1') + ']';
    }
    if (options && options.getter) name = 'get ' + name;
    if (options && options.setter) name = 'set ' + name;
    if (!hasOwnProperty_1(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
      if (descriptors) defineProperty(value, 'name', { value: name, configurable: true });
      else value.name = name;
    }
    if (CONFIGURABLE_LENGTH && options && hasOwnProperty_1(options, 'arity') && value.length !== options.arity) {
      defineProperty(value, 'length', { value: options.arity });
    }
    try {
      if (options && hasOwnProperty_1(options, 'constructor') && options.constructor) {
        if (descriptors) defineProperty(value, 'prototype', { writable: false });
      // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
      } else if (value.prototype) value.prototype = undefined;
    } catch (error) { /* empty */ }
    var state = enforceInternalState(value);
    if (!hasOwnProperty_1(state, 'source')) {
      state.source = TEMPLATE.join(typeof name == 'string' ? name : '');
    } return value;
  };

  // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
  // eslint-disable-next-line no-extend-native -- required
  Function.prototype.toString = makeBuiltIn(function toString() {
    return isCallable(this) && getInternalState(this).source || inspectSource(this);
  }, 'toString');
  });

  var defineBuiltIn = function (O, key, value, options) {
    if (!options) options = {};
    var simple = options.enumerable;
    var name = options.name !== undefined ? options.name : key;
    if (isCallable(value)) makeBuiltIn_1(value, name, options);
    if (options.global) {
      if (simple) O[key] = value;
      else defineGlobalProperty(key, value);
    } else {
      try {
        if (!options.unsafe) delete O[key];
        else if (O[key]) simple = true;
      } catch (error) { /* empty */ }
      if (simple) O[key] = value;
      else objectDefineProperty.f(O, key, {
        value: value,
        enumerable: false,
        configurable: !options.nonConfigurable,
        writable: !options.nonWritable
      });
    } return O;
  };

  var ceil = Math.ceil;
  var floor = Math.floor;

  // `Math.trunc` method
  // https://tc39.es/ecma262/#sec-math.trunc
  // eslint-disable-next-line es/no-math-trunc -- safe
  var mathTrunc = Math.trunc || function trunc(x) {
    var n = +x;
    return (n > 0 ? floor : ceil)(n);
  };

  // `ToIntegerOrInfinity` abstract operation
  // https://tc39.es/ecma262/#sec-tointegerorinfinity
  var toIntegerOrInfinity = function (argument) {
    var number = +argument;
    // eslint-disable-next-line no-self-compare -- NaN check
    return number !== number || number === 0 ? 0 : mathTrunc(number);
  };

  var max = Math.max;
  var min = Math.min;

  // Helper for a popular repeating case of the spec:
  // Let integer be ? ToInteger(index).
  // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
  var toAbsoluteIndex = function (index, length) {
    var integer = toIntegerOrInfinity(index);
    return integer < 0 ? max(integer + length, 0) : min(integer, length);
  };

  var min$1 = Math.min;

  // `ToLength` abstract operation
  // https://tc39.es/ecma262/#sec-tolength
  var toLength = function (argument) {
    return argument > 0 ? min$1(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
  };

  // `LengthOfArrayLike` abstract operation
  // https://tc39.es/ecma262/#sec-lengthofarraylike
  var lengthOfArrayLike = function (obj) {
    return toLength(obj.length);
  };

  // `Array.prototype.{ indexOf, includes }` methods implementation
  var createMethod = function (IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = toIndexedObject($this);
      var length = lengthOfArrayLike(O);
      var index = toAbsoluteIndex(fromIndex, length);
      var value;
      // Array#includes uses SameValueZero equality algorithm
      // eslint-disable-next-line no-self-compare -- NaN check
      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++];
        // eslint-disable-next-line no-self-compare -- NaN check
        if (value != value) return true;
      // Array#indexOf ignores holes, Array#includes - not
      } else for (;length > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
      } return !IS_INCLUDES && -1;
    };
  };

  var arrayIncludes = {
    // `Array.prototype.includes` method
    // https://tc39.es/ecma262/#sec-array.prototype.includes
    includes: createMethod(true),
    // `Array.prototype.indexOf` method
    // https://tc39.es/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod(false)
  };

  var indexOf = arrayIncludes.indexOf;


  var push = functionUncurryThis([].push);

  var objectKeysInternal = function (object, names) {
    var O = toIndexedObject(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O) !hasOwnProperty_1(hiddenKeys, key) && hasOwnProperty_1(O, key) && push(result, key);
    // Don't enum bug & hidden keys
    while (names.length > i) if (hasOwnProperty_1(O, key = names[i++])) {
      ~indexOf(result, key) || push(result, key);
    }
    return result;
  };

  // IE8- don't enum bug keys
  var enumBugKeys = [
    'constructor',
    'hasOwnProperty',
    'isPrototypeOf',
    'propertyIsEnumerable',
    'toLocaleString',
    'toString',
    'valueOf'
  ];

  var hiddenKeys$1 = enumBugKeys.concat('length', 'prototype');

  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  // eslint-disable-next-line es/no-object-getownpropertynames -- safe
  var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return objectKeysInternal(O, hiddenKeys$1);
  };

  var objectGetOwnPropertyNames = {
  	f: f$3
  };

  // eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
  var f$4 = Object.getOwnPropertySymbols;

  var objectGetOwnPropertySymbols = {
  	f: f$4
  };

  var concat = functionUncurryThis([].concat);

  // all object keys, includes non-enumerable and symbols
  var ownKeys$1 = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
    var keys = objectGetOwnPropertyNames.f(anObject(it));
    var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
    return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
  };

  var copyConstructorProperties = function (target, source, exceptions) {
    var keys = ownKeys$1(source);
    var defineProperty = objectDefineProperty.f;
    var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (!hasOwnProperty_1(target, key) && !(exceptions && hasOwnProperty_1(exceptions, key))) {
        defineProperty(target, key, getOwnPropertyDescriptor(source, key));
      }
    }
  };

  var replacement = /#|\.prototype\./;

  var isForced = function (feature, detection) {
    var value = data[normalize(feature)];
    return value == POLYFILL ? true
      : value == NATIVE ? false
      : isCallable(detection) ? fails(detection)
      : !!detection;
  };

  var normalize = isForced.normalize = function (string) {
    return String(string).replace(replacement, '.').toLowerCase();
  };

  var data = isForced.data = {};
  var NATIVE = isForced.NATIVE = 'N';
  var POLYFILL = isForced.POLYFILL = 'P';

  var isForced_1 = isForced;

  var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;






  /*
    options.target         - name of the target object
    options.global         - target is the global object
    options.stat           - export as static methods of target
    options.proto          - export as prototype methods of target
    options.real           - real prototype method for the `pure` version
    options.forced         - export even if the native feature is available
    options.bind           - bind methods to the target, required for the `pure` version
    options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
    options.unsafe         - use the simple assignment of property instead of delete + defineProperty
    options.sham           - add a flag to not completely full polyfills
    options.enumerable     - export as enumerable property
    options.dontCallGetSet - prevent calling a getter on target
    options.name           - the .name of the function if it does not match the key
  */
  var _export = function (options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var FORCED, target, key, targetProperty, sourceProperty, descriptor;
    if (GLOBAL) {
      target = global_1;
    } else if (STATIC) {
      target = global_1[TARGET] || defineGlobalProperty(TARGET, {});
    } else {
      target = (global_1[TARGET] || {}).prototype;
    }
    if (target) for (key in source) {
      sourceProperty = source[key];
      if (options.dontCallGetSet) {
        descriptor = getOwnPropertyDescriptor$1(target, key);
        targetProperty = descriptor && descriptor.value;
      } else targetProperty = target[key];
      FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
      // contained in target
      if (!FORCED && targetProperty !== undefined) {
        if (typeof sourceProperty == typeof targetProperty) continue;
        copyConstructorProperties(sourceProperty, targetProperty);
      }
      // add a flag to not completely full polyfills
      if (options.sham || (targetProperty && targetProperty.sham)) {
        createNonEnumerableProperty(sourceProperty, 'sham', true);
      }
      defineBuiltIn(target, key, sourceProperty, options);
    }
  };

  var bind = functionUncurryThis(functionUncurryThis.bind);

  // optional / simple context binding
  var functionBindContext = function (fn, that) {
    aCallable(fn);
    return that === undefined ? fn : functionBindNative ? bind(fn, that) : function (/* ...args */) {
      return fn.apply(that, arguments);
    };
  };

  // `IsArray` abstract operation
  // https://tc39.es/ecma262/#sec-isarray
  // eslint-disable-next-line es/no-array-isarray -- safe
  var isArray = Array.isArray || function isArray(argument) {
    return classofRaw(argument) == 'Array';
  };

  var TO_STRING_TAG = wellKnownSymbol('toStringTag');
  var test = {};

  test[TO_STRING_TAG] = 'z';

  var toStringTagSupport = String(test) === '[object z]';

  var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');
  var $Object$3 = Object;

  // ES3 wrong here
  var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

  // fallback for IE11 Script Access Denied error
  var tryGet = function (it, key) {
    try {
      return it[key];
    } catch (error) { /* empty */ }
  };

  // getting tag from ES6+ `Object.prototype.toString`
  var classof = toStringTagSupport ? classofRaw : function (it) {
    var O, tag, result;
    return it === undefined ? 'Undefined' : it === null ? 'Null'
      // @@toStringTag case
      : typeof (tag = tryGet(O = $Object$3(it), TO_STRING_TAG$1)) == 'string' ? tag
      // builtinTag case
      : CORRECT_ARGUMENTS ? classofRaw(O)
      // ES3 arguments fallback
      : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
  };

  var noop = function () { /* empty */ };
  var empty = [];
  var construct = getBuiltIn('Reflect', 'construct');
  var constructorRegExp = /^\s*(?:class|function)\b/;
  var exec = functionUncurryThis(constructorRegExp.exec);
  var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);

  var isConstructorModern = function isConstructor(argument) {
    if (!isCallable(argument)) return false;
    try {
      construct(noop, empty, argument);
      return true;
    } catch (error) {
      return false;
    }
  };

  var isConstructorLegacy = function isConstructor(argument) {
    if (!isCallable(argument)) return false;
    switch (classof(argument)) {
      case 'AsyncFunction':
      case 'GeneratorFunction':
      case 'AsyncGeneratorFunction': return false;
    }
    try {
      // we can't check .prototype since constructors produced by .bind haven't it
      // `Function#toString` throws on some built-it function in some legacy engines
      // (for example, `DOMQuad` and similar in FF41-)
      return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
    } catch (error) {
      return true;
    }
  };

  isConstructorLegacy.sham = true;

  // `IsConstructor` abstract operation
  // https://tc39.es/ecma262/#sec-isconstructor
  var isConstructor = !construct || fails(function () {
    var called;
    return isConstructorModern(isConstructorModern.call)
      || !isConstructorModern(Object)
      || !isConstructorModern(function () { called = true; })
      || called;
  }) ? isConstructorLegacy : isConstructorModern;

  var SPECIES = wellKnownSymbol('species');
  var $Array = Array;

  // a part of `ArraySpeciesCreate` abstract operation
  // https://tc39.es/ecma262/#sec-arrayspeciescreate
  var arraySpeciesConstructor = function (originalArray) {
    var C;
    if (isArray(originalArray)) {
      C = originalArray.constructor;
      // cross-realm fallback
      if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = undefined;
      else if (isObject(C)) {
        C = C[SPECIES];
        if (C === null) C = undefined;
      }
    } return C === undefined ? $Array : C;
  };

  // `ArraySpeciesCreate` abstract operation
  // https://tc39.es/ecma262/#sec-arrayspeciescreate
  var arraySpeciesCreate = function (originalArray, length) {
    return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
  };

  var push$1 = functionUncurryThis([].push);

  // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
  var createMethod$1 = function (TYPE) {
    var IS_MAP = TYPE == 1;
    var IS_FILTER = TYPE == 2;
    var IS_SOME = TYPE == 3;
    var IS_EVERY = TYPE == 4;
    var IS_FIND_INDEX = TYPE == 6;
    var IS_FILTER_REJECT = TYPE == 7;
    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    return function ($this, callbackfn, that, specificCreate) {
      var O = toObject($this);
      var self = indexedObject(O);
      var boundFunction = functionBindContext(callbackfn, that);
      var length = lengthOfArrayLike(self);
      var index = 0;
      var create = specificCreate || arraySpeciesCreate;
      var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
      var value, result;
      for (;length > index; index++) if (NO_HOLES || index in self) {
        value = self[index];
        result = boundFunction(value, index, O);
        if (TYPE) {
          if (IS_MAP) target[index] = result; // map
          else if (result) switch (TYPE) {
            case 3: return true;              // some
            case 5: return value;             // find
            case 6: return index;             // findIndex
            case 2: push$1(target, value);      // filter
          } else switch (TYPE) {
            case 4: return false;             // every
            case 7: push$1(target, value);      // filterReject
          }
        }
      }
      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
    };
  };

  var arrayIteration = {
    // `Array.prototype.forEach` method
    // https://tc39.es/ecma262/#sec-array.prototype.foreach
    forEach: createMethod$1(0),
    // `Array.prototype.map` method
    // https://tc39.es/ecma262/#sec-array.prototype.map
    map: createMethod$1(1),
    // `Array.prototype.filter` method
    // https://tc39.es/ecma262/#sec-array.prototype.filter
    filter: createMethod$1(2),
    // `Array.prototype.some` method
    // https://tc39.es/ecma262/#sec-array.prototype.some
    some: createMethod$1(3),
    // `Array.prototype.every` method
    // https://tc39.es/ecma262/#sec-array.prototype.every
    every: createMethod$1(4),
    // `Array.prototype.find` method
    // https://tc39.es/ecma262/#sec-array.prototype.find
    find: createMethod$1(5),
    // `Array.prototype.findIndex` method
    // https://tc39.es/ecma262/#sec-array.prototype.findIndex
    findIndex: createMethod$1(6),
    // `Array.prototype.filterReject` method
    // https://github.com/tc39/proposal-array-filtering
    filterReject: createMethod$1(7)
  };

  var SPECIES$1 = wellKnownSymbol('species');

  var arrayMethodHasSpeciesSupport = function (METHOD_NAME) {
    // We can't use this feature detection in V8 since it causes
    // deoptimization and serious performance degradation
    // https://github.com/zloirock/core-js/issues/677
    return engineV8Version >= 51 || !fails(function () {
      var array = [];
      var constructor = array.constructor = {};
      constructor[SPECIES$1] = function () {
        return { foo: 1 };
      };
      return array[METHOD_NAME](Boolean).foo !== 1;
    });
  };

  var $map = arrayIteration.map;


  var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');

  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  // with adding support of @@species
  _export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
    map: function map(callbackfn /* , thisArg */) {
      return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  var $TypeError$6 = TypeError;

  var deletePropertyOrThrow = function (O, P) {
    if (!delete O[P]) throw $TypeError$6('Cannot delete property ' + tryToString(P) + ' of ' + tryToString(O));
  };

  var $String$2 = String;

  var toString_1 = function (argument) {
    if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
    return $String$2(argument);
  };

  var createProperty = function (object, key, value) {
    var propertyKey = toPropertyKey(key);
    if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));
    else object[propertyKey] = value;
  };

  var $Array$1 = Array;
  var max$1 = Math.max;

  var arraySliceSimple = function (O, start, end) {
    var length = lengthOfArrayLike(O);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    var result = $Array$1(max$1(fin - k, 0));
    for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);
    result.length = n;
    return result;
  };

  var floor$1 = Math.floor;

  var mergeSort = function (array, comparefn) {
    var length = array.length;
    var middle = floor$1(length / 2);
    return length < 8 ? insertionSort(array, comparefn) : merge(
      array,
      mergeSort(arraySliceSimple(array, 0, middle), comparefn),
      mergeSort(arraySliceSimple(array, middle), comparefn),
      comparefn
    );
  };

  var insertionSort = function (array, comparefn) {
    var length = array.length;
    var i = 1;
    var element, j;

    while (i < length) {
      j = i;
      element = array[i];
      while (j && comparefn(array[j - 1], element) > 0) {
        array[j] = array[--j];
      }
      if (j !== i++) array[j] = element;
    } return array;
  };

  var merge = function (array, left, right, comparefn) {
    var llength = left.length;
    var rlength = right.length;
    var lindex = 0;
    var rindex = 0;

    while (lindex < llength || rindex < rlength) {
      array[lindex + rindex] = (lindex < llength && rindex < rlength)
        ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]
        : lindex < llength ? left[lindex++] : right[rindex++];
    } return array;
  };

  var arraySort = mergeSort;

  var arrayMethodIsStrict = function (METHOD_NAME, argument) {
    var method = [][METHOD_NAME];
    return !!method && fails(function () {
      // eslint-disable-next-line no-useless-call -- required for testing
      method.call(null, argument || function () { return 1; }, 1);
    });
  };

  var firefox = engineUserAgent.match(/firefox\/(\d+)/i);

  var engineFfVersion = !!firefox && +firefox[1];

  var engineIsIeOrEdge = /MSIE|Trident/.test(engineUserAgent);

  var webkit = engineUserAgent.match(/AppleWebKit\/(\d+)\./);

  var engineWebkitVersion = !!webkit && +webkit[1];

  var test$1 = [];
  var nativeSort = functionUncurryThis(test$1.sort);
  var push$2 = functionUncurryThis(test$1.push);

  // IE8-
  var FAILS_ON_UNDEFINED = fails(function () {
    test$1.sort(undefined);
  });
  // V8 bug
  var FAILS_ON_NULL = fails(function () {
    test$1.sort(null);
  });
  // Old WebKit
  var STRICT_METHOD = arrayMethodIsStrict('sort');

  var STABLE_SORT = !fails(function () {
    // feature detection can be too slow, so check engines versions
    if (engineV8Version) return engineV8Version < 70;
    if (engineFfVersion && engineFfVersion > 3) return;
    if (engineIsIeOrEdge) return true;
    if (engineWebkitVersion) return engineWebkitVersion < 603;

    var result = '';
    var code, chr, value, index;

    // generate an array with more 512 elements (Chakra and old V8 fails only in this case)
    for (code = 65; code < 76; code++) {
      chr = String.fromCharCode(code);

      switch (code) {
        case 66: case 69: case 70: case 72: value = 3; break;
        case 68: case 71: value = 4; break;
        default: value = 2;
      }

      for (index = 0; index < 47; index++) {
        test$1.push({ k: chr + index, v: value });
      }
    }

    test$1.sort(function (a, b) { return b.v - a.v; });

    for (index = 0; index < test$1.length; index++) {
      chr = test$1[index].k.charAt(0);
      if (result.charAt(result.length - 1) !== chr) result += chr;
    }

    return result !== 'DGBEFHACIJK';
  });

  var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;

  var getSortCompare = function (comparefn) {
    return function (x, y) {
      if (y === undefined) return -1;
      if (x === undefined) return 1;
      if (comparefn !== undefined) return +comparefn(x, y) || 0;
      return toString_1(x) > toString_1(y) ? 1 : -1;
    };
  };

  // `Array.prototype.sort` method
  // https://tc39.es/ecma262/#sec-array.prototype.sort
  _export({ target: 'Array', proto: true, forced: FORCED }, {
    sort: function sort(comparefn) {
      if (comparefn !== undefined) aCallable(comparefn);

      var array = toObject(this);

      if (STABLE_SORT) return comparefn === undefined ? nativeSort(array) : nativeSort(array, comparefn);

      var items = [];
      var arrayLength = lengthOfArrayLike(array);
      var itemsLength, index;

      for (index = 0; index < arrayLength; index++) {
        if (index in array) push$2(items, array[index]);
      }

      arraySort(items, getSortCompare(comparefn));

      itemsLength = lengthOfArrayLike(items);
      index = 0;

      while (index < itemsLength) array[index] = items[index++];
      while (index < arrayLength) deletePropertyOrThrow(array, index++);

      return array;
    }
  });

  var floor$2 = Math.floor;

  // `IsIntegralNumber` abstract operation
  // https://tc39.es/ecma262/#sec-isintegralnumber
  // eslint-disable-next-line es/no-number-isinteger -- safe
  var isIntegralNumber = Number.isInteger || function isInteger(it) {
    return !isObject(it) && isFinite(it) && floor$2(it) === it;
  };

  // `Number.isInteger` method
  // https://tc39.es/ecma262/#sec-number.isinteger
  _export({ target: 'Number', stat: true }, {
    isInteger: isIntegralNumber
  });

  var $String$3 = String;
  var $TypeError$7 = TypeError;

  var aPossiblePrototype = function (argument) {
    if (typeof argument == 'object' || isCallable(argument)) return argument;
    throw $TypeError$7("Can't set " + $String$3(argument) + ' as a prototype');
  };

  /* eslint-disable no-proto -- safe */




  // `Object.setPrototypeOf` method
  // https://tc39.es/ecma262/#sec-object.setprototypeof
  // Works with __proto__ only. Old v8 can't work with null proto objects.
  // eslint-disable-next-line es/no-object-setprototypeof -- safe
  var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
    var CORRECT_SETTER = false;
    var test = {};
    var setter;
    try {
      // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
      setter = functionUncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);
      setter(test, []);
      CORRECT_SETTER = test instanceof Array;
    } catch (error) { /* empty */ }
    return function setPrototypeOf(O, proto) {
      anObject(O);
      aPossiblePrototype(proto);
      if (CORRECT_SETTER) setter(O, proto);
      else O.__proto__ = proto;
      return O;
    };
  }() : undefined);

  // makes subclassing work correct for wrapped built-ins
  var inheritIfRequired = function ($this, dummy, Wrapper) {
    var NewTarget, NewTargetPrototype;
    if (
      // it can work only with native `setPrototypeOf`
      objectSetPrototypeOf &&
      // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
      isCallable(NewTarget = dummy.constructor) &&
      NewTarget !== Wrapper &&
      isObject(NewTargetPrototype = NewTarget.prototype) &&
      NewTargetPrototype !== Wrapper.prototype
    ) objectSetPrototypeOf($this, NewTargetPrototype);
    return $this;
  };

  // `thisNumberValue` abstract operation
  // https://tc39.es/ecma262/#sec-thisnumbervalue
  var thisNumberValue = functionUncurryThis(1.0.valueOf);

  // a string of all valid unicode whitespaces
  var whitespaces = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
    '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

  var replace = functionUncurryThis(''.replace);
  var whitespace = '[' + whitespaces + ']';
  var ltrim = RegExp('^' + whitespace + whitespace + '*');
  var rtrim = RegExp(whitespace + whitespace + '*$');

  // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
  var createMethod$2 = function (TYPE) {
    return function ($this) {
      var string = toString_1(requireObjectCoercible($this));
      if (TYPE & 1) string = replace(string, ltrim, '');
      if (TYPE & 2) string = replace(string, rtrim, '');
      return string;
    };
  };

  var stringTrim = {
    // `String.prototype.{ trimLeft, trimStart }` methods
    // https://tc39.es/ecma262/#sec-string.prototype.trimstart
    start: createMethod$2(1),
    // `String.prototype.{ trimRight, trimEnd }` methods
    // https://tc39.es/ecma262/#sec-string.prototype.trimend
    end: createMethod$2(2),
    // `String.prototype.trim` method
    // https://tc39.es/ecma262/#sec-string.prototype.trim
    trim: createMethod$2(3)
  };

  var getOwnPropertyNames = objectGetOwnPropertyNames.f;
  var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
  var defineProperty$1 = objectDefineProperty.f;

  var trim = stringTrim.trim;

  var NUMBER = 'Number';
  var NativeNumber = global_1[NUMBER];
  var NumberPrototype = NativeNumber.prototype;
  var TypeError$2 = global_1.TypeError;
  var arraySlice = functionUncurryThis(''.slice);
  var charCodeAt = functionUncurryThis(''.charCodeAt);

  // `ToNumeric` abstract operation
  // https://tc39.es/ecma262/#sec-tonumeric
  var toNumeric = function (value) {
    var primValue = toPrimitive(value, 'number');
    return typeof primValue == 'bigint' ? primValue : toNumber(primValue);
  };

  // `ToNumber` abstract operation
  // https://tc39.es/ecma262/#sec-tonumber
  var toNumber = function (argument) {
    var it = toPrimitive(argument, 'number');
    var first, third, radix, maxCode, digits, length, index, code;
    if (isSymbol(it)) throw TypeError$2('Cannot convert a Symbol value to a number');
    if (typeof it == 'string' && it.length > 2) {
      it = trim(it);
      first = charCodeAt(it, 0);
      if (first === 43 || first === 45) {
        third = charCodeAt(it, 2);
        if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
      } else if (first === 48) {
        switch (charCodeAt(it, 1)) {
          case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i
          case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i
          default: return +it;
        }
        digits = arraySlice(it, 2);
        length = digits.length;
        for (index = 0; index < length; index++) {
          code = charCodeAt(digits, index);
          // parseInt parses a string to a first unavailable symbol
          // but ToNumber should return NaN if a string contains unavailable symbols
          if (code < 48 || code > maxCode) return NaN;
        } return parseInt(digits, radix);
      }
    } return +it;
  };

  // `Number` constructor
  // https://tc39.es/ecma262/#sec-number-constructor
  if (isForced_1(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
    var NumberWrapper = function Number(value) {
      var n = arguments.length < 1 ? 0 : NativeNumber(toNumeric(value));
      var dummy = this;
      // check on 1..constructor(foo) case
      return objectIsPrototypeOf(NumberPrototype, dummy) && fails(function () { thisNumberValue(dummy); })
        ? inheritIfRequired(Object(n), dummy, NumberWrapper) : n;
    };
    for (var keys$1 = descriptors ? getOwnPropertyNames(NativeNumber) : (
      // ES3:
      'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
      // ES2015 (in case, if modules with ES2015 Number statics required before):
      'EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,' +
      // ESNext
      'fromString,range'
    ).split(','), j = 0, key; keys$1.length > j; j++) {
      if (hasOwnProperty_1(NativeNumber, key = keys$1[j]) && !hasOwnProperty_1(NumberWrapper, key)) {
        defineProperty$1(NumberWrapper, key, getOwnPropertyDescriptor$2(NativeNumber, key));
      }
    }
    NumberWrapper.prototype = NumberPrototype;
    NumberPrototype.constructor = NumberWrapper;
    defineBuiltIn(global_1, NUMBER, NumberWrapper, { constructor: true });
  }

  // TODO: Remove from `core-js@4`



  var DatePrototype = Date.prototype;
  var INVALID_DATE = 'Invalid Date';
  var TO_STRING = 'toString';
  var nativeDateToString = functionUncurryThis(DatePrototype[TO_STRING]);
  var thisTimeValue = functionUncurryThis(DatePrototype.getTime);

  // `Date.prototype.toString` method
  // https://tc39.es/ecma262/#sec-date.prototype.tostring
  if (String(new Date(NaN)) != INVALID_DATE) {
    defineBuiltIn(DatePrototype, TO_STRING, function toString() {
      var value = thisTimeValue(this);
      // eslint-disable-next-line no-self-compare -- NaN check
      return value === value ? nativeDateToString(this) : INVALID_DATE;
    });
  }

  // `Object.prototype.toString` method implementation
  // https://tc39.es/ecma262/#sec-object.prototype.tostring
  var objectToString = toStringTagSupport ? {}.toString : function toString() {
    return '[object ' + classof(this) + ']';
  };

  // `Object.prototype.toString` method
  // https://tc39.es/ecma262/#sec-object.prototype.tostring
  if (!toStringTagSupport) {
    defineBuiltIn(Object.prototype, 'toString', objectToString, { unsafe: true });
  }

  // `RegExp.prototype.flags` getter implementation
  // https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
  var regexpFlags = function () {
    var that = anObject(this);
    var result = '';
    if (that.hasIndices) result += 'd';
    if (that.global) result += 'g';
    if (that.ignoreCase) result += 'i';
    if (that.multiline) result += 'm';
    if (that.dotAll) result += 's';
    if (that.unicode) result += 'u';
    if (that.unicodeSets) result += 'v';
    if (that.sticky) result += 'y';
    return result;
  };

  var RegExpPrototype = RegExp.prototype;

  var regexpGetFlags = function (R) {
    var flags = R.flags;
    return flags === undefined && !('flags' in RegExpPrototype) && !hasOwnProperty_1(R, 'flags') && objectIsPrototypeOf(RegExpPrototype, R)
      ? functionCall(regexpFlags, R) : flags;
  };

  var PROPER_FUNCTION_NAME = functionName.PROPER;






  var TO_STRING$1 = 'toString';
  var RegExpPrototype$1 = RegExp.prototype;
  var nativeToString = RegExpPrototype$1[TO_STRING$1];

  var NOT_GENERIC = fails(function () { return nativeToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });
  // FF44- RegExp#toString has a wrong name
  var INCORRECT_NAME = PROPER_FUNCTION_NAME && nativeToString.name != TO_STRING$1;

  // `RegExp.prototype.toString` method
  // https://tc39.es/ecma262/#sec-regexp.prototype.tostring
  if (NOT_GENERIC || INCORRECT_NAME) {
    defineBuiltIn(RegExp.prototype, TO_STRING$1, function toString() {
      var R = anObject(this);
      var pattern = toString_1(R.source);
      var flags = toString_1(regexpGetFlags(R));
      return '/' + pattern + '/' + flags;
    }, { unsafe: true });
  }

  var $forEach = arrayIteration.forEach;


  var STRICT_METHOD$1 = arrayMethodIsStrict('forEach');

  // `Array.prototype.forEach` method implementation
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  var arrayForEach = !STRICT_METHOD$1 ? function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  // eslint-disable-next-line es/no-array-prototype-foreach -- safe
  } : [].forEach;

  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  // eslint-disable-next-line es/no-array-prototype-foreach -- safe
  _export({ target: 'Array', proto: true, forced: [].forEach != arrayForEach }, {
    forEach: arrayForEach
  });

  // iterable DOM collections
  // flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
  var domIterables = {
    CSSRuleList: 0,
    CSSStyleDeclaration: 0,
    CSSValueList: 0,
    ClientRectList: 0,
    DOMRectList: 0,
    DOMStringList: 0,
    DOMTokenList: 1,
    DataTransferItemList: 0,
    FileList: 0,
    HTMLAllCollection: 0,
    HTMLCollection: 0,
    HTMLFormElement: 0,
    HTMLSelectElement: 0,
    MediaList: 0,
    MimeTypeArray: 0,
    NamedNodeMap: 0,
    NodeList: 1,
    PaintRequestList: 0,
    Plugin: 0,
    PluginArray: 0,
    SVGLengthList: 0,
    SVGNumberList: 0,
    SVGPathSegList: 0,
    SVGPointList: 0,
    SVGStringList: 0,
    SVGTransformList: 0,
    SourceBufferList: 0,
    StyleSheetList: 0,
    TextTrackCueList: 0,
    TextTrackList: 0,
    TouchList: 0
  };

  // in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`


  var classList = documentCreateElement('span').classList;
  var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;

  var domTokenListPrototype = DOMTokenListPrototype === Object.prototype ? undefined : DOMTokenListPrototype;

  var handlePrototype = function (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype && CollectionPrototype.forEach !== arrayForEach) try {
      createNonEnumerableProperty(CollectionPrototype, 'forEach', arrayForEach);
    } catch (error) {
      CollectionPrototype.forEach = arrayForEach;
    }
  };

  for (var COLLECTION_NAME in domIterables) {
    if (domIterables[COLLECTION_NAME]) {
      handlePrototype(global_1[COLLECTION_NAME] && global_1[COLLECTION_NAME].prototype);
    }
  }

  handlePrototype(domTokenListPrototype);

  var $TypeError$8 = TypeError;
  // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
  var getOwnPropertyDescriptor$3 = Object.getOwnPropertyDescriptor;

  // Safari < 13 does not throw an error in this case
  var SILENT_ON_NON_WRITABLE_LENGTH_SET = descriptors && !function () {
    // makes no sense without proper strict mode support
    if (this !== undefined) return true;
    try {
      // eslint-disable-next-line es/no-object-defineproperty -- safe
      Object.defineProperty([], 'length', { writable: false }).length = 1;
    } catch (error) {
      return error instanceof TypeError;
    }
  }();

  var arraySetLength = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function (O, length) {
    if (isArray(O) && !getOwnPropertyDescriptor$3(O, 'length').writable) {
      throw $TypeError$8('Cannot set read only .length');
    } return O.length = length;
  } : function (O, length) {
    return O.length = length;
  };

  var $TypeError$9 = TypeError;
  var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991

  var doesNotExceedSafeInteger = function (it) {
    if (it > MAX_SAFE_INTEGER) throw $TypeError$9('Maximum allowed index exceeded');
    return it;
  };

  var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport('splice');

  var max$2 = Math.max;
  var min$2 = Math.min;

  // `Array.prototype.splice` method
  // https://tc39.es/ecma262/#sec-array.prototype.splice
  // with adding support of @@species
  _export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$1 }, {
    splice: function splice(start, deleteCount /* , ...items */) {
      var O = toObject(this);
      var len = lengthOfArrayLike(O);
      var actualStart = toAbsoluteIndex(start, len);
      var argumentsLength = arguments.length;
      var insertCount, actualDeleteCount, A, k, from, to;
      if (argumentsLength === 0) {
        insertCount = actualDeleteCount = 0;
      } else if (argumentsLength === 1) {
        insertCount = 0;
        actualDeleteCount = len - actualStart;
      } else {
        insertCount = argumentsLength - 2;
        actualDeleteCount = min$2(max$2(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
      }
      doesNotExceedSafeInteger(len + insertCount - actualDeleteCount);
      A = arraySpeciesCreate(O, actualDeleteCount);
      for (k = 0; k < actualDeleteCount; k++) {
        from = actualStart + k;
        if (from in O) createProperty(A, k, O[from]);
      }
      A.length = actualDeleteCount;
      if (insertCount < actualDeleteCount) {
        for (k = actualStart; k < len - actualDeleteCount; k++) {
          from = k + actualDeleteCount;
          to = k + insertCount;
          if (from in O) O[to] = O[from];
          else deletePropertyOrThrow(O, to);
        }
        for (k = len; k > len - actualDeleteCount + insertCount; k--) deletePropertyOrThrow(O, k - 1);
      } else if (insertCount > actualDeleteCount) {
        for (k = len - actualDeleteCount; k > actualStart; k--) {
          from = k + actualDeleteCount - 1;
          to = k + insertCount - 1;
          if (from in O) O[to] = O[from];
          else deletePropertyOrThrow(O, to);
        }
      }
      for (k = 0; k < insertCount; k++) {
        O[k + actualStart] = arguments[k + 2];
      }
      arraySetLength(O, len - actualDeleteCount + insertCount);
      return A;
    }
  });

  // `Object.keys` method
  // https://tc39.es/ecma262/#sec-object.keys
  // eslint-disable-next-line es/no-object-keys -- safe
  var objectKeys = Object.keys || function keys(O) {
    return objectKeysInternal(O, enumBugKeys);
  };

  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  // eslint-disable-next-line es/no-object-defineproperties -- safe
  var f$5 = descriptors && !v8PrototypeDefineBug ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject(O);
    var props = toIndexedObject(Properties);
    var keys = objectKeys(Properties);
    var length = keys.length;
    var index = 0;
    var key;
    while (length > index) objectDefineProperty.f(O, key = keys[index++], props[key]);
    return O;
  };

  var objectDefineProperties = {
  	f: f$5
  };

  var html = getBuiltIn('document', 'documentElement');

  /* global ActiveXObject -- old IE, WSH */








  var GT = '>';
  var LT = '<';
  var PROTOTYPE = 'prototype';
  var SCRIPT = 'script';
  var IE_PROTO = sharedKey('IE_PROTO');

  var EmptyConstructor = function () { /* empty */ };

  var scriptTag = function (content) {
    return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
  };

  // Create object with fake `null` prototype: use ActiveX Object with cleared prototype
  var NullProtoObjectViaActiveX = function (activeXDocument) {
    activeXDocument.write(scriptTag(''));
    activeXDocument.close();
    var temp = activeXDocument.parentWindow.Object;
    activeXDocument = null; // avoid memory leak
    return temp;
  };

  // Create object with fake `null` prototype: use iframe Object with cleared prototype
  var NullProtoObjectViaIFrame = function () {
    // Thrash, waste and sodomy: IE GC bug
    var iframe = documentCreateElement('iframe');
    var JS = 'java' + SCRIPT + ':';
    var iframeDocument;
    iframe.style.display = 'none';
    html.appendChild(iframe);
    // https://github.com/zloirock/core-js/issues/475
    iframe.src = String(JS);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(scriptTag('document.F=Object'));
    iframeDocument.close();
    return iframeDocument.F;
  };

  // Check for document.domain and active x support
  // No need to use active x approach when document.domain is not set
  // see https://github.com/es-shims/es5-shim/issues/150
  // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
  // avoid IE GC bug
  var activeXDocument;
  var NullProtoObject = function () {
    try {
      activeXDocument = new ActiveXObject('htmlfile');
    } catch (error) { /* ignore */ }
    NullProtoObject = typeof document != 'undefined'
      ? document.domain && activeXDocument
        ? NullProtoObjectViaActiveX(activeXDocument) // old IE
        : NullProtoObjectViaIFrame()
      : NullProtoObjectViaActiveX(activeXDocument); // WSH
    var length = enumBugKeys.length;
    while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
    return NullProtoObject();
  };

  hiddenKeys[IE_PROTO] = true;

  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  // eslint-disable-next-line es/no-object-create -- safe
  var objectCreate = Object.create || function create(O, Properties) {
    var result;
    if (O !== null) {
      EmptyConstructor[PROTOTYPE] = anObject(O);
      result = new EmptyConstructor();
      EmptyConstructor[PROTOTYPE] = null;
      // add "__proto__" for Object.getPrototypeOf polyfill
      result[IE_PROTO] = O;
    } else result = NullProtoObject();
    return Properties === undefined ? result : objectDefineProperties.f(result, Properties);
  };

  var defineProperty$2 = objectDefineProperty.f;

  var UNSCOPABLES = wellKnownSymbol('unscopables');
  var ArrayPrototype = Array.prototype;

  // Array.prototype[@@unscopables]
  // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
  if (ArrayPrototype[UNSCOPABLES] == undefined) {
    defineProperty$2(ArrayPrototype, UNSCOPABLES, {
      configurable: true,
      value: objectCreate(null)
    });
  }

  // add a key to Array.prototype[@@unscopables]
  var addToUnscopables = function (key) {
    ArrayPrototype[UNSCOPABLES][key] = true;
  };

  var $find = arrayIteration.find;


  var FIND = 'find';
  var SKIPS_HOLES = true;

  // Shouldn't skip holes
  if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });

  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  _export({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {
    find: function find(callbackfn /* , that = undefined */) {
      return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
  addToUnscopables(FIND);

  var FUNCTION_NAME_EXISTS = functionName.EXISTS;

  var defineProperty$3 = objectDefineProperty.f;

  var FunctionPrototype$2 = Function.prototype;
  var functionToString$1 = functionUncurryThis(FunctionPrototype$2.toString);
  var nameRE = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/;
  var regExpExec = functionUncurryThis(nameRE.exec);
  var NAME = 'name';

  // Function instances `.name` property
  // https://tc39.es/ecma262/#sec-function-instances-name
  if (descriptors && !FUNCTION_NAME_EXISTS) {
    defineProperty$3(FunctionPrototype$2, NAME, {
      configurable: true,
      get: function () {
        try {
          return regExpExec(nameRE, functionToString$1(this))[1];
        } catch (error) {
          return '';
        }
      }
    });
  }

  var $findIndex = arrayIteration.findIndex;


  var FIND_INDEX = 'findIndex';
  var SKIPS_HOLES$1 = true;

  // Shouldn't skip holes
  if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () { SKIPS_HOLES$1 = false; });

  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findindex
  _export({ target: 'Array', proto: true, forced: SKIPS_HOLES$1 }, {
    findIndex: function findIndex(callbackfn /* , that = undefined */) {
      return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
  addToUnscopables(FIND_INDEX);

  var $filter = arrayIteration.filter;


  var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport('filter');

  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  // with adding support of @@species
  _export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$2 }, {
    filter: function filter(callbackfn /* , thisArg */) {
      return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  var $includes = arrayIncludes.includes;



  // FF99+ bug
  var BROKEN_ON_SPARSE = fails(function () {
    return !Array(1).includes();
  });

  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  _export({ target: 'Array', proto: true, forced: BROKEN_ON_SPARSE }, {
    includes: function includes(el /* , fromIndex = 0 */) {
      return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
  addToUnscopables('includes');

  var MATCH = wellKnownSymbol('match');

  // `IsRegExp` abstract operation
  // https://tc39.es/ecma262/#sec-isregexp
  var isRegexp = function (it) {
    var isRegExp;
    return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');
  };

  var $TypeError$a = TypeError;

  var notARegexp = function (it) {
    if (isRegexp(it)) {
      throw $TypeError$a("The method doesn't accept regular expressions");
    } return it;
  };

  var MATCH$1 = wellKnownSymbol('match');

  var correctIsRegexpLogic = function (METHOD_NAME) {
    var regexp = /./;
    try {
      '/./'[METHOD_NAME](regexp);
    } catch (error1) {
      try {
        regexp[MATCH$1] = false;
        return '/./'[METHOD_NAME](regexp);
      } catch (error2) { /* empty */ }
    } return false;
  };

  var stringIndexOf = functionUncurryThis(''.indexOf);

  // `String.prototype.includes` method
  // https://tc39.es/ecma262/#sec-string.prototype.includes
  _export({ target: 'String', proto: true, forced: !correctIsRegexpLogic('includes') }, {
    includes: function includes(searchString /* , position = 0 */) {
      return !!~stringIndexOf(
        toString_1(requireObjectCoercible(this)),
        toString_1(notARegexp(searchString)),
        arguments.length > 1 ? arguments[1] : undefined
      );
    }
  });

  var nativeJoin = functionUncurryThis([].join);

  var ES3_STRINGS = indexedObject != Object;
  var STRICT_METHOD$2 = arrayMethodIsStrict('join', ',');

  // `Array.prototype.join` method
  // https://tc39.es/ecma262/#sec-array.prototype.join
  _export({ target: 'Array', proto: true, forced: ES3_STRINGS || !STRICT_METHOD$2 }, {
    join: function join(separator) {
      return nativeJoin(toIndexedObject(this), separator === undefined ? ',' : separator);
    }
  });

  var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');

  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/679
  var IS_CONCAT_SPREADABLE_SUPPORT = engineV8Version >= 51 || !fails(function () {
    var array = [];
    array[IS_CONCAT_SPREADABLE] = false;
    return array.concat()[0] !== array;
  });

  var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

  var isConcatSpreadable = function (O) {
    if (!isObject(O)) return false;
    var spreadable = O[IS_CONCAT_SPREADABLE];
    return spreadable !== undefined ? !!spreadable : isArray(O);
  };

  var FORCED$1 = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

  // `Array.prototype.concat` method
  // https://tc39.es/ecma262/#sec-array.prototype.concat
  // with adding support of @@isConcatSpreadable and @@species
  _export({ target: 'Array', proto: true, arity: 1, forced: FORCED$1 }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    concat: function concat(arg) {
      var O = toObject(this);
      var A = arraySpeciesCreate(O, 0);
      var n = 0;
      var i, k, length, len, E;
      for (i = -1, length = arguments.length; i < length; i++) {
        E = i === -1 ? O : arguments[i];
        if (isConcatSpreadable(E)) {
          len = lengthOfArrayLike(E);
          doesNotExceedSafeInteger(n + len);
          for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
        } else {
          doesNotExceedSafeInteger(n + 1);
          createProperty(A, n++, E);
        }
      }
      A.length = n;
      return A;
    }
  });

  var arraySlice$1 = functionUncurryThis([].slice);

  var HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport('slice');

  var SPECIES$2 = wellKnownSymbol('species');
  var $Array$2 = Array;
  var max$3 = Math.max;

  // `Array.prototype.slice` method
  // https://tc39.es/ecma262/#sec-array.prototype.slice
  // fallback for not array-like ES3 strings and DOM objects
  _export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$3 }, {
    slice: function slice(start, end) {
      var O = toIndexedObject(this);
      var length = lengthOfArrayLike(O);
      var k = toAbsoluteIndex(start, length);
      var fin = toAbsoluteIndex(end === undefined ? length : end, length);
      // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
      var Constructor, result, n;
      if (isArray(O)) {
        Constructor = O.constructor;
        // cross-realm fallback
        if (isConstructor(Constructor) && (Constructor === $Array$2 || isArray(Constructor.prototype))) {
          Constructor = undefined;
        } else if (isObject(Constructor)) {
          Constructor = Constructor[SPECIES$2];
          if (Constructor === null) Constructor = undefined;
        }
        if (Constructor === $Array$2 || Constructor === undefined) {
          return arraySlice$1(O, k, fin);
        }
      }
      result = new (Constructor === undefined ? $Array$2 : Constructor)(max$3(fin - k, 0));
      for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
      result.length = n;
      return result;
    }
  });

  // babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
  var $RegExp = global_1.RegExp;

  var UNSUPPORTED_Y = fails(function () {
    var re = $RegExp('a', 'y');
    re.lastIndex = 2;
    return re.exec('abcd') != null;
  });

  // UC Browser bug
  // https://github.com/zloirock/core-js/issues/1008
  var MISSED_STICKY = UNSUPPORTED_Y || fails(function () {
    return !$RegExp('a', 'y').sticky;
  });

  var BROKEN_CARET = UNSUPPORTED_Y || fails(function () {
    // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
    var re = $RegExp('^r', 'gy');
    re.lastIndex = 2;
    return re.exec('str') != null;
  });

  var regexpStickyHelpers = {
    BROKEN_CARET: BROKEN_CARET,
    MISSED_STICKY: MISSED_STICKY,
    UNSUPPORTED_Y: UNSUPPORTED_Y
  };

  // babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError
  var $RegExp$1 = global_1.RegExp;

  var regexpUnsupportedDotAll = fails(function () {
    var re = $RegExp$1('.', 's');
    return !(re.dotAll && re.exec('\n') && re.flags === 's');
  });

  // babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError
  var $RegExp$2 = global_1.RegExp;

  var regexpUnsupportedNcg = fails(function () {
    var re = $RegExp$2('(?<a>b)', 'g');
    return re.exec('b').groups.a !== 'b' ||
      'b'.replace(re, '$<a>c') !== 'bc';
  });

  /* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */
  /* eslint-disable regexp/no-useless-quantifier -- testing */







  var getInternalState = internalState.get;



  var nativeReplace = shared('native-string-replace', String.prototype.replace);
  var nativeExec = RegExp.prototype.exec;
  var patchedExec = nativeExec;
  var charAt = functionUncurryThis(''.charAt);
  var indexOf$1 = functionUncurryThis(''.indexOf);
  var replace$1 = functionUncurryThis(''.replace);
  var stringSlice$1 = functionUncurryThis(''.slice);

  var UPDATES_LAST_INDEX_WRONG = (function () {
    var re1 = /a/;
    var re2 = /b*/g;
    functionCall(nativeExec, re1, 'a');
    functionCall(nativeExec, re2, 'a');
    return re1.lastIndex !== 0 || re2.lastIndex !== 0;
  })();

  var UNSUPPORTED_Y$1 = regexpStickyHelpers.BROKEN_CARET;

  // nonparticipating capturing group, copied from es5-shim's String#split patch.
  var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

  var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1 || regexpUnsupportedDotAll || regexpUnsupportedNcg;

  if (PATCH) {
    patchedExec = function exec(string) {
      var re = this;
      var state = getInternalState(re);
      var str = toString_1(string);
      var raw = state.raw;
      var result, reCopy, lastIndex, match, i, object, group;

      if (raw) {
        raw.lastIndex = re.lastIndex;
        result = functionCall(patchedExec, raw, str);
        re.lastIndex = raw.lastIndex;
        return result;
      }

      var groups = state.groups;
      var sticky = UNSUPPORTED_Y$1 && re.sticky;
      var flags = functionCall(regexpFlags, re);
      var source = re.source;
      var charsAdded = 0;
      var strCopy = str;

      if (sticky) {
        flags = replace$1(flags, 'y', '');
        if (indexOf$1(flags, 'g') === -1) {
          flags += 'g';
        }

        strCopy = stringSlice$1(str, re.lastIndex);
        // Support anchored sticky behavior.
        if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt(str, re.lastIndex - 1) !== '\n')) {
          source = '(?: ' + source + ')';
          strCopy = ' ' + strCopy;
          charsAdded++;
        }
        // ^(? + rx + ) is needed, in combination with some str slicing, to
        // simulate the 'y' flag.
        reCopy = new RegExp('^(?:' + source + ')', flags);
      }

      if (NPCG_INCLUDED) {
        reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
      }
      if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

      match = functionCall(nativeExec, sticky ? reCopy : re, strCopy);

      if (sticky) {
        if (match) {
          match.input = stringSlice$1(match.input, charsAdded);
          match[0] = stringSlice$1(match[0], charsAdded);
          match.index = re.lastIndex;
          re.lastIndex += match[0].length;
        } else re.lastIndex = 0;
      } else if (UPDATES_LAST_INDEX_WRONG && match) {
        re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
      }
      if (NPCG_INCLUDED && match && match.length > 1) {
        // Fix browsers whose `exec` methods don't consistently return `undefined`
        // for NPCG, like IE8. NOTE: This doesn't work for /(.?)?/
        functionCall(nativeReplace, match[0], reCopy, function () {
          for (i = 1; i < arguments.length - 2; i++) {
            if (arguments[i] === undefined) match[i] = undefined;
          }
        });
      }

      if (match && groups) {
        match.groups = object = objectCreate(null);
        for (i = 0; i < groups.length; i++) {
          group = groups[i];
          object[group[0]] = match[group[1]];
        }
      }

      return match;
    };
  }

  var regexpExec = patchedExec;

  // `RegExp.prototype.exec` method
  // https://tc39.es/ecma262/#sec-regexp.prototype.exec
  _export({ target: 'RegExp', proto: true, forced: /./.exec !== regexpExec }, {
    exec: regexpExec
  });

  var FunctionPrototype$3 = Function.prototype;
  var apply = FunctionPrototype$3.apply;
  var call$2 = FunctionPrototype$3.call;

  // eslint-disable-next-line es/no-reflect -- safe
  var functionApply = typeof Reflect == 'object' && Reflect.apply || (functionBindNative ? call$2.bind(apply) : function () {
    return call$2.apply(apply, arguments);
  });

  // TODO: Remove from `core-js@4` since it's moved to entry points








  var SPECIES$3 = wellKnownSymbol('species');
  var RegExpPrototype$2 = RegExp.prototype;

  var fixRegexpWellKnownSymbolLogic = function (KEY, exec, FORCED, SHAM) {
    var SYMBOL = wellKnownSymbol(KEY);

    var DELEGATES_TO_SYMBOL = !fails(function () {
      // String methods call symbol-named RegEp methods
      var O = {};
      O[SYMBOL] = function () { return 7; };
      return ''[KEY](O) != 7;
    });

    var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
      // Symbol-named RegExp methods call .exec
      var execCalled = false;
      var re = /a/;

      if (KEY === 'split') {
        // We can't use real regex here since it causes deoptimization
        // and serious performance degradation in V8
        // https://github.com/zloirock/core-js/issues/306
        re = {};
        // RegExp[@@split] doesn't call the regex's exec method, but first creates
        // a new one. We need to return the patched regex when creating the new one.
        re.constructor = {};
        re.constructor[SPECIES$3] = function () { return re; };
        re.flags = '';
        re[SYMBOL] = /./[SYMBOL];
      }

      re.exec = function () { execCalled = true; return null; };

      re[SYMBOL]('');
      return !execCalled;
    });

    if (
      !DELEGATES_TO_SYMBOL ||
      !DELEGATES_TO_EXEC ||
      FORCED
    ) {
      var uncurriedNativeRegExpMethod = functionUncurryThis(/./[SYMBOL]);
      var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
        var uncurriedNativeMethod = functionUncurryThis(nativeMethod);
        var $exec = regexp.exec;
        if ($exec === regexpExec || $exec === RegExpPrototype$2.exec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };
          }
          return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };
        }
        return { done: false };
      });

      defineBuiltIn(String.prototype, KEY, methods[0]);
      defineBuiltIn(RegExpPrototype$2, SYMBOL, methods[1]);
    }

    if (SHAM) createNonEnumerableProperty(RegExpPrototype$2[SYMBOL], 'sham', true);
  };

  var $TypeError$b = TypeError;

  // `Assert: IsConstructor(argument) is true`
  var aConstructor = function (argument) {
    if (isConstructor(argument)) return argument;
    throw $TypeError$b(tryToString(argument) + ' is not a constructor');
  };

  var SPECIES$4 = wellKnownSymbol('species');

  // `SpeciesConstructor` abstract operation
  // https://tc39.es/ecma262/#sec-speciesconstructor
  var speciesConstructor = function (O, defaultConstructor) {
    var C = anObject(O).constructor;
    var S;
    return C === undefined || isNullOrUndefined(S = anObject(C)[SPECIES$4]) ? defaultConstructor : aConstructor(S);
  };

  var charAt$1 = functionUncurryThis(''.charAt);
  var charCodeAt$1 = functionUncurryThis(''.charCodeAt);
  var stringSlice$2 = functionUncurryThis(''.slice);

  var createMethod$3 = function (CONVERT_TO_STRING) {
    return function ($this, pos) {
      var S = toString_1(requireObjectCoercible($this));
      var position = toIntegerOrInfinity(pos);
      var size = S.length;
      var first, second;
      if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
      first = charCodeAt$1(S, position);
      return first < 0xD800 || first > 0xDBFF || position + 1 === size
        || (second = charCodeAt$1(S, position + 1)) < 0xDC00 || second > 0xDFFF
          ? CONVERT_TO_STRING
            ? charAt$1(S, position)
            : first
          : CONVERT_TO_STRING
            ? stringSlice$2(S, position, position + 2)
            : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
    };
  };

  var stringMultibyte = {
    // `String.prototype.codePointAt` method
    // https://tc39.es/ecma262/#sec-string.prototype.codepointat
    codeAt: createMethod$3(false),
    // `String.prototype.at` method
    // https://github.com/mathiasbynens/String.prototype.at
    charAt: createMethod$3(true)
  };

  var charAt$2 = stringMultibyte.charAt;

  // `AdvanceStringIndex` abstract operation
  // https://tc39.es/ecma262/#sec-advancestringindex
  var advanceStringIndex = function (S, index, unicode) {
    return index + (unicode ? charAt$2(S, index).length : 1);
  };

  var $TypeError$c = TypeError;

  // `RegExpExec` abstract operation
  // https://tc39.es/ecma262/#sec-regexpexec
  var regexpExecAbstract = function (R, S) {
    var exec = R.exec;
    if (isCallable(exec)) {
      var result = functionCall(exec, R, S);
      if (result !== null) anObject(result);
      return result;
    }
    if (classofRaw(R) === 'RegExp') return functionCall(regexpExec, R, S);
    throw $TypeError$c('RegExp#exec called on incompatible receiver');
  };

  var UNSUPPORTED_Y$2 = regexpStickyHelpers.UNSUPPORTED_Y;
  var MAX_UINT32 = 0xFFFFFFFF;
  var min$3 = Math.min;
  var $push = [].push;
  var exec$1 = functionUncurryThis(/./.exec);
  var push$3 = functionUncurryThis($push);
  var stringSlice$3 = functionUncurryThis(''.slice);

  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  // Weex JS has frozen built-in prototypes, so use try / catch wrapper
  var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
    // eslint-disable-next-line regexp/no-empty-group -- required for testing
    var re = /(?:)/;
    var originalExec = re.exec;
    re.exec = function () { return originalExec.apply(this, arguments); };
    var result = 'ab'.split(re);
    return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
  });

  // @@split logic
  fixRegexpWellKnownSymbolLogic('split', function (SPLIT, nativeSplit, maybeCallNative) {
    var internalSplit;
    if (
      'abbc'.split(/(b)*/)[1] == 'c' ||
      // eslint-disable-next-line regexp/no-empty-group -- required for testing
      'test'.split(/(?:)/, -1).length != 4 ||
      'ab'.split(/(?:ab)*/).length != 2 ||
      '.'.split(/(.?)(.?)/).length != 4 ||
      // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
      '.'.split(/()()/).length > 1 ||
      ''.split(/.?/).length
    ) {
      // based on es5-shim implementation, need to rework it
      internalSplit = function (separator, limit) {
        var string = toString_1(requireObjectCoercible(this));
        var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
        if (lim === 0) return [];
        if (separator === undefined) return [string];
        // If `separator` is not a regex, use native split
        if (!isRegexp(separator)) {
          return functionCall(nativeSplit, string, separator, lim);
        }
        var output = [];
        var flags = (separator.ignoreCase ? 'i' : '') +
                    (separator.multiline ? 'm' : '') +
                    (separator.unicode ? 'u' : '') +
                    (separator.sticky ? 'y' : '');
        var lastLastIndex = 0;
        // Make `global` and avoid `lastIndex` issues by working with a copy
        var separatorCopy = new RegExp(separator.source, flags + 'g');
        var match, lastIndex, lastLength;
        while (match = functionCall(regexpExec, separatorCopy, string)) {
          lastIndex = separatorCopy.lastIndex;
          if (lastIndex > lastLastIndex) {
            push$3(output, stringSlice$3(string, lastLastIndex, match.index));
            if (match.length > 1 && match.index < string.length) functionApply($push, output, arraySliceSimple(match, 1));
            lastLength = match[0].length;
            lastLastIndex = lastIndex;
            if (output.length >= lim) break;
          }
          if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
        }
        if (lastLastIndex === string.length) {
          if (lastLength || !exec$1(separatorCopy, '')) push$3(output, '');
        } else push$3(output, stringSlice$3(string, lastLastIndex));
        return output.length > lim ? arraySliceSimple(output, 0, lim) : output;
      };
    // Chakra, V8
    } else if ('0'.split(undefined, 0).length) {
      internalSplit = function (separator, limit) {
        return separator === undefined && limit === 0 ? [] : functionCall(nativeSplit, this, separator, limit);
      };
    } else internalSplit = nativeSplit;

    return [
      // `String.prototype.split` method
      // https://tc39.es/ecma262/#sec-string.prototype.split
      function split(separator, limit) {
        var O = requireObjectCoercible(this);
        var splitter = isNullOrUndefined(separator) ? undefined : getMethod(separator, SPLIT);
        return splitter
          ? functionCall(splitter, separator, O, limit)
          : functionCall(internalSplit, toString_1(O), separator, limit);
      },
      // `RegExp.prototype[@@split]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
      //
      // NOTE: This cannot be properly polyfilled in engines that don't support
      // the 'y' flag.
      function (string, limit) {
        var rx = anObject(this);
        var S = toString_1(string);
        var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);

        if (res.done) return res.value;

        var C = speciesConstructor(rx, RegExp);

        var unicodeMatching = rx.unicode;
        var flags = (rx.ignoreCase ? 'i' : '') +
                    (rx.multiline ? 'm' : '') +
                    (rx.unicode ? 'u' : '') +
                    (UNSUPPORTED_Y$2 ? 'g' : 'y');

        // ^(? + rx + ) is needed, in combination with some S slicing, to
        // simulate the 'y' flag.
        var splitter = new C(UNSUPPORTED_Y$2 ? '^(?:' + rx.source + ')' : rx, flags);
        var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
        if (lim === 0) return [];
        if (S.length === 0) return regexpExecAbstract(splitter, S) === null ? [S] : [];
        var p = 0;
        var q = 0;
        var A = [];
        while (q < S.length) {
          splitter.lastIndex = UNSUPPORTED_Y$2 ? 0 : q;
          var z = regexpExecAbstract(splitter, UNSUPPORTED_Y$2 ? stringSlice$3(S, q) : S);
          var e;
          if (
            z === null ||
            (e = min$3(toLength(splitter.lastIndex + (UNSUPPORTED_Y$2 ? q : 0)), S.length)) === p
          ) {
            q = advanceStringIndex(S, q, unicodeMatching);
          } else {
            push$3(A, stringSlice$3(S, p, q));
            if (A.length === lim) return A;
            for (var i = 1; i <= z.length - 1; i++) {
              push$3(A, z[i]);
              if (A.length === lim) return A;
            }
            q = p = e;
          }
        }
        push$3(A, stringSlice$3(S, p));
        return A;
      }
    ];
  }, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y$2);

  var floor$3 = Math.floor;
  var charAt$3 = functionUncurryThis(''.charAt);
  var replace$2 = functionUncurryThis(''.replace);
  var stringSlice$4 = functionUncurryThis(''.slice);
  var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
  var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;

  // `GetSubstitution` abstract operation
  // https://tc39.es/ecma262/#sec-getsubstitution
  var getSubstitution = function (matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return replace$2(replacement, symbols, function (match, ch) {
      var capture;
      switch (charAt$3(ch, 0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return stringSlice$4(str, 0, position);
        case "'": return stringSlice$4(str, tailPos);
        case '<':
          capture = namedCaptures[stringSlice$4(ch, 1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor$3(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? charAt$3(ch, 1) : captures[f - 1] + charAt$3(ch, 1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  };

  var REPLACE = wellKnownSymbol('replace');
  var max$4 = Math.max;
  var min$4 = Math.min;
  var concat$1 = functionUncurryThis([].concat);
  var push$4 = functionUncurryThis([].push);
  var stringIndexOf$1 = functionUncurryThis(''.indexOf);
  var stringSlice$5 = functionUncurryThis(''.slice);

  var maybeToString = function (it) {
    return it === undefined ? it : String(it);
  };

  // IE <= 11 replaces $0 with the whole match, as if it was $&
  // https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
  var REPLACE_KEEPS_$0 = (function () {
    // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing
    return 'a'.replace(/./, '$0') === '$0';
  })();

  // Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
    if (/./[REPLACE]) {
      return /./[REPLACE]('a', '$0') === '';
    }
    return false;
  })();

  var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
    var re = /./;
    re.exec = function () {
      var result = [];
      result.groups = { a: '7' };
      return result;
    };
    // eslint-disable-next-line regexp/no-useless-dollar-replacements -- false positive
    return ''.replace(re, '$<a>') !== '7';
  });

  // @@replace logic
  fixRegexpWellKnownSymbolLogic('replace', function (_, nativeReplace, maybeCallNative) {
    var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

    return [
      // `String.prototype.replace` method
      // https://tc39.es/ecma262/#sec-string.prototype.replace
      function replace(searchValue, replaceValue) {
        var O = requireObjectCoercible(this);
        var replacer = isNullOrUndefined(searchValue) ? undefined : getMethod(searchValue, REPLACE);
        return replacer
          ? functionCall(replacer, searchValue, O, replaceValue)
          : functionCall(nativeReplace, toString_1(O), searchValue, replaceValue);
      },
      // `RegExp.prototype[@@replace]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
      function (string, replaceValue) {
        var rx = anObject(this);
        var S = toString_1(string);

        if (
          typeof replaceValue == 'string' &&
          stringIndexOf$1(replaceValue, UNSAFE_SUBSTITUTE) === -1 &&
          stringIndexOf$1(replaceValue, '$<') === -1
        ) {
          var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
          if (res.done) return res.value;
        }

        var functionalReplace = isCallable(replaceValue);
        if (!functionalReplace) replaceValue = toString_1(replaceValue);

        var global = rx.global;
        if (global) {
          var fullUnicode = rx.unicode;
          rx.lastIndex = 0;
        }
        var results = [];
        while (true) {
          var result = regexpExecAbstract(rx, S);
          if (result === null) break;

          push$4(results, result);
          if (!global) break;

          var matchStr = toString_1(result[0]);
          if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        }

        var accumulatedResult = '';
        var nextSourcePosition = 0;
        for (var i = 0; i < results.length; i++) {
          result = results[i];

          var matched = toString_1(result[0]);
          var position = max$4(min$4(toIntegerOrInfinity(result.index), S.length), 0);
          var captures = [];
          // NOTE: This is equivalent to
          //   captures = result.slice(1).map(maybeToString)
          // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
          // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
          // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
          for (var j = 1; j < result.length; j++) push$4(captures, maybeToString(result[j]));
          var namedCaptures = result.groups;
          if (functionalReplace) {
            var replacerArgs = concat$1([matched], captures, position, S);
            if (namedCaptures !== undefined) push$4(replacerArgs, namedCaptures);
            var replacement = toString_1(functionApply(replaceValue, undefined, replacerArgs));
          } else {
            replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
          }
          if (position >= nextSourcePosition) {
            accumulatedResult += stringSlice$5(S, nextSourcePosition, position) + replacement;
            nextSourcePosition = position + matched.length;
          }
        }
        return accumulatedResult + stringSlice$5(S, nextSourcePosition);
      }
    ];
  }, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);

  /**
   * @param {number} value
   * @param {number} [decimalPlaces]
   */
  function round(value) {
    var decimalPlaces = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    if (typeof value !== 'number') throw 'Not a number.';
    if (decimalPlaces === 0) return Math.round(value);
    var pow = Math.pow(10, decimalPlaces);
    return Math.round(value * pow) / pow;
  }

  function defaultKnots(degree, points, knots) {
    var i = knots.length;
    var lastKnot = knots[i - 1];
    for (; i < points.length + degree + 1; i++) {
      knots[i] = lastKnot;
    }
  }
  function getBSplinePoints(degree, points, knots, weights) {
    var step = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.1;
    defaultKnots(degree, points, knots);
    var calcPoints = [];
    for (var t = 0; t <= 1; t += step) {
      var _getBSplinePoint = getBSplinePoint(t, degree, points, knots, weights),
        _getBSplinePoint2 = _slicedToArray(_getBSplinePoint, 2),
        x = _getBSplinePoint2[0],
        y = _getBSplinePoint2[1];
      if (isNaN(x) || isNaN(y)) continue;
      calcPoints.push(round(x, 2), round(y, 2));
    }
    return calcPoints;
  }
  function getBSplinePoint(t, degree, points, knots, weights) {
    var i, j, s, l; // function-scoped iteration variables
    var n = points.length; // points count
    var d = points[0].length; // point dimensionality

    if (degree < 1) throw new Error('degree must be at least 1 (linear)');
    if (degree > n - 1) throw new Error('degree must be less than or equal to point count - 1');
    if (!weights) {
      // build weight vector of length [n]
      weights = [];
      for (i = 0; i < n; i++) {
        weights[i] = 1;
      }
    }
    if (!knots) {
      // build knot vector of length [n + degree + 1]
      knots = [];
      for (i = 0; i < n + degree + 1; i++) {
        knots[i] = i;
      }
    } else {
      if (knots.length !== n + degree + 1) throw new Error('bad knot vector length');
    }
    var domain = [degree, knots.length - 1 - degree];

    // remap t to the domain where the spline is defined
    var low = knots[domain[0]];
    var high = knots[domain[1]];
    t = t * (high - low) + low;
    if (t < low || t > high) throw new Error('out of bounds');

    // find s (the spline segment) for the [t] value provided
    for (s = domain[0]; s < domain[1]; s++) {
      if (t >= knots[s] && t <= knots[s + 1]) {
        break;
      }
    }

    // convert points to homogeneous coordinates
    var v = [];
    for (i = 0; i < n; i++) {
      v[i] = [];
      for (j = 0; j < d; j++) {
        v[i][j] = points[i][j] * weights[i];
      }
      v[i][d] = weights[i];
    }

    // l (level) goes from 1 to the curve degree + 1
    var alpha;
    for (l = 1; l <= degree + 1; l++) {
      // build level l of the pyramid
      for (i = s; i > s - degree - 1 + l; i--) {
        alpha = (t - knots[i]) / (knots[i + degree + 1 - l] - knots[i]);

        // interpolate each component
        for (j = 0; j < d + 1; j++) {
          v[i][j] = (1 - alpha) * v[i - 1][j] + alpha * v[i][j];
        }
      }
    }

    // convert back to cartesian and return
    var result = [];
    for (i = 0; i < d; i++) {
      result[i] = v[s][i] / v[s][d];
    }
    return result;
  }

  var XmlSchemaKey = {
    Main: 'Main',
    Relationships: 'Relationships',
    DrawingML: 'DrawingML',
    Theme: 'Theme'
  };

  /** @enum {string} XmlSchema */
  var XmlSchema = {
    Main: 'http://schemas.microsoft.com/office/visio/2012/main',
    Relationships: 'http://schemas.openxmlformats.org/package/2006/relationships',
    ContentTypes: 'http://schemas.openxmlformats.org/package/2006/content-types',
    DocumentRelationships: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
    VisioMasterRelationship: 'http://schemas.microsoft.com/visio/2010/relationships/master',
    DocumentImageRelationships: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image',
    CustomProperties: 'http://schemas.openxmlformats.org/officeDocument/2006/custom-properties',
    DocPropsVTypes: 'http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes',
    // @see {https://en.wikipedia.org/wiki/Office_Open_XML_file_formats#DrawingML}
    DrawingML: 'http://schemas.openxmlformats.org/drawingml/2006/main',
    Theme: 'http://schemas.microsoft.com/office/visio/2012/theme'
  };

  /** @enum {string} VisioJxonType */
  var VisioJxonType = {
    Cell: 'Cell',
    Row: 'Row',
    Master: 'Master',
    Section: 'Section',
    Shape: 'Shape',
    ShapeText: 'ShapeText',
    PageSheet: 'PageSheet',
    Page: 'Page',
    Icon: 'Icon',
    Image: 'Image',
    Document: 'Document',
    StyleSheet: 'StyleSheet',
    ForeignData: 'ForeignData',
    DocumentSettings: 'DocumentSettings',
    DocumentSheet: 'DocumentSheet',
    SchemeClr: 'SchemeClr',
    Connect: 'Connect',
    FaceName: 'FaceName'
  };

  /** @enum {string} VisioCellKey */
  var VisioJxonCellKey = {
    Name: '@N',
    Value: '@V',
    Units: '@U',
    Formula: '@F'
  };
  var LocalToVisioCellKey = {
    name: VisioJxonCellKey.Name,
    value: VisioJxonCellKey.Value,
    units: VisioJxonCellKey.Units,
    formula: VisioJxonCellKey.Formula
  };

  /**
   * @enum {string} VisioJxonMasterKey
   * @see {http://localhost/MS-VSDX.pdf#page=119}
   */
  var VisioJxonMasterKey = {
    // objects
    PageSheet: 'PageSheet',
    Rel: 'Rel',
    // required
    Icon: 'Icon',
    // properties
    Id: '@ID',
    // required
    UniqueId: '@UniqueID',
    MasterType: '@MasterType',
    BaseId: '@BaseID',
    NameU: '@NameU',
    // language-independent name
    IsCustomNameU: '@IsCustomNameU',
    Name: '@Name',
    // language-dependent name
    IsCustomName: '@IsCustomName',
    Prompt: '@Prompt',
    // "tooltip" "This connector..."

    Hidden: '@Hidden',
    IconSize: '@IconSize',
    AlignName: '@AlignName',
    MatchByName: '@MatchByName',
    IconUpdate: '@IconUpdate',
    PatternFlags: '@PatternFlags'
  };

  /** @enum {string} VisioJxonRelationKey */
  var VisioJxonRelationKey = {
    // root
    Relationship: 'Relationship',
    // inside relation
    Id: '@Id',
    Type: '@Type',
    Target: '@Target'
  };

  /** @enum {string} VisioRelationType */
  var VisioRelationType = {
    Document: 'Document',
    Master: 'Master',
    Masters: 'Masters',
    Page: 'Page',
    Pages: 'Pages',
    Windows: 'Windows',
    Theme: 'Theme',
    Image: 'Image',
    Solutions: 'Solutions',
    // getTopRelationsMap
    coreProperties: 'coreProperties',
    thumbnail: 'thumbnail',
    document: 'document',
    customProperties: 'customProperties',
    extendedProperties: 'extendedProperties'
  };

  /** @enum {string} VisioRelationSchemaToType */
  var VisioRelationSchemaToType = {
    // document
    'http://schemas.microsoft.com/visio/2010/relationships/windows': VisioRelationType.Windows,
    'http://schemas.microsoft.com/visio/2010/relationships/pages': VisioRelationType.Pages,
    // pages
    'http://schemas.microsoft.com/visio/2010/relationships/page': VisioRelationType.Page,
    // master
    'http://schemas.microsoft.com/visio/2010/relationships/master': VisioRelationType.Master,
    'http://schemas.microsoft.com/visio/2010/relationships/masters': VisioRelationType.Masters,
    //
    'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme': VisioRelationType.Theme,
    'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image': VisioRelationType.Image,
    'http://schemas.microsoft.com/visio/2010/relationships/solutions': VisioRelationType.Solutions,
    'http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties': 'coreProperties',
    'http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail': 'thumbnail',
    'http://schemas.microsoft.com/visio/2010/relationships/document': 'document',
    'http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties': 'customProperties',
    'http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties': 'extendedProperties'
  };

  /** @enum {string} VisioCellKey */
  var VisioJxonSectionKey = {
    Name: '@N',
    Id: '@IX',
    Row: 'Row'
  };
  var VisioJxonRowKey = {
    Name: '@N',
    Id: '@IX',
    Type: '@T',
    Cell: 'Cell'
  };

  /** @enum {string} VisioJxonShapeKey */
  var VisioJxonShapeKey = {
    // required
    Id: '@ID',
    // objects
    Shapes: 'Shapes',
    // in grouped shape
    Section: 'Section',
    Cell: 'Cell',
    Text: 'Text',
    Connect: 'Connect',
    //TODO miky which one
    Connects: 'Connects',
    //TODO miky which one

    // properties
    MasterShapeId: '@MasterShape',
    MasterId: '@Master',
    Type: '@Type'
  };

  /** @enum {string} VisioJxonShapesKey */
  var VisioJxonShapesKey = {
    Shape: 'Shape'
  };

  /** @enum {string} VisioJxonKey */
  var VisioJxonKey = {
    // required
    Id: '@ID',
    // objects
    Cell: 'Cell',
    Row: 'Row',
    Section: 'Section',
    Text: 'Text',
    Rel: 'Rel',
    PageSheet: 'PageSheet',
    Icon: 'Icon',
    ForeignData: 'ForeignData',
    // attributes
    Type: '@Type',
    xmlns: '@xmlns',
    xmlnsR: '@xmlns:r',
    xmlSpace: '@xml:space'
  };
  /** @enum {string} VisioJxonDocumentKey */
  var VisioJxonDocumentKey = {
    DocumentSettings: 'DocumentSettings',
    Colors: 'Colors',
    FaceNames: 'FaceNames',
    StyleSheets: 'StyleSheets',
    DocumentSheet: 'DocumentSheet',
    ColorEntry: 'ColorEntry',
    Ix: '@IX',
    Rgb: '@RGB'
  };

  /** @enum {string} VisioJxonShapeTextKey */
  var VisioJxonShapeTextKey = {
    // objects
    CharacterProperties: 'cp',
    // properties
    Content: 'keyValue' // '@keyValue'
  };

  /** @enum {string} VisioJxonIconKey */
  var VisioJxonIconKey = {
    // properties
    Content: 'keyValue'
  };

  /** @enum {string} VisioCellKey */
  var VisioJxonRelKey = {
    RelId: '@r:id' // example @r:id = "rId1"
  };

  /** @enum {string} VisioUnitType */
  var VisioUnitType = {
    // A
    AC: 'AC',
    // Acres
    AD: 'AD',
    // Degrees-minutes-seconds

    // B
    BOOL: 'BOOL',
    // Boolean

    // C
    C: 'C',
    // Ciceros
    C_D: 'C_D',
    // Ciceros and didots
    CM: 'CM',
    // Centimeters
    COLOR: 'COLOR',
    // RGB color value
    CY: 'CY',
    // Currency

    // D
    D: 'D',
    // Didots
    DA: 'DA',
    // Radians
    DATE: 'DATE',
    // Days
    DE: 'DE',
    // Days
    DEG: 'DEG',
    // Degrees
    DL: 'DL',
    // Inches
    DP: 'DP',
    // Inches
    DT: 'DT',
    // Points

    // E
    ED: 'ED',
    // Days
    EH: 'EH',
    // Hours
    EM: 'EM',
    // Minutes
    ES: 'ES',
    // Seconds
    EW: 'EW',
    // Weeks

    // F
    F_I: 'F_I',
    // Feet and inches
    FT: 'FT',
    // Feet

    // H
    HA: 'HA',
    // Hectare

    // I
    IN: 'IN',
    // Inches
    IN_F: 'IN_F',
    // Inches

    // K
    KM: 'KM',
    // Kilometers

    // M
    M: 'M',
    // Meters
    MI: 'MI',
    // Miles
    MI_F: 'MI_F',
    // Miles
    MM: 'MM',
    // Millimeters

    // N
    NM: 'NM',
    // Nautical miles

    // P
    PER: 'PER',
    // Percentage
    P_PT: 'P_PT',
    // Picas and points
    PT: 'PT',
    // Points
    P: 'P',
    // Picas
    PNT: 'PNT',
    // Coordinates of a two-dimensional point

    // R
    RAD: 'RAD',
    // Radians

    // S
    STR: 'STR',
    // String

    // Y
    YD: 'YD' // Yards
  };

  /** @enum {string} VisioCellName */
  var VisioCellName = {
    A: 'A',
    // @see {http://localhost/MS-VSDX.pdf#page=159}
    Action: 'Action',
    // @see {http://localhost/MS-VSDX.pdf#page=159}
    Active: 'Active',
    // @see {http://localhost/MS-VSDX.pdf#page=160}
    AddMarkup: 'AddMarkup',
    // @see {http://localhost/MS-VSDX.pdf#page=160}
    Address: 'Address',
    // @see {http://localhost/MS-VSDX.pdf#page=160}
    AlignBottom: 'AlignBottom',
    // @see {http://localhost/MS-VSDX.pdf#page=160}
    AlignCenter: 'AlignCenter',
    // @see {http://localhost/MS-VSDX.pdf#page=160}
    AlignLeft: 'AlignLeft',
    // @see {http://localhost/MS-VSDX.pdf#page=160}
    Alignment: 'Alignment',
    // @see {http://localhost/MS-VSDX.pdf#page=160}
    Alignment0: 'Alignment0',
    //TODO miky BRND page1.xml
    AlignMiddle: 'AlignMiddle',
    // @see {http://localhost/MS-VSDX.pdf#page=161}
    AlignRight: 'AlignRight',
    // @see {http://localhost/MS-VSDX.pdf#page=161}
    AlignTop: 'AlignTop',
    // @see {http://localhost/MS-VSDX.pdf#page=161}
    Angle: 'Angle',
    // @see {http://localhost/MS-VSDX.pdf#page=161}
    AsianFont: 'AsianFont',
    // @see {http://localhost/MS-VSDX.pdf#page=161}
    AutoGen: 'AutoGen',
    // @see {http://localhost/MS-VSDX.pdf#page=161}
    AvenueSizeX: 'AvenueSizeX',
    // @see {http://localhost/MS-VSDX.pdf#page=161}
    AvenueSizeY: 'AvenueSizeY',
    // @see {http://localhost/MS-VSDX.pdf#page=161}
    AvoidPageBreaks: 'AvoidPageBreaks',
    // @see {http://localhost/MS-VSDX.pdf#page=161}
    B: 'B',
    // @see {http://localhost/MS-VSDX.pdf#page=162}
    BeginArrow: 'BeginArrow',
    // @see {http://localhost/MS-VSDX.pdf#page=162}
    BeginArrowSize: 'BeginArrowSize',
    // @see {http://localhost/MS-VSDX.pdf#page=164}
    BeginGroup: 'BeginGroup',
    // @see {http://localhost/MS-VSDX.pdf#page=165}
    BeginX: 'BeginX',
    // @see {http://localhost/MS-VSDX.pdf#page=165}
    BeginY: 'BeginY',
    // @see {http://localhost/MS-VSDX.pdf#page=165}
    BegTrigger: 'BegTrigger',
    // @see {http://localhost/MS-VSDX.pdf#page=165}
    BevelBottomHeight: 'BevelBottomHeight',
    // @see {http://localhost/MS-VSDX.pdf#page=165}
    BevelBottomType: 'BevelBottomType',
    // @see {http://localhost/MS-VSDX.pdf#page=165}
    BevelBottomWidth: 'BevelBottomWidth',
    // @see {http://localhost/MS-VSDX.pdf#page=166}
    BevelContourColor: 'BevelContourColor',
    // @see {http://localhost/MS-VSDX.pdf#page=166}
    BevelContourSize: 'BevelContourSize',
    // @see {http://localhost/MS-VSDX.pdf#page=166}
    BevelDepthColor: 'BevelDepthColor',
    // @see {http://localhost/MS-VSDX.pdf#page=166}
    BevelDepthSize: 'BevelDepthSize',
    // @see {http://localhost/MS-VSDX.pdf#page=166}
    BevelLightingAngle: 'BevelLightingAngle',
    // @see {http://localhost/MS-VSDX.pdf#page=166}
    BevelLightingType: 'BevelLightingType',
    // @see {http://localhost/MS-VSDX.pdf#page=167}
    BevelMaterialType: 'BevelMaterialType',
    // @see {http://localhost/MS-VSDX.pdf#page=167}
    BevelTopHeight: 'BevelTopHeight',
    // @see {http://localhost/MS-VSDX.pdf#page=168}
    BevelTopType: 'BevelTopType',
    // @see {http://localhost/MS-VSDX.pdf#page=168}
    BevelTopWidth: 'BevelTopWidth',
    // @see {http://localhost/MS-VSDX.pdf#page=169}
    BlockSizeX: 'BlockSizeX',
    // @see {http://localhost/MS-VSDX.pdf#page=169}
    BlockSizeY: 'BlockSizeY',
    // @see {http://localhost/MS-VSDX.pdf#page=169}
    Blur: 'Blur',
    // @see {http://localhost/MS-VSDX.pdf#page=169}
    BottomMargin: 'BottomMargin',
    // @see {http://localhost/MS-VSDX.pdf#page=169}
    Brightness: 'Brightness',
    // @see {http://localhost/MS-VSDX.pdf#page=169}
    Bullet: 'Bullet',
    // @see {http://localhost/MS-VSDX.pdf#page=170}
    BulletFont: 'BulletFont',
    // @see {http://localhost/MS-VSDX.pdf#page=170}
    BulletFontSize: 'BulletFontSize',
    // @see {http://localhost/MS-VSDX.pdf#page=170}
    BulletStr: 'BulletStr',
    // @see {http://localhost/MS-VSDX.pdf#page=170}
    ButtonFace: 'ButtonFace',
    // @see {http://localhost/MS-VSDX.pdf#page=171}
    C: 'C',
    // @see {http://localhost/MS-VSDX.pdf#page=171}
    Calendar: 'Calendar',
    // @see {http://localhost/MS-VSDX.pdf#page=171}
    CanGlue: 'CanGlue',
    // @see {http://localhost/MS-VSDX.pdf#page=171}
    Case: 'Case',
    // @see {http://localhost/MS-VSDX.pdf#page=171}
    CenterX: 'CenterX',
    // @see {http://localhost/MS-VSDX.pdf#page=172}
    CenterY: 'CenterY',
    // @see {http://localhost/MS-VSDX.pdf#page=172}
    Checked: 'Checked',
    // @see {http://localhost/MS-VSDX.pdf#page=172}
    ClippingPath: 'ClippingPath',
    // @see {http://localhost/MS-VSDX.pdf#page=172}
    Color: 'Color',
    // @see {http://localhost/MS-VSDX.pdf#page=172}
    ColorSchemeIndex: 'ColorSchemeIndex',
    // @see {http://localhost/MS-VSDX.pdf#page=173}
    ColorTrans: 'ColorTrans',
    // @see {http://localhost/MS-VSDX.pdf#page=173}
    Comment: 'Comment',
    // @see {http://localhost/MS-VSDX.pdf#page=174}
    ComplexScriptFont: 'ComplexScriptFont',
    // @see {http://localhost/MS-VSDX.pdf#page=174}
    ComplexScriptSize: 'ComplexScriptSize',
    // @see {http://localhost/MS-VSDX.pdf#page=174}
    CompoundType: 'CompoundType',
    // @see {http://localhost/MS-VSDX.pdf#page=174}
    ConFixedCode: 'ConFixedCode',
    // @see {http://localhost/MS-VSDX.pdf#page=175}
    ConLineJumpCode: 'ConLineJumpCode',
    // @see {http://localhost/MS-VSDX.pdf#page=175}
    ConLineJumpDirX: 'ConLineJumpDirX',
    // @see {http://localhost/MS-VSDX.pdf#page=175}
    ConLineJumpDirY: 'ConLineJumpDirY',
    // @see {http://localhost/MS-VSDX.pdf#page=175}
    ConLineJumpStyle: 'ConLineJumpStyle',
    // @see {http://localhost/MS-VSDX.pdf#page=175}
    ConLineRouteExt: 'ConLineRouteExt',
    // @see {http://localhost/MS-VSDX.pdf#page=175}
    ConnectorSchemeIndex: 'ConnectorSchemeIndex',
    // @see {http://localhost/MS-VSDX.pdf#page=175}
    Contrast: 'Contrast',
    // @see {http://localhost/MS-VSDX.pdf#page=175}
    Copyright: 'Copyright',
    // @see {http://localhost/MS-VSDX.pdf#page=176}
    CtrlAsInput: 'CtrlAsInput',
    // @see {http://localhost/MS-VSDX.pdf#page=176}
    CurrentIndex: 'CurrentIndex',
    // @see {http://localhost/MS-VSDX.pdf#page=176}
    D: 'D',
    // @see {http://localhost/MS-VSDX.pdf#page=176}
    DataLinked: 'DataLinked',
    // @see {http://localhost/MS-VSDX.pdf#page=176}
    DblUnderline: 'DblUnderline',
    // @see {http://localhost/MS-VSDX.pdf#page=176}
    Default: 'Default',
    // @see {http://localhost/MS-VSDX.pdf#page=176}
    DefaultTabStop: 'DefaultTabStop',
    // @see {http://localhost/MS-VSDX.pdf#page=177}
    Denoise: 'Denoise',
    // @see {http://localhost/MS-VSDX.pdf#page=177}
    Description: 'Description',
    // @see {http://localhost/MS-VSDX.pdf#page=177}
    DirX: 'DirX',
    // @see {http://localhost/MS-VSDX.pdf#page=177}
    DirY: 'DirY',
    // @see {http://localhost/MS-VSDX.pdf#page=177}
    Disabled: 'Disabled',
    // @see {http://localhost/MS-VSDX.pdf#page=177}
    DisplayLevel: 'DisplayLevel',
    // @see {http://localhost/MS-VSDX.pdf#page=177}
    DisplayMode: 'DisplayMode',
    // @see {http://localhost/MS-VSDX.pdf#page=177}
    DistanceFromGround: 'DistanceFromGround',
    // @see {http://localhost/MS-VSDX.pdf#page=178}
    DocLangID: 'DocLangID',
    // @see {http://localhost/MS-VSDX.pdf#page=178}
    DocLockDuplicatePage: 'DocLockDuplicatePage',
    // @see {http://localhost/MS-VSDX.pdf#page=178}
    DocLockReplace: 'DocLockReplace',
    // @see {http://localhost/MS-VSDX.pdf#page=178}
    DontMoveChildren: 'DontMoveChildren',
    // @see {http://localhost/MS-VSDX.pdf#page=178}
    DoubleStrikethrough: 'DoubleStrikethrough',
    // @see {http://localhost/MS-VSDX.pdf#page=178}
    DrawingResizeType: 'DrawingResizeType',
    // @see {http://localhost/MS-VSDX.pdf#page=179}
    DrawingScale: 'DrawingScale',
    // @see {http://localhost/MS-VSDX.pdf#page=179}
    DrawingScaleType: 'DrawingScaleType',
    // @see {http://localhost/MS-VSDX.pdf#page=179}
    DrawingSizeType: 'DrawingSizeType',
    // @see {http://localhost/MS-VSDX.pdf#page=179}
    DropOnPageScale: 'DropOnPageScale',
    // @see {http://localhost/MS-VSDX.pdf#page=180}
    DynamicsOff: 'DynamicsOff',
    // @see {http://localhost/MS-VSDX.pdf#page=180}
    DynFeedback: 'DynFeedback',
    // @see {http://localhost/MS-VSDX.pdf#page=180}
    E: 'E',
    // @see {http://localhost/MS-VSDX.pdf#page=180}
    EffectSchemeIndex: 'EffectSchemeIndex',
    // @see {http://localhost/MS-VSDX.pdf#page=180}
    EmbellishmentIndex: 'EmbellishmentIndex',
    // @see {http://localhost/MS-VSDX.pdf#page=180}
    EnableFillProps: 'EnableFillProps',
    // @see {http://localhost/MS-VSDX.pdf#page=180}
    EnableGrid: 'EnableGrid',
    // @see {http://localhost/MS-VSDX.pdf#page=181}
    EnableLineProps: 'EnableLineProps',
    // @see {http://localhost/MS-VSDX.pdf#page=181}
    EnableTextProps: 'EnableTextProps',
    // @see {http://localhost/MS-VSDX.pdf#page=181}
    EndArrow: 'EndArrow',
    // @see {http://localhost/MS-VSDX.pdf#page=181}
    EndArrowSize: 'EndArrowSize',
    // @see {http://localhost/MS-VSDX.pdf#page=181}
    EndTrigger: 'EndTrigger',
    // @see {http://localhost/MS-VSDX.pdf#page=182}
    EndX: 'EndX',
    // @see {http://localhost/MS-VSDX.pdf#page=182}
    EndY: 'EndY',
    // @see {http://localhost/MS-VSDX.pdf#page=182}
    EventDblClick: 'EventDblClick',
    // @see {http://localhost/MS-VSDX.pdf#page=182}
    EventDrop: 'EventDrop',
    // @see {http://localhost/MS-VSDX.pdf#page=182}
    EventMultiDrop: 'EventMultiDrop',
    // @see {http://localhost/MS-VSDX.pdf#page=182}
    EventXFMod: 'EventXFMod',
    // @see {http://localhost/MS-VSDX.pdf#page=182}
    ExtraInfo: 'ExtraInfo',
    // @see {http://localhost/MS-VSDX.pdf#page=182}
    FillBkgnd: 'FillBkgnd',
    // @see {http://localhost/MS-VSDX.pdf#page=183}
    FillBkgndTrans: 'FillBkgndTrans',
    // @see {http://localhost/MS-VSDX.pdf#page=183}
    FillForegnd: 'FillForegnd',
    // @see {http://localhost/MS-VSDX.pdf#page=183}
    FillForegndTrans: 'FillForegndTrans',
    // @see {http://localhost/MS-VSDX.pdf#page=183}
    FillGradientAngle: 'FillGradientAngle',
    // @see {http://localhost/MS-VSDX.pdf#page=183}
    FillGradientDir: 'FillGradientDir',
    // @see {http://localhost/MS-VSDX.pdf#page=183}
    FillGradientEnabled: 'FillGradientEnabled',
    // @see {http://localhost/MS-VSDX.pdf#page=184}
    FillPattern: 'FillPattern',
    // @see {http://localhost/MS-VSDX.pdf#page=184}
    Flags: 'Flags',
    // @see {http://localhost/MS-VSDX.pdf#page=187}
    FlipX: 'FlipX',
    // @see {http://localhost/MS-VSDX.pdf#page=187}
    FlipY: 'FlipY',
    // @see {http://localhost/MS-VSDX.pdf#page=187}
    FlyoutChild: 'FlyoutChild',
    // @see {http://localhost/MS-VSDX.pdf#page=187}
    Font: 'Font',
    // @see {http://localhost/MS-VSDX.pdf#page=187}
    FontScale: 'FontScale',
    // @see {http://localhost/MS-VSDX.pdf#page=187}
    FontSchemeIndex: 'FontSchemeIndex',
    // @see {http://localhost/MS-VSDX.pdf#page=188}
    Format: 'Format',
    // @see {http://localhost/MS-VSDX.pdf#page=188}
    Frame: 'Frame',
    // @see {http://localhost/MS-VSDX.pdf#page=188}
    Gamma: 'Gamma',
    // @see {http://localhost/MS-VSDX.pdf#page=188}
    GlowColor: 'GlowColor',
    // @see {http://localhost/MS-VSDX.pdf#page=188}
    GlowColorTrans: 'GlowColorTrans',
    // @see {http://localhost/MS-VSDX.pdf#page=188}
    GlowSize: 'GlowSize',
    // @see {http://localhost/MS-VSDX.pdf#page=188}
    Glue: 'Glue',
    // @see {http://localhost/MS-VSDX.pdf#page=189}
    GlueType: 'GlueType',
    // @see {http://localhost/MS-VSDX.pdf#page=189}
    GradientStopColor: 'GradientStopColor',
    // @see {http://localhost/MS-VSDX.pdf#page=189}
    GradientStopColorTrans: 'GradientStopColorTrans',
    // @see {http://localhost/MS-VSDX.pdf#page=189}
    GradientStopPosition: 'GradientStopPosition',
    // @see {http://localhost/MS-VSDX.pdf#page=189}
    Height: 'Height',
    // @see {http://localhost/MS-VSDX.pdf#page=189}
    HelpTopic: 'HelpTopic',
    // @see {http://localhost/MS-VSDX.pdf#page=189}
    HideForApply: 'HideForApply',
    // @see {http://localhost/MS-VSDX.pdf#page=190}
    HideText: 'HideText',
    // @see {http://localhost/MS-VSDX.pdf#page=190}
    HorzAlign: 'HorzAlign',
    // @see {http://localhost/MS-VSDX.pdf#page=190}
    ImgHeight: 'ImgHeight',
    // @see {http://localhost/MS-VSDX.pdf#page=190}
    ImgOffsetX: 'ImgOffsetX',
    // @see {http://localhost/MS-VSDX.pdf#page=190}
    ImgOffsetY: 'ImgOffsetY',
    // @see {http://localhost/MS-VSDX.pdf#page=190}
    ImgWidth: 'ImgWidth',
    // @see {http://localhost/MS-VSDX.pdf#page=190}
    IndFirst: 'IndFirst',
    // @see {http://localhost/MS-VSDX.pdf#page=191}
    IndLeft: 'IndLeft',
    // @see {http://localhost/MS-VSDX.pdf#page=191}
    IndRight: 'IndRight',
    // @see {http://localhost/MS-VSDX.pdf#page=191}
    InhibitSnap: 'InhibitSnap',
    // @see {http://localhost/MS-VSDX.pdf#page=191}
    Initials: 'Initials',
    // @see {http://localhost/MS-VSDX.pdf#page=191}
    Invisible: 'Invisible',
    // @see {http://localhost/MS-VSDX.pdf#page=191}
    IsDropSource: 'IsDropSource',
    // @see {http://localhost/MS-VSDX.pdf#page=191}
    IsDropTarget: 'IsDropTarget',
    // @see {http://localhost/MS-VSDX.pdf#page=192}
    IsSnapTarget: 'IsSnapTarget',
    // @see {http://localhost/MS-VSDX.pdf#page=192}
    IsTextEditTarget: 'IsTextEditTarget',
    // @see {http://localhost/MS-VSDX.pdf#page=192}
    KeepTextFlat: 'KeepTextFlat',
    // @see {http://localhost/MS-VSDX.pdf#page=192}
    Label: 'Label',
    // @see {http://localhost/MS-VSDX.pdf#page=192}
    LangID: 'LangID',
    // @see {http://localhost/MS-VSDX.pdf#page=192}
    LayerMember: 'LayerMember',
    // @see {http://localhost/MS-VSDX.pdf#page=192}
    LeftMargin: 'LeftMargin',
    // @see {http://localhost/MS-VSDX.pdf#page=192}
    Letterspace: 'Letterspace',
    // @see {http://localhost/MS-VSDX.pdf#page=193}
    LineAdjustFrom: 'LineAdjustFrom',
    // @see {http://localhost/MS-VSDX.pdf#page=193}
    LineAdjustTo: 'LineAdjustTo',
    // @see {http://localhost/MS-VSDX.pdf#page=193}
    LineCap: 'LineCap',
    // @see {http://localhost/MS-VSDX.pdf#page=193}
    LineColor: 'LineColor',
    // @see {http://localhost/MS-VSDX.pdf#page=193}
    LineColorTrans: 'LineColorTrans',
    // @see {http://localhost/MS-VSDX.pdf#page=193}
    LineGradientAngle: 'LineGradientAngle',
    // @see {http://localhost/MS-VSDX.pdf#page=193}
    LineGradientDir: 'LineGradientDir',
    // @see {http://localhost/MS-VSDX.pdf#page=194}
    LineGradientEnabled: 'LineGradientEnabled',
    // @see {http://localhost/MS-VSDX.pdf#page=194}
    LineJumpCode: 'LineJumpCode',
    // @see {http://localhost/MS-VSDX.pdf#page=194}
    LineJumpFactorX: 'LineJumpFactorX',
    // @see {http://localhost/MS-VSDX.pdf#page=194}
    LineJumpFactorY: 'LineJumpFactorY',
    // @see {http://localhost/MS-VSDX.pdf#page=195}
    LineJumpStyle: 'LineJumpStyle',
    // @see {http://localhost/MS-VSDX.pdf#page=195}
    LinePattern: 'LinePattern',
    // @see {http://localhost/MS-VSDX.pdf#page=195}
    LineRouteExt: 'LineRouteExt',
    // @see {http://localhost/MS-VSDX.pdf#page=196}
    LineToLineX: 'LineToLineX',
    // @see {http://localhost/MS-VSDX.pdf#page=196}
    LineToLineY: 'LineToLineY',
    // @see {http://localhost/MS-VSDX.pdf#page=196}
    LineToNodeX: 'LineToNodeX',
    // @see {http://localhost/MS-VSDX.pdf#page=196}
    LineToNodeY: 'LineToNodeY',
    // @see {http://localhost/MS-VSDX.pdf#page=197}
    LineWeight: 'LineWeight',
    // @see {http://localhost/MS-VSDX.pdf#page=197}
    LocalizeMerge: 'LocalizeMerge',
    // @see {http://localhost/MS-VSDX.pdf#page=197}
    Lock: 'Lock',
    // @see {http://localhost/MS-VSDX.pdf#page=197}
    LockAspect: 'LockAspect',
    // @see {http://localhost/MS-VSDX.pdf#page=197}
    LockBegin: 'LockBegin',
    // @see {http://localhost/MS-VSDX.pdf#page=197}
    LockCalcWH: 'LockCalcWH',
    // @see {http://localhost/MS-VSDX.pdf#page=197}
    LockCrop: 'LockCrop',
    // @see {http://localhost/MS-VSDX.pdf#page=197}
    LockCustProp: 'LockCustProp',
    // @see {http://localhost/MS-VSDX.pdf#page=197}
    LockDelete: 'LockDelete',
    // @see {http://localhost/MS-VSDX.pdf#page=197}
    LockEnd: 'LockEnd',
    // @see {http://localhost/MS-VSDX.pdf#page=198}
    LockFormat: 'LockFormat',
    // @see {http://localhost/MS-VSDX.pdf#page=198}
    LockFromGroupFormat: 'LockFromGroupFormat',
    // @see {http://localhost/MS-VSDX.pdf#page=198}
    LockGroup: 'LockGroup',
    // @see {http://localhost/MS-VSDX.pdf#page=198}
    LockHeight: 'LockHeight',
    // @see {http://localhost/MS-VSDX.pdf#page=198}
    LockMoveX: 'LockMoveX',
    // @see {http://localhost/MS-VSDX.pdf#page=198}
    LockMoveY: 'LockMoveY',
    // @see {http://localhost/MS-VSDX.pdf#page=198}
    LockPreview: 'LockPreview',
    // @see {http://localhost/MS-VSDX.pdf#page=198}
    LockReplace: 'LockReplace',
    // @see {http://localhost/MS-VSDX.pdf#page=198}
    LockRotate: 'LockRotate',
    // @see {http://localhost/MS-VSDX.pdf#page=198}
    LockSelect: 'LockSelect',
    // @see {http://localhost/MS-VSDX.pdf#page=199}
    LockTextEdit: 'LockTextEdit',
    // @see {http://localhost/MS-VSDX.pdf#page=199}
    LockThemeColors: 'LockThemeColors',
    // @see {http://localhost/MS-VSDX.pdf#page=199}
    LockThemeConnectors: 'LockThemeConnectors',
    // @see {http://localhost/MS-VSDX.pdf#page=199}
    LockThemeEffects: 'LockThemeEffects',
    // @see {http://localhost/MS-VSDX.pdf#page=199}
    LockThemeFonts: 'LockThemeFonts',
    // @see {http://localhost/MS-VSDX.pdf#page=199}
    LockThemeIndex: 'LockThemeIndex',
    // @see {http://localhost/MS-VSDX.pdf#page=199}
    LockVariation: 'LockVariation',
    // @see {http://localhost/MS-VSDX.pdf#page=199}
    LockVtxEdit: 'LockVtxEdit',
    // @see {http://localhost/MS-VSDX.pdf#page=199}
    LockWidth: 'LockWidth',
    // @see {http://localhost/MS-VSDX.pdf#page=199}
    LocPinX: 'LocPinX',
    // @see {http://localhost/MS-VSDX.pdf#page=200}
    LocPinY: 'LocPinY',
    // @see {http://localhost/MS-VSDX.pdf#page=200}
    Menu: 'Menu',
    // @see {http://localhost/MS-VSDX.pdf#page=200}
    Name: 'Name',
    // @see {http://localhost/MS-VSDX.pdf#page=200}
    NameUniv: 'NameUniv',
    // @see {http://localhost/MS-VSDX.pdf#page=200}
    NewWindow: 'NewWindow',
    // @see {http://localhost/MS-VSDX.pdf#page=200}
    NoAlignBox: 'NoAlignBox',
    // @see {http://localhost/MS-VSDX.pdf#page=200}
    NoCoauth: 'NoCoauth',
    // @see {http://localhost/MS-VSDX.pdf#page=200}
    NoCtlHandles: 'NoCtlHandles',
    // @see {http://localhost/MS-VSDX.pdf#page=200}
    NoFill: 'NoFill',
    // @see {http://localhost/MS-VSDX.pdf#page=200}
    NoLine: 'NoLine',
    // @see {http://localhost/MS-VSDX.pdf#page=201}
    NoLiveDynamics: 'NoLiveDynamics',
    // @see {http://localhost/MS-VSDX.pdf#page=201}
    NonPrinting: 'NonPrinting',
    // @see {http://localhost/MS-VSDX.pdf#page=201}
    NoObjHandles: 'NoObjHandles',
    // @see {http://localhost/MS-VSDX.pdf#page=201}
    NoProofing: 'NoProofing',
    // @see {http://localhost/MS-VSDX.pdf#page=201}
    NoQuickDrag: 'NoQuickDrag',
    // @see {http://localhost/MS-VSDX.pdf#page=201}
    NoShow: 'NoShow',
    // @see {http://localhost/MS-VSDX.pdf#page=201}
    NoSnap: 'NoSnap',
    // @see {http://localhost/MS-VSDX.pdf#page=201}
    ObjectKind: 'ObjectKind',
    // @see {http://localhost/MS-VSDX.pdf#page=201}
    ObjType: 'ObjType',
    // @see {http://localhost/MS-VSDX.pdf#page=202}
    OnPage: 'OnPage',
    // @see {http://localhost/MS-VSDX.pdf#page=202}
    OutputFormat: 'OutputFormat',
    // @see {http://localhost/MS-VSDX.pdf#page=202}
    Overline: 'Overline',
    // @see {http://localhost/MS-VSDX.pdf#page=202}
    PageBottomMargin: 'PageBottomMargin',
    // @see {http://localhost/MS-VSDX.pdf#page=202}
    PageHeight: 'PageHeight',
    // @see {http://localhost/MS-VSDX.pdf#page=202}
    PageLeftMargin: 'PageLeftMargin',
    // @see {http://localhost/MS-VSDX.pdf#page=202}
    PageLineJumpDirX: 'PageLineJumpDirX',
    // @see {http://localhost/MS-VSDX.pdf#page=202}
    PageLineJumpDirY: 'PageLineJumpDirY',
    // @see {http://localhost/MS-VSDX.pdf#page=203}
    PageLockDuplicate: 'PageLockDuplicate',
    // @see {http://localhost/MS-VSDX.pdf#page=203}
    PageLockReplace: 'PageLockReplace',
    // @see {http://localhost/MS-VSDX.pdf#page=203}
    PageRightMargin: 'PageRightMargin',
    // @see {http://localhost/MS-VSDX.pdf#page=203}
    PageScale: 'PageScale',
    // @see {http://localhost/MS-VSDX.pdf#page=203}
    PageShapeSplit: 'PageShapeSplit',
    // @see {http://localhost/MS-VSDX.pdf#page=203}
    PagesX: 'PagesX',
    // @see {http://localhost/MS-VSDX.pdf#page=203}
    PagesY: 'PagesY',
    // @see {http://localhost/MS-VSDX.pdf#page=203}
    PageTopMargin: 'PageTopMargin',
    // @see {http://localhost/MS-VSDX.pdf#page=203}
    PageWidth: 'PageWidth',
    // @see {http://localhost/MS-VSDX.pdf#page=203}
    PaperKind: 'PaperKind',
    // @see {http://localhost/MS-VSDX.pdf#page=204}
    PaperSource: 'PaperSource',
    // @see {http://localhost/MS-VSDX.pdf#page=204}
    Perspective: 'Perspective',
    // @see {http://localhost/MS-VSDX.pdf#page=204}
    PinX: 'PinX',
    // @see {http://localhost/MS-VSDX.pdf#page=204}
    PinY: 'PinY',
    // @see {http://localhost/MS-VSDX.pdf#page=204}
    PlaceDepth: 'PlaceDepth',
    // @see {http://localhost/MS-VSDX.pdf#page=204}
    PlaceFlip: 'PlaceFlip',
    // @see {http://localhost/MS-VSDX.pdf#page=204}
    PlaceStyle: 'PlaceStyle',
    // @see {http://localhost/MS-VSDX.pdf#page=204}
    PlowCode: 'PlowCode',
    // @see {http://localhost/MS-VSDX.pdf#page=204}
    Pos: 'Pos',
    // @see {http://localhost/MS-VSDX.pdf#page=205}
    Position: 'Position',
    // @see {http://localhost/MS-VSDX.pdf#page=205}
    Position0: 'Position0',
    //TODO miky BRND page1.xml
    PreviewQuality: 'PreviewQuality',
    // @see {http://localhost/MS-VSDX.pdf#page=205}
    PreviewScope: 'PreviewScope',
    // @see {http://localhost/MS-VSDX.pdf#page=205}
    Print: 'Print',
    // @see {http://localhost/MS-VSDX.pdf#page=205}
    PrintGrid: 'PrintGrid',
    // @see {http://localhost/MS-VSDX.pdf#page=205}
    PrintPageOrientation: 'PrintPageOrientation',
    // @see {http://localhost/MS-VSDX.pdf#page=205}
    Prompt: 'Prompt',
    // @see {http://localhost/MS-VSDX.pdf#page=206}
    QuickStyleEffectsMatrix: 'QuickStyleEffectsMatrix',
    // @see {http://localhost/MS-VSDX.pdf#page=206}
    QuickStyleFillColor: 'QuickStyleFillColor',
    // @see {http://localhost/MS-VSDX.pdf#page=207}
    QuickStyleFillMatrix: 'QuickStyleFillMatrix',
    // @see {http://localhost/MS-VSDX.pdf#page=208}
    QuickStyleFontColor: 'QuickStyleFontColor',
    // @see {http://localhost/MS-VSDX.pdf#page=209}
    QuickStyleFontMatrix: 'QuickStyleFontMatrix',
    // @see {http://localhost/MS-VSDX.pdf#page=209}
    QuickStyleLineColor: 'QuickStyleLineColor',
    // @see {http://localhost/MS-VSDX.pdf#page=210}
    QuickStyleLineMatrix: 'QuickStyleLineMatrix',
    // @see {http://localhost/MS-VSDX.pdf#page=210}
    QuickStyleShadowColor: 'QuickStyleShadowColor',
    // @see {http://localhost/MS-VSDX.pdf#page=211}
    QuickStyleType: 'QuickStyleType',
    // @see {http://localhost/MS-VSDX.pdf#page=211}
    QuickStyleVariation: 'QuickStyleVariation',
    // @see {http://localhost/MS-VSDX.pdf#page=211}
    ReadOnly: 'ReadOnly',
    // @see {http://localhost/MS-VSDX.pdf#page=213}
    ReflectionBlur: 'ReflectionBlur',
    // @see {http://localhost/MS-VSDX.pdf#page=213}
    ReflectionDist: 'ReflectionDist',
    // @see {http://localhost/MS-VSDX.pdf#page=213}
    ReflectionSize: 'ReflectionSize',
    // @see {http://localhost/MS-VSDX.pdf#page=213}
    ReflectionTrans: 'ReflectionTrans',
    // @see {http://localhost/MS-VSDX.pdf#page=213}
    Relationships: 'Relationships',
    // @see {http://localhost/MS-VSDX.pdf#page=213}
    ReplaceCopyCells: 'ReplaceCopyCells',
    // @see {http://localhost/MS-VSDX.pdf#page=213}
    ReplaceLockFormat: 'ReplaceLockFormat',
    // @see {http://localhost/MS-VSDX.pdf#page=213}
    ReplaceLockShapeData: 'ReplaceLockShapeData',
    // @see {http://localhost/MS-VSDX.pdf#page=214}
    ReplaceLockText: 'ReplaceLockText',
    // @see {http://localhost/MS-VSDX.pdf#page=214}
    ResizeMode: 'ResizeMode',
    // @see {http://localhost/MS-VSDX.pdf#page=214}
    ResizePage: 'ResizePage',
    // @see {http://localhost/MS-VSDX.pdf#page=214}
    ReviewerID: 'ReviewerID',
    // @see {http://localhost/MS-VSDX.pdf#page=214}
    RightMargin: 'RightMargin',
    // @see {http://localhost/MS-VSDX.pdf#page=214}
    RotateGradientWithShape: 'RotateGradientWithShape',
    // @see {http://localhost/MS-VSDX.pdf#page=214}
    RotationType: 'RotationType',
    // @see {http://localhost/MS-VSDX.pdf#page=214}
    RotationXAngle: 'RotationXAngle',
    // @see {http://localhost/MS-VSDX.pdf#page=215}
    RotationYAngle: 'RotationYAngle',
    // @see {http://localhost/MS-VSDX.pdf#page=215}
    RotationZAngle: 'RotationZAngle',
    // @see {http://localhost/MS-VSDX.pdf#page=215}
    Rounding: 'Rounding',
    // @see {http://localhost/MS-VSDX.pdf#page=215}
    RouteStyle: 'RouteStyle',
    // @see {http://localhost/MS-VSDX.pdf#page=215}
    ScaleX: 'ScaleX',
    // @see {http://localhost/MS-VSDX.pdf#page=215}
    ScaleY: 'ScaleY',
    // @see {http://localhost/MS-VSDX.pdf#page=216}
    SelectMode: 'SelectMode',
    // @see {http://localhost/MS-VSDX.pdf#page=216}
    ShapeFixedCode: 'ShapeFixedCode',
    // @see {http://localhost/MS-VSDX.pdf#page=216}
    ShapeKeywords: 'ShapeKeywords',
    // @see {http://localhost/MS-VSDX.pdf#page=216}
    ShapePermeablePlace: 'ShapePermeablePlace',
    // @see {http://localhost/MS-VSDX.pdf#page=216}
    ShapePermeableX: 'ShapePermeableX',
    // @see {http://localhost/MS-VSDX.pdf#page=216}
    ShapePermeableY: 'ShapePermeableY',
    // @see {http://localhost/MS-VSDX.pdf#page=216}
    ShapePlaceFlip: 'ShapePlaceFlip',
    // @see {http://localhost/MS-VSDX.pdf#page=216}
    ShapePlaceStyle: 'ShapePlaceStyle',
    // @see {http://localhost/MS-VSDX.pdf#page=217}
    ShapePlowCode: 'ShapePlowCode',
    // @see {http://localhost/MS-VSDX.pdf#page=217}
    ShapeRouteStyle: 'ShapeRouteStyle',
    // @see {http://localhost/MS-VSDX.pdf#page=217}
    ShapeShdwBlur: 'ShapeShdwBlur',
    // @see {http://localhost/MS-VSDX.pdf#page=217}
    ShapeShdwObliqueAngle: 'ShapeShdwObliqueAngle',
    // @see {http://localhost/MS-VSDX.pdf#page=217}
    ShapeShdwOffsetX: 'ShapeShdwOffsetX',
    // @see {http://localhost/MS-VSDX.pdf#page=217}
    ShapeShdwOffsetY: 'ShapeShdwOffsetY',
    // @see {http://localhost/MS-VSDX.pdf#page=217}
    ShapeShdwScaleFactor: 'ShapeShdwScaleFactor',
    // @see {http://localhost/MS-VSDX.pdf#page=217}
    ShapeShdwShow: 'ShapeShdwShow',
    // @see {http://localhost/MS-VSDX.pdf#page=218}
    ShapeShdwType: 'ShapeShdwType',
    // @see {http://localhost/MS-VSDX.pdf#page=218}
    ShapeSplit: 'ShapeSplit',
    // @see {http://localhost/MS-VSDX.pdf#page=218}
    ShapeSplittable: 'ShapeSplittable',
    // @see {http://localhost/MS-VSDX.pdf#page=218}
    Sharpen: 'Sharpen',
    // @see {http://localhost/MS-VSDX.pdf#page=218}
    ShdwBkgnd: 'ShdwBkgnd',
    //TODO miky FIGS page1.xml
    ShdwBkgndTrans: 'ShdwBkgndTrans',
    //TODO miky FIGS page1.xml
    ShdwForegnd: 'ShdwForegnd',
    // @see {http://localhost/MS-VSDX.pdf#page=219}
    ShdwForegndTrans: 'ShdwForegndTrans',
    // @see {http://localhost/MS-VSDX.pdf#page=219}
    ShdwObliqueAngle: 'ShdwObliqueAngle',
    // @see {http://localhost/MS-VSDX.pdf#page=219}
    ShdwOffsetX: 'ShdwOffsetX',
    // @see {http://localhost/MS-VSDX.pdf#page=219}
    ShdwOffsetY: 'ShdwOffsetY',
    // @see {http://localhost/MS-VSDX.pdf#page=219}
    ShdwPattern: 'ShdwPattern',
    // @see {http://localhost/MS-VSDX.pdf#page=220}
    ShdwScaleFactor: 'ShdwScaleFactor',
    // @see {http://localhost/MS-VSDX.pdf#page=220}
    ShdwType: 'ShdwType',
    // @see {http://localhost/MS-VSDX.pdf#page=220}
    Size: 'Size',
    // @see {http://localhost/MS-VSDX.pdf#page=220}
    SketchAmount: 'SketchAmount',
    // @see {http://localhost/MS-VSDX.pdf#page=220}
    SketchEnabled: 'SketchEnabled',
    // @see {http://localhost/MS-VSDX.pdf#page=221}
    SketchFillChange: 'SketchFillChange',
    // @see {http://localhost/MS-VSDX.pdf#page=221}
    SketchLineChange: 'SketchLineChange',
    // @see {http://localhost/MS-VSDX.pdf#page=221}
    SketchLineWeight: 'SketchLineWeight',
    // @see {http://localhost/MS-VSDX.pdf#page=221}
    SketchSeed: 'SketchSeed',
    // @see {http://localhost/MS-VSDX.pdf#page=221}
    Snap: 'Snap',
    // @see {http://localhost/MS-VSDX.pdf#page=221}
    SoftEdgesSize: 'SoftEdgesSize',
    // @see {http://localhost/MS-VSDX.pdf#page=221}
    SortKey: 'SortKey',
    // @see {http://localhost/MS-VSDX.pdf#page=222}
    SpAfter: 'SpAfter',
    // @see {http://localhost/MS-VSDX.pdf#page=222}
    SpBefore: 'SpBefore',
    // @see {http://localhost/MS-VSDX.pdf#page=222}
    SpLine: 'SpLine',
    // @see {http://localhost/MS-VSDX.pdf#page=222}
    Status: 'Status',
    // @see {http://localhost/MS-VSDX.pdf#page=222}
    Strikethru: 'Strikethru',
    // @see {http://localhost/MS-VSDX.pdf#page=222}
    Style: 'Style',
    // @see {http://localhost/MS-VSDX.pdf#page=222}
    SubAddress: 'SubAddress',
    // @see {http://localhost/MS-VSDX.pdf#page=223}
    TagName: 'TagName',
    // @see {http://localhost/MS-VSDX.pdf#page=223}
    TextBkgnd: 'TextBkgnd',
    // @see {http://localhost/MS-VSDX.pdf#page=223}
    TextBkgndTrans: 'TextBkgndTrans',
    // @see {http://localhost/MS-VSDX.pdf#page=223}
    TextDirection: 'TextDirection',
    // @see {http://localhost/MS-VSDX.pdf#page=224}
    TextPosAfterBullet: 'TextPosAfterBullet',
    // @see {http://localhost/MS-VSDX.pdf#page=224}
    TheData: 'TheData',
    // @see {http://localhost/MS-VSDX.pdf#page=224}
    ThemeIndex: 'ThemeIndex',
    // @see {http://localhost/MS-VSDX.pdf#page=224}
    TheText: 'TheText',
    // @see {http://localhost/MS-VSDX.pdf#page=224}
    TopMargin: 'TopMargin',
    // @see {http://localhost/MS-VSDX.pdf#page=224}
    Transparency: 'Transparency',
    // @see {http://localhost/MS-VSDX.pdf#page=224}
    TxtAngle: 'TxtAngle',
    // @see {http://localhost/MS-VSDX.pdf#page=225}
    TxtHeight: 'TxtHeight',
    // @see {http://localhost/MS-VSDX.pdf#page=225}
    TxtLocPinX: 'TxtLocPinX',
    // @see {http://localhost/MS-VSDX.pdf#page=225}
    TxtLocPinY: 'TxtLocPinY',
    // @see {http://localhost/MS-VSDX.pdf#page=225}
    TxtPinX: 'TxtPinX',
    // @see {http://localhost/MS-VSDX.pdf#page=225}
    TxtPinY: 'TxtPinY',
    // @see {http://localhost/MS-VSDX.pdf#page=225}
    TxtWidth: 'TxtWidth',
    // @see {http://localhost/MS-VSDX.pdf#page=225}
    Type: 'Type',
    // @see {http://localhost/MS-VSDX.pdf#page=225}
    UICat: 'UICat',
    // @see {http://localhost/MS-VSDX.pdf#page=226}
    UICod: 'UICod',
    // @see {http://localhost/MS-VSDX.pdf#page=226}
    UIFmt: 'UIFmt',
    // @see {http://localhost/MS-VSDX.pdf#page=226}
    UIVisibility: 'UIVisibility',
    // @see {http://localhost/MS-VSDX.pdf#page=226}
    UpdateAlignBox: 'UpdateAlignBox',
    // @see {http://localhost/MS-VSDX.pdf#page=226}
    UseGroupGradient: 'UseGroupGradient',
    // @see {http://localhost/MS-VSDX.pdf#page=226}
    Value: 'Value',
    // @see {http://localhost/MS-VSDX.pdf#page=226}
    VariationColorIndex: 'VariationColorIndex',
    // @see {http://localhost/MS-VSDX.pdf#page=226}
    VariationStyleIndex: 'VariationStyleIndex',
    // @see {http://localhost/MS-VSDX.pdf#page=227}
    Verify: 'Verify',
    // @see {http://localhost/MS-VSDX.pdf#page=228}
    VerticalAlign: 'VerticalAlign',
    // @see {http://localhost/MS-VSDX.pdf#page=228}
    ViewMarkup: 'ViewMarkup',
    // @see {http://localhost/MS-VSDX.pdf#page=228}
    Visible: 'Visible',
    // @see {http://localhost/MS-VSDX.pdf#page=228}
    WalkPreference: 'WalkPreference',
    // @see {http://localhost/MS-VSDX.pdf#page=228}
    Width: 'Width',
    // @see {http://localhost/MS-VSDX.pdf#page=229}
    X: 'X',
    // @see {http://localhost/MS-VSDX.pdf#page=229}
    XCon: 'XCon',
    // @see {http://localhost/MS-VSDX.pdf#page=229}
    XDyn: 'XDyn',
    // @see {http://localhost/MS-VSDX.pdf#page=229}
    XGridDensity: 'XGridDensity',
    // @see {http://localhost/MS-VSDX.pdf#page=229}
    XGridOrigin: 'XGridOrigin',
    // @see {http://localhost/MS-VSDX.pdf#page=229}
    XGridSpacing: 'XGridSpacing',
    // @see {http://localhost/MS-VSDX.pdf#page=229}
    XJustify: 'XJustify',
    // @see {http://localhost/MS-VSDX.pdf#page=229}
    XRulerDensity: 'XRulerDensity',
    // @see {http://localhost/MS-VSDX.pdf#page=229}
    XRulerOrigin: 'XRulerOrigin',
    // @see {http://localhost/MS-VSDX.pdf#page=230}
    Y: 'Y',
    // @see {http://localhost/MS-VSDX.pdf#page=230}
    YCon: 'YCon',
    // @see {http://localhost/MS-VSDX.pdf#page=230}
    YDyn: 'YDyn',
    // @see {http://localhost/MS-VSDX.pdf#page=230}
    YGridDensity: 'YGridDensity',
    // @see {http://localhost/MS-VSDX.pdf#page=230}
    YGridOrigin: 'YGridOrigin',
    // @see {http://localhost/MS-VSDX.pdf#page=230}
    YGridSpacing: 'YGridSpacing',
    // @see {http://localhost/MS-VSDX.pdf#page=230}
    YJustify: 'YJustify',
    // @see {http://localhost/MS-VSDX.pdf#page=230}
    YRulerDensity: 'YRulerDensity',
    // @see {http://localhost/MS-VSDX.pdf#page=230}
    YRulerOrigin: 'YRulerOrigin' // @see {http://localhost/MS-VSDX.pdf#page=231}
  };

  /** @enum {string} VisioShapeType */
  var VisioShapeType = {
    Shape: 'Shape',
    Group: 'Group',
    Foreign: 'Foreign',
    Guide: 'Guide',
    MasterShape1: 'MasterShape1',
    // in masters.xml
    MasterShape2: 'MasterShape2',
    // in master2.xml
    Dummy: 'Dummy',
    // created during import
    LinkLabel: 'LinkLabel'
  };

  /** @enum {string} VisioSectionType */
  var VisioSectionType = {
    Actions: 'Actions',
    ActionTag: 'ActionTag',
    Character: 'Character',
    Connection: 'Connection',
    Control: 'Control',
    Field: 'Field',
    FillGradient: 'FillGradient',
    Geometry: 'Geometry',
    Hyperlink: 'Hyperlink',
    Layer: 'Layer',
    LineGradient: 'LineGradient',
    Paragraph: 'Paragraph',
    User: 'User',
    Property: 'Property',
    Scratch: 'Scratch',
    Tabs: 'Tabs'

    // TODO: unimplemented
    // ConnectionABCD: 'ConnectionABCD',
    // Reviewer: 'Reviewer',
    // Annotation: 'Annotation',
  };

  /** @enum {string} VisioJxonRowAttributeName */
  var VisioJxonRowAttributeName = {
    Type: '@T',
    Name: '@N',
    UniqueIndex: '@IX',
    Deleted: '@Del'
  };

  /** @enum {string} VisioRowStructureType */
  var VisioRowStructureType = {
    Indexed: 'Indexed',
    Named: 'Named'
  };

  /** @enum {string} VisioRowType */
  var VisioRowType = {
    ArcTo: 'ArcTo',
    Ellipse: 'Ellipse',
    EllipticalArcTo: 'EllipticalArcTo',
    InfiniteLine: 'InfiniteLine',
    LineTo: 'LineTo',
    MoveTo: 'MoveTo',
    NURBSTo: 'NURBSTo',
    PolylineTo: 'PolylineTo',
    RelCubBezTo: 'RelCubBezTo',
    RelEllipticalArcTo: 'RelEllipticalArcTo',
    RelLineTo: 'RelLineTo',
    RelMoveTo: 'RelMoveTo',
    RelQuadBezTo: 'RelQuadBezTo',
    SplineStart: 'SplineStart',
    SplineKnot: 'SplineKnot'
  };

  /** @enum {string} VisioShapeDebugType */
  var VisioShapeDebugType = {
    ShapeSimple: 'ShapeSimple',
    ShapeGroupItem: 'ShapeGroupItem',
    ShapeMaster: 'ShapeMaster',
    ShapeGroup: 'ShapeGroup',
    ShapeForeign: 'ShapeForeign',
    ShapeGuide: 'ShapeGuide',
    GeneralMaster: 'GeneralMaster',
    //TODO miky inconsistent
    ShapeDeleteOverride: 'ShapeDeleteOverride'
  };

  /** @enum {string} VisioAttribute (VisioObjectRootAttribute) */
  var VisioAttribute = {
    //TODO miky
    // to sort
    archive: 'archive',
    xmlPath: 'xmlPath',
    shapeId: 'shapeId',
    source: 'source',
    target: 'target',
    // _
    _rel: '_rel',
    // A
    alignName: 'alignName',
    // B
    baseID: 'baseID',
    base64: 'base64',
    background: 'background',
    backPage: 'backPage',
    beginX: 'beginX',
    beginY: 'beginY',
    // C
    cells: 'cells',
    colors: 'colors',
    connects: 'connects',
    // D
    deleted: 'deleted',
    defaultLineStyle: 'defaultLineStyle',
    defaultTextStyle: 'defaultTextStyle',
    defaultFillStyle: 'defaultFillStyle',
    defaultGuideStyle: 'defaultGuideStyle',
    documentSheet: 'documentSheet',
    documentSettings: 'documentSettings',
    dynamicGridEnabled: 'dynamicGridEnabled',
    // E
    endX: 'endX',
    endY: 'endY',
    // F
    faceNames: 'faceNames',
    fillStyle: 'fillStyle',
    foreignData: 'foreignData',
    foreignShapes: 'foreignShapes',
    fromSheet: 'fromSheet',
    fromCell: 'fromCell',
    fromPart: 'fromPart',
    // G
    glueSettings: 'glueSettings',
    // H
    hidden: 'hidden',
    // I
    icon: 'icon',
    iconSize: 'iconSize',
    iconUpdate: 'iconUpdate',
    id: 'id',
    index: 'index',
    isCustomNameU: 'isCustomNameU',
    isCustomName: 'isCustomName',
    // L
    lineStyle: 'lineStyle',
    // M
    master: 'master',
    masterId: 'masterId',
    masterShapeId: 'masterShapeId',
    masterShape: 'masterShape',
    masterType: 'masterType',
    matchByName: 'matchByName',
    // N
    name: 'name',
    nameU: 'nameU',
    n: 'n',
    // O
    originalId: 'originalId',
    // P
    pages: 'pages',
    pageSheet: 'pageSheet',
    patternFlags: 'patternFlags',
    prompt: 'prompt',
    protectStyles: 'protectStyles',
    protectShapes: 'protectShapes',
    protectMasters: 'protectMasters',
    protectBkgnds: 'protectBkgnds',
    // R
    rels: 'rels',
    relations: 'relations',
    relMasterShape: 'relMasterShape',
    rows: 'rows',
    // S
    shapes: 'shapes',
    shape: 'shape',
    sections: 'sections',
    snapSettings: 'snapSettings',
    snapExtensions: 'snapExtensions',
    snapAngles: 'snapAngles',
    styleSheets: 'styleSheets',
    // T
    text: 'text',
    textStyle: 'textStyle',
    topPage: 'topPage',
    toSheet: 'toSheet',
    toCell: 'toCell',
    toPart: 'toPart',
    type: 'type',
    // U
    uniqueId: 'uniqueId',
    // V
    val: 'val',
    // general value attribute
    viewScale: 'viewScale',
    viewCenterX: 'viewCenterX',
    viewCenterY: 'viewCenterY',
    // X
    xmlns: 'xmlns',
    'xmlns:r': 'xmlns:r',
    'xml:space': 'xml:space',
    // special
    jxon: 'jxon'
  };

  /** @enum {string} VisioConvertType */
  var VisioConvertType = {
    ignore: 'ignore',
    number: 'number',
    booleanStrict: 'booleanStrict',
    booleanTriState: 'booleanTriState',
    color: 'color',
    asIs: 'asIs',
    "byte": 'byte',
    // PtgByte @see {http://localhost/MS-VSDX.pdf#page=332&zoom=100,92,869}
    date: 'date',
    percentage: 'percentage',
    internalUnitsToPixels: 'internalUnitsToPixels',
    internalUnitsToDegrees: 'internalUnitsToDegrees',
    resolveByPath: 'resolveByPath' // different types dependent on xml structure
  };

  /** @enum {string} VisioXsdType */
  var VisioXsdType = {
    Shape_Type: 'Shape_Type',
    Master_Type: 'Master_Type',
    Section_Type: 'Section_Type',
    Row_Type: 'Row_Type'
  };

  /** @enum {string} VisioValueType */
  var VisioValueType = {
    // PtgNum @see {http://localhost/MS-VSDX.pdf#page=337&zoom=100,92,677}
    // double precision floating-point number
    PtgNum: 'PtgNum',
    // PtgByte @see {http://localhost/MS-VSDX.pdf#page=332&zoom=100,92,869}
    //  an unsigned byte value
    PtgByte: 'PtgByte',
    // PtgBool @see {http://localhost/MS-VSDX.pdf#page=332&zoom=100,92,522}
    PtgBool: 'PtgBool',
    // PtgString @see {}
    PtgString: 'PtgString',
    // PtgColorRGB @see {}
    PtgColorRGB: 'PtgColorRGB',
    // PtgShort @see {}
    PtgShort: 'PtgShort',
    // PtgDate @see {}
    PtgDate: 'PtgDate',
    // PtgInt @see {}
    PtgInt: 'PtgInt',
    // PtgUnsShort @see {}
    PtgUnsShort: 'PtgUnsShort',
    // PtgNumI @see {}
    PtgNumI: 'PtgNumI',
    // vLanguageString @see {}
    vLanguageString: 'vLanguageString',
    // vFont @see {http://localhost/MS-VSDX.pdf#page=370&zoom=100,92,240}
    vFont: 'vFont',
    // vAny @see {}
    vAny: 'vAny',
    // vAngle @see {}
    vAngle: 'vAngle',
    // vScalar @see {http://localhost/MS-VSDX.pdf#page=360&zoom=100,92,273}
    vScalar: 'vScalar',
    // vLength @see {http://localhost/MS-VSDX.pdf#page=359&zoom=100,92,710}
    //  The value of any type in this
    // grouping MUST be interpreted as a lengthInternalUnitNumber.
    // http://localhost/MS-VSDX.pdf#page=360&zoom=100,92,734
    vLength: 'vLength',
    // vColor @see {}
    vColor: 'vColor',
    // vFormatString @see {http://localhost/MS-VSDX.pdf#page=370&zoom=100,92,318}
    vFormatString: 'vFormatString',
    formulaExpression: 'formulaExpression'
  };

  /** @enum {string} VisioThemeValKey */
  var VisioThemeValKey = {
    // A
    AccentColor: 'AccentColor',
    AccentColor2: 'AccentColor2',
    AccentColor3: 'AccentColor3',
    AccentColor4: 'AccentColor4',
    AccentColor5: 'AccentColor5',
    AccentColor6: 'AccentColor6',
    AsianFont: 'AsianFont',
    // B
    BackgroundColor: 'BackgroundColor',
    BevelTopType: 'BevelTopType',
    BevelTopWidth: 'BevelTopWidth',
    BevelTopHeight: 'BevelTopHeight',
    BevelMaterial: 'BevelMaterial',
    BevelLighting: 'BevelLighting',
    BevelLightingAngle: 'BevelLightingAngle',
    BevelContourColor: 'BevelContourColor',
    BevelContourSize: 'BevelContourSize',
    // C
    ComplexFont: 'ComplexFont',
    ConnectorColor: 'ConnectorColor',
    ConnectorPattern: 'ConnectorPattern',
    ConnectorWeight: 'ConnectorWeight',
    ConnectorTransparency: 'ConnectorTransparency',
    ConnectorRounding: 'ConnectorRounding',
    ConnectorBegin: 'ConnectorBegin',
    ConnectorEnd: 'ConnectorEnd',
    ConnectorBeginSize: 'ConnectorBeginSize',
    ConnectorEndSize: 'ConnectorEndSize',
    // D
    Dark: 'Dark',
    // F
    FillColor: 'FillColor',
    FillColor2: 'FillColor2',
    FillGradientEnabled: 'FillGradientEnabled',
    FillGradientDir: 'FillGradientDir',
    FillGradientAngle: 'FillGradientAngle',
    FillPattern: 'FillPattern',
    FillTransparency: 'FillTransparency',
    // G
    GlowSize: 'GlowSize',
    GlowColor: 'GlowColor',
    GlowTransparency: 'GlowTransparency',
    // H

    // L
    LatinFont: 'LatinFont',
    Light: 'Light',
    LineCap: 'LineCap',
    LineColor: 'LineColor',
    LineColorTrans: 'LineColorTrans',
    LineCompoundtype: 'LineCompoundtype',
    LineGradientEnabled: 'LineGradientEnabled',
    LineGradientDir: 'LineGradientDir',
    LineGradientAngle: 'LineGradientAngle',
    LinePattern: 'LinePattern',
    LineWeight: 'LineWeight',
    LineBegin: 'LineBegin',
    LineEnd: 'LineEnd',
    LineBeginSize: 'LineBeginSize',
    LineEndSize: 'LineEndSize',
    LineRounding: 'LineRounding',
    // R
    RotateGradientWithShape: 'RotateGradientWithShape',
    ReflectionBlur: 'ReflectionBlur',
    ReflectionDist: 'ReflectionDist',
    ReflectionSize: 'ReflectionSize',
    ReflectionTrans: 'ReflectionTrans',
    // S
    ShadowType: 'ShadowType',
    ShadowColor: 'ShadowColor',
    ShadowTransparency: 'ShadowTransparency',
    ShadowMagnification: 'ShadowMagnification',
    ShadowBlur: 'ShadowBlur',
    ShadowXOffset: 'ShadowXOffset',
    ShadowYOffset: 'ShadowYOffset',
    ShadowDirection: 'ShadowDirection',
    ShadowPattern: 'ShadowPattern',
    SoftEdgesSize: 'SoftEdgesSize',
    SketchAmount: 'SketchAmount',
    SketchEnabled: 'SketchEnabled',
    SketchFillChange: 'SketchFillChange',
    SketchLineChange: 'SketchLineChange',
    SketchLineWeight: 'SketchLineWeight',
    // T
    TextColor: 'TextColor',
    TextStyle: 'TextStyle',
    // U
    UseGroupGradient: 'UseGroupGradient',
    // V
    VariantColor1: 'VariantColor1',
    VariantColor2: 'VariantColor2',
    VariantColor3: 'VariantColor3',
    VariantColor4: 'VariantColor4',
    VariantColor5: 'VariantColor5',
    VariantColor6: 'VariantColor6',
    VariantColor7: 'VariantColor7'
  };

  var VisioSectionStructureType = {
    Actions: VisioRowStructureType.Named,
    Character: VisioRowStructureType.Indexed,
    Connection: VisioRowStructureType.Indexed,
    Control: VisioRowStructureType.Named,
    Field: VisioRowStructureType.Indexed,
    FillGradient: VisioRowStructureType.Indexed,
    Geometry: VisioRowStructureType.Indexed,
    Hyperlink: VisioRowStructureType.Named,
    Layer: VisioRowStructureType.Indexed,
    LineGradient: VisioRowStructureType.Indexed,
    Paragraph: VisioRowStructureType.Indexed,
    Property: VisioRowStructureType.Named,
    Reviewer: VisioRowStructureType.Indexed,
    Scratch: VisioRowStructureType.Indexed,
    ActionTag: VisioRowStructureType.Named,
    Tabs: VisioRowStructureType.Indexed,
    User: VisioRowStructureType.Named
  };

  var trim$1 = stringTrim.trim;


  var charAt$4 = functionUncurryThis(''.charAt);
  var $parseFloat = global_1.parseFloat;
  var Symbol$2 = global_1.Symbol;
  var ITERATOR = Symbol$2 && Symbol$2.iterator;
  var FORCED$2 = 1 / $parseFloat(whitespaces + '-0') !== -Infinity
    // MS Edge 18- broken with boxed symbols
    || (ITERATOR && !fails(function () { $parseFloat(Object(ITERATOR)); }));

  // `parseFloat` method
  // https://tc39.es/ecma262/#sec-parsefloat-string
  var numberParseFloat = FORCED$2 ? function parseFloat(string) {
    var trimmedString = trim$1(toString_1(string));
    var result = $parseFloat(trimmedString);
    return result === 0 && charAt$4(trimmedString, 0) == '-' ? -0 : result;
  } : $parseFloat;

  // `Number.parseFloat` method
  // https://tc39.es/ecma262/#sec-number.parseFloat
  // eslint-disable-next-line es/no-number-parsefloat -- required for testing
  _export({ target: 'Number', stat: true, forced: Number.parseFloat != numberParseFloat }, {
    parseFloat: numberParseFloat
  });

  // `Number.isNaN` method
  // https://tc39.es/ecma262/#sec-number.isnan
  _export({ target: 'Number', stat: true }, {
    isNaN: function isNaN(number) {
      // eslint-disable-next-line no-self-compare -- NaN check
      return number != number;
    }
  });

  /* eslint-disable no-console */
  /*
      1 - console.log
      2 - tooltips
      4 - text frames
  */

  var debug = {
    CONSOLE: 1 << 0,
    TOOLTIPS: 1 << 2,
    TEXT_FRAMES: 1 << 2,
    level: 0,
    log: log
  };
  function log() {
    if (debug.level & debug.CONSOLE) {
      var _console;
      (_console = console).log.apply(_console, arguments);
    }
  }

  var FAILS_ON_PRIMITIVES = fails(function () { objectKeys(1); });

  // `Object.keys` method
  // https://tc39.es/ecma262/#sec-object.keys
  _export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
    keys: function keys(it) {
      return objectKeys(toObject(it));
    }
  });

  /***
   * Asserts of primitive javascript types
   */

  /**
   * @param {string} string
   */
  function assertIsString(string) {
    if (typeof string !== 'string') debug.log('Value to convert is not a string.', string);
  }

  /**
   * @throws
   * @param {string} name
   * @param {Object} object
   * @param {Object.<string, string>} keyValues
   */
  function assertHasKeyValue(name, object, keyValues) {
    return;
    // if (typeof object !== 'object')
    //     logAndThrow(`"${name}" is not an object.`, object);

    // Object.entries(keyValues)
    //     .forEach(([key, expectedValue]) => {
    //         if (!object.hasOwnProperty(key))
    //             logAndThrow(`"${name}" required key "${key}" missing.`, object);

    //         const actualValue = object[key];
    //         if (actualValue !== expectedValue)
    //             logAndThrow(
    //                 `"${name}" required key "${key}" has incorrect value. ` +
    //                 `(expected: "${expectedValue}", actual: "${actualValue}")`,
    //                 object
    //             );
    //     });
  }

  /**
   * @param {string} string
   * @returns {number}
   */
  function asNumber(string) {
    assertIsString(string);
    var number = Number(string);
    return number;
  }

  /**
   * @param {string} string
   * @returns {number}
   */
  function asInteger(string) {
    assertIsString(string);
    var number = Number(string);
    return number;
  }

  /**
   * 
   * @param {string} string
   * @param {boolean} [triState] - whether can return null
   * @returns {boolean|null}
   */
  function asBooleanTristate(string) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$triState = _ref.triState,
      triState = _ref$triState === void 0 ? true : _ref$triState;
    if (triState && string === undefined) {
      debug.log('boolean as a null');
      return null;
    }
    return asBooleanStrict(string);
  }

  /**
   * @param {string} string
   * @returns {boolean}
   */
  function asBooleanStrict(string) {
    if (string !== '0' && string !== '1') debug.log('Can\'t convert string to boolean', string);
    return string === '1';
  }

  function stringToPixels(string, units) {
    return toPixels(asNumber(string), units);
  }
  function fromPixels(value) {
    var units = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : VisioUnitType.IN;
    if (value === undefined || !units) {
      debug.log('Value and target unit type are required to convert a pixel value.');
    }
    value = Number.parseFloat(value);
    if (Number.isNaN(value)) {
      debug.log('fromPixels requires a numeric value.');
    }
    switch (units) {
      case VisioUnitType.IN:
      case VisioUnitType.IN_F:
      case VisioUnitType.DL:
      case VisioUnitType.DP:
        return pixelsToInches(value);
      case VisioUnitType.DT:
      case VisioUnitType.PT:
        return pixelsToPoints(value);
      case VisioUnitType.MM:
        return pixelsToMillimeters(value);
      case VisioUnitType.CM:
        return pixelsToCentimeters(value);
      default:
        debug.log("Unsupported numeric unit type \"".concat(unitDisplayName(units), "\" (\"").concat(units, "\")"));
        return value;
    }
  }
  function toPixels(value) {
    var units = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : VisioUnitType.IN;
    if (value === undefined || !units) {
      debug.log('Value and target unit type are required to convert to a pixel value.');
    }

    // todo: support more units
    switch (units) {
      case VisioUnitType.IN:
      case VisioUnitType.IN_F:
      case VisioUnitType.DL:
      case VisioUnitType.DP:
        return inchesToPixels(value);
      case VisioUnitType.MM:
        return millimetersToPixel(value);
      case VisioUnitType.CM:
        return centimetersToPixel(value);
      case VisioUnitType.DT:
      case VisioUnitType.PT:
        // points are not pixels (1 pt = 1/72 inch)
        // todo: suspiciously low value
        // drawing1.vsdx 0.006944444444444444 Points
        // logAndThrow('investigate VisioUnitType.PT');
        return pointsToPixel(value);
      default:
        {
          debug.log("Unsupported numeric unit type \"".concat(unitDisplayName(units), "\" (\"").concat(units, "\")"));
          return value;
        }
    }
  }

  /**
   * @param {number} inches
   * @returns {number}
   */
  function inchesToPixels(inches) {
    return inches * 96;
  }

  /**
   * @param {number} millimeters
   * @returns {number}
   */
  function millimetersToPixel(millimeters) {
    return millimeters * 3.7795275591;
  }
  function pixelsToMillimeters(pixels) {
    return pixels / 3.7795275591;
  }

  /**
   * @param {number} centimeters
   * @returns {number}
   */
  function centimetersToPixel(centimeters) {
    var millimeters = centimeters * 10;
    return millimetersToPixel(millimeters);
  }
  function pixelsToCentimeters(pixels) {
    var millimeters = pixelsToMillimeters(pixels);
    return millimeters / 10;
  }

  /**
   * 1 pt = 1/72 inch
   * @param {number} points
   * @returns {number}
   */
  function pointsToPixel(points) {
    var inch = points / 72;
    return inchesToPixels(inch);
  }
  function pixelsToPoints(pixels) {
    var inch = pixelsToInches(pixels);
    return inch * 72;
  }

  /**
   * @param {number} inches
   * @returns {number}
   */
  function pixelsToInches(pixels) {
    return pixels / 96;
  }

  /**
   * @param stringValue - radians counterclockwise
   * @param {boolean} round
   * @param {VisioUnitType} units
   * @param {number} decimalPlaces
   * @returns {number} - degrees clockwise
   */
  function toDegrees(stringValue) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$round = _ref.round,
      round$1 = _ref$round === void 0 ? true : _ref$round,
      _ref$decimalPlaces = _ref.decimalPlaces,
      decimalPlaces = _ref$decimalPlaces === void 0 ? 2 : _ref$decimalPlaces,
      _ref$units = _ref.units,
      units = _ref$units === void 0 ? VisioUnitType.RAD : _ref$units;
    // in xml all values as a string
    var value = Number(stringValue);

    //TODO miky support more units
    if (units === VisioUnitType.RAD || units === VisioUnitType.DA) {
      // convert radians counterclockwise to degrees clockwise
      value = 360 - value * 180 / Math.PI;
    } else if (units === VisioUnitType.DEG) ; else if (units === VisioUnitType.AD && value === 0) ; else {
      debug.log("Implement unit type \"".concat(unitDisplayName(units), "\" (\"VisioUnitType.").concat(units, "\")"));
    }

    // normalize
    value = value % 360;

    // round to exact decimal places
    if (round$1) value = round(value, decimalPlaces);
    return value;
  }

  /**
   * @param {VisioUnitType} unitType
   */
  function unitDisplayName(unitType) {
    var _VisioUnitType$AC$Vis;
    if (!VisioUnitType.hasOwnProperty(unitType)) throw "Unknown unit type \"".concat(unitType, "\".");
    return (_VisioUnitType$AC$Vis = {}, _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.AC, 'Acres'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.DEG, 'Degrees'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.DA, 'Radians'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.AD, 'Degrees-minutes-seconds'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.RAD, 'Radians'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.BOOL, 'Boolean'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.COLOR, 'RGB color value'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.CY, 'Currency'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.DATE, 'Days'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.ED, 'Days'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.EH, 'Hours'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.EM, 'Minutes'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.ES, 'Seconds'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.EW, 'Weeks'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.HA, 'Hectare'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.CM, 'Centimeters'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.DL, 'Inches'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.FT, 'Feet'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.F_I, 'Feet and inches'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.IN, 'Inches'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.IN_F, 'Inches'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.KM, 'Kilometers'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.M, 'Meters'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.MI, 'Miles'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.MI_F, 'Miles'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.MM, 'Millimeters'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.NM, 'Nautical miles'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.PER, 'Percentage'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.YD, 'Yards'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.DP, 'Inches'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.PNT, 'Coordinates of a two-dimensional point'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.STR, 'String'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.DE, 'Days'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.C_D, 'Ciceros and didots'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.C, 'Ciceros'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.D, 'Didots'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.DT, 'Points'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.P, 'Picas'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.P_PT, 'Picas and points'), _defineProperty(_VisioUnitType$AC$Vis, VisioUnitType.PT, 'Points'), _VisioUnitType$AC$Vis)[unitType];
  }

  var sqrt = Math.sqrt,
    cos = Math.cos,
    sin = Math.sin,
    atan2 = Math.atan2,
    abs = Math.abs;
  var lastX = 0;
  var lastY = 0;
  var spline = null;
  function convertToSvg(rows, _ref) {
    var width = _ref.width,
      height = _ref.height;
    var dimensions = {
      width: width,
      height: height
    };
    var resultString = '';
    lastX = lastY = 0;
    spline = null;
    rows.forEach(function (_ref2, index, dataset) {
      var name = _ref2.name,
        cells = _ref2.cells;
      if (index === 0 && name !== VisioRowType.MoveTo) {
        // The first command of an SVG path has to be `M`
        resultString += getMoveTo({
          x: 0,
          y: 0
        });
      }
      if (spline) {
        var _spline = spline,
          points = _spline.points,
          knots = _spline.knots,
          degree = _spline.degree;
        if (dataset.length === index + 1) {
          // Last Row
          convertRowToSVG(name, cells, dimensions);
          resultString += getSpline(points, knots, degree);
          return;
        } else if (name !== VisioRowType.SplineKnot) {
          // Last Knot
          resultString += getSpline(points, knots, degree);
          spline = null;
        }
      }
      resultString += convertRowToSVG(name, cells, dimensions);
    });
    return resultString;
  }
  function convertRowToSVG(name, cells, dimensions) {
    // Note: A geometry section that contains an Ellipse or InfiniteLine row should not contain any other rows.
    switch (name) {
      // Absolute
      case VisioRowType.MoveTo:
        return getMoveTo(cells);
      case VisioRowType.LineTo:
        return getLineTo(cells);
      case VisioRowType.ArcTo:
        return getArcTo(cells);
      case VisioRowType.EllipticalArcTo:
        return getEllipticalArcTo(cells);
      case VisioRowType.Ellipse:
        return getEllipse(cells);
      case VisioRowType.InfiniteLine:
        return getInfiniteLine(cells);
      case VisioRowType.SplineStart:
        getSplineStart(cells);
        break;
      case VisioRowType.SplineKnot:
        getSplineKnot(cells);
        break;
      // Relative
      case VisioRowType.RelMoveTo:
        return getRelMoveTo(cells, dimensions);
      case VisioRowType.RelLineTo:
        return getRelLineTo(cells, dimensions);
      case VisioRowType.RelCubBezTo:
        return getRelCubBezTo(cells, dimensions);
      case VisioRowType.RelQuadBezTo:
        return getRelQuadBezTo(cells, dimensions);
      case VisioRowType.RelEllipticalArcTo:
        return getRelEllipticalArcTo(cells, dimensions);
      case VisioRowType.PolylineTo:
        return getPolylineTo(cells, dimensions);
      case VisioRowType.NURBSTo:
        return getNURBSTo(cells, dimensions);
    }
    return '';
  }

  // Relative Commands

  function getRelQuadBezTo(cells, dimensions) {
    var width = dimensions.width,
      height = dimensions.height;
    var x = cells.x * width;
    var y = cells.y * height;
    var x1 = cells.a * width;
    var y1 = cells.b * height;
    lastX = x;
    lastY = y;
    return " Q ".concat(round(x1), " ").concat(round(y1), " ").concat(round(x), " ").concat(round(y));
  }
  function getRelCubBezTo(cells, dimensions) {
    var width = dimensions.width,
      height = dimensions.height;
    var x = cells.x * width;
    var y = cells.y * height;
    var cpx1 = cells.a * width;
    var cpy1 = cells.b * height;
    var cpx2 = cells.c * width;
    var cpy2 = cells.d * height;
    lastX = x;
    lastY = y;
    return " C ".concat(round(cpx1), " ").concat(round(cpy1), " ").concat(round(cpx2), " ").concat(round(cpy2), " ").concat(round(x), " ").concat(round(y));
  }
  function getRelMoveTo(cells, dimensions) {
    var width = dimensions.width,
      height = dimensions.height;
    var _cells$x = cells.x,
      x = _cells$x === void 0 ? lastX : _cells$x,
      _cells$y = cells.y,
      y = _cells$y === void 0 ? lastY : _cells$y;
    x = x * width;
    y = y * height;
    lastX = x;
    lastY = y;
    return " M ".concat(round(x), " ").concat(round(y));
  }
  function getRelLineTo(cells, dimensions) {
    var width = dimensions.width,
      height = dimensions.height;
    var _cells$x2 = cells.x,
      x = _cells$x2 === void 0 ? lastX : _cells$x2,
      _cells$y2 = cells.y,
      y = _cells$y2 === void 0 ? lastY : _cells$y2;
    x = x * width;
    y = y * height;
    lastX = x;
    lastY = y;
    return " L ".concat(round(x), " ").concat(round(y));
  }
  function getEllipse(cells) {
    var cx = cells.x;
    var cy = cells.y;
    var a = cells.a;
    var b = cells.b;
    var c = cells.c;
    var d = cells.d;
    var dx1 = abs(a - cx);
    var dy1 = abs(b - cy);
    var rx = sqrt(dx1 * dx1 + dy1 * dy1);
    var dx2 = abs(c - cx);
    var dy2 = abs(d - cy);
    var ry = sqrt(dx2 * dx2 + dy2 * dy2);
    return " M ".concat(cx - rx, " ").concat(cy, " A ").concat(rx, " ").concat(ry, " 0 1 0 ").concat(cx + rx, " ").concat(cy, " A ").concat(rx, " ").concat(ry, " 0 1 0 ").concat(cx - rx, " ").concat(cy);
  }

  // Absolute Commands

  function getMoveTo(cells) {
    var _cells$x3 = cells.x,
      x = _cells$x3 === void 0 ? lastX : _cells$x3,
      _cells$y3 = cells.y,
      y = _cells$y3 === void 0 ? lastY : _cells$y3;
    lastX = x;
    lastY = y;
    return " M ".concat(round(x), " ").concat(round(y));
  }
  function getLineTo(cells) {
    var _cells$x4 = cells.x,
      x = _cells$x4 === void 0 ? lastX : _cells$x4,
      _cells$y4 = cells.y,
      y = _cells$y4 === void 0 ? lastY : _cells$y4;
    lastX = x;
    lastY = y;
    return " L ".concat(round(x), " ").concat(round(y));
  }
  function getInfiniteLine(cells) {
    var x = cells.x,
      y = cells.y,
      x2 = cells.a,
      y2 = cells.b;
    return " L ".concat(x, " ").concat(y, " ").concat(x2, " ").concat(y2);
  }
  function getArcTo(cells) {
    var x = cells.x,
      y = cells.y,
      a = cells.a;
    if (a === 0) {
      return " L ".concat(x, " ").concat(y);
    }
    var x0 = lastX;
    var y0 = lastY;
    var dx = abs(x - x0);
    var dy = abs(y - y0);
    var rx = abs(round(a * 0.5 + (dx * dx + dy * dy) / (8.0 * a), 2));
    var ry = rx;
    var r0 = abs(rx);
    x = round(x, 2);
    y = round(y, 2);
    a = round(a, 2);
    var sf = a > 0 ? 1 : 0;
    var laf = r0 < abs(a) ? 1 : 0;
    lastX = x;
    lastY = y;
    // A rx ry x-axis-rotation large-arc-flag sweep-flag x y
    return " A ".concat(rx, " ").concat(ry, " 0 ").concat(laf, " ").concat(sf, " ").concat(x, " ").concat(y);
  }
  function getEllipticalArcTo(cells) {
    var _cells$x5 = cells.x,
      x = _cells$x5 === void 0 ? lastX : _cells$x5,
      _cells$y5 = cells.y,
      y = _cells$y5 === void 0 ? lastY : _cells$y5,
      _cells$a = cells.a,
      x3 = _cells$a === void 0 ? 0 : _cells$a,
      _cells$b = cells.b,
      y3 = _cells$b === void 0 ? 0 : _cells$b,
      _cells$c = cells.c,
      c = _cells$c === void 0 ? 0 : _cells$c,
      _cells$d = cells.d,
      d = _cells$d === void 0 ? 0 : _cells$d;
    var x1 = lastX;
    var y1 = lastY;
    var x2 = x;
    var y2 = y;
    var rotation = -c;
    lastX = x;
    lastY = y;
    var rad = jointjs.g.toRad(rotation);
    var p1x = sqrt(x1 * x1 + y1 * y1) * cos(atan2(y1, x1) - rad);
    var p1y = sqrt(x1 * x1 + y1 * y1) * sin(atan2(y1, x1) - rad);
    var p2x = sqrt(x2 * x2 + y2 * y2) * cos(atan2(y2, x2) - rad);
    var p2y = sqrt(x2 * x2 + y2 * y2) * sin(atan2(y2, x2) - rad);
    var p3x = sqrt(x3 * x3 + y3 * y3) * cos(atan2(y3, x3) - rad);
    var p3y = sqrt(x3 * x3 + y3 * y3) * sin(atan2(y3, x3) - rad);
    var p0xDenominator = (p1x - p2x) * (p2y - p3y) - (p2x - p3x) * (p1y - p2y);
    var p0yDenominator = (p2x - p3x) * (p1y - p2y) - (p1x - p2x) * (p2y - p3y);
    if (p0yDenominator === 0 || p0yDenominator === 0) {
      return " L ".concat(x2, " ").concat(y2);
    }
    var p0xNumerator = (p1x - p2x) * (p1x + p2x) * (p2y - p3y) - (p2x - p3x) * (p2x + p3x) * (p1y - p2y) + d * d * (p1y - p2y) * (p2y - p3y) * (p1y - p3y);
    var p0x = p0xNumerator / (2 * p0xDenominator);
    var p0yNumerator = (p1x - p2x) * (p2x - p3x) * (p1x - p3x) / (d * d) + (p2x - p3x) * (p1y - p2y) * (p1y + p2y) - (p1x - p2x) * (p2y - p3y) * (p2y + p3y);
    var p0y = p0yNumerator / (2 * p0yDenominator);
    var dx = p1x - p0x;
    var dy = p1y - p0y;
    var rx = sqrt(dx * dx + dy * dy * d * d);
    var ry = rx / d;
    var sweep = (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1);
    var sf = sweep > 0 ? 0 : 1;
    var laf = 0;
    if (isInsideTriangle(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) && isReflexAngle(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y)) {
      laf = 1;
    }
    return " A ".concat(round(rx, 2), " ").concat(round(ry, 2), " ").concat(rotation, " ").concat(laf, " ").concat(sf, " ").concat(round(x, 2), " ").concat(round(y, 2));
  }
  function getRelEllipticalArcTo(cells, dimensions) {
    // A RelEllipticalArcTo row can only be persisted in the .vsdx, .vsdm, .vstx, .vstm, .vssx, and .vssm file formats.
    // When a file is saved to the Visio 2003-2010 formats, the RelEllipticalArcTo row is converted to an EllipticalArcTo row.
    var width = dimensions.width,
      height = dimensions.height;
    var x = cells.x,
      y = cells.y,
      a = cells.a,
      b = cells.b,
      c = cells.c,
      d = cells.d;
    return getEllipticalArcTo({
      // X: The x-coordinate of the ending vertex on an arc relative to the width of the shape.
      x: x * width,
      // Y: The y-coordinate of the ending vertex on an arc relative to the height of the shape.
      y: y * height,
      // A: The x-coordinate of the arc's control point relative to the shape's width; a point on the arc.
      // The control point is best located about halfway between the beginning and ending vertices of the arc.
      // Otherwise, the arc may grow to an extreme size in order to pass through the control point, with unpredictable results.
      a: a * width,
      // B: The y-coordinate of an arc's control point relative to the shape's width.
      b: b * width,
      // C: The angle of an arc's major axis relative to the x -axis of its parent.
      c: c,
      // D: The ratio of an arc's major axis to its minor axis. Despite the usual meaning of these words,
      // the "major" axis does not have to be greater than the "minor" axis, so this ratio does not have to be greater than 1.
      // Setting this cell to a value less than or equal to 0 or greater than 1000 can lead to unpredictable results.
      d: d
    });
  }
  function getSpline(points, knots, degree) {
    return " L ".concat(getBSplinePoints(degree, points, knots).join(' '));
  }
  function getSplineStart(cells) {
    var _cells$x6 = cells.x,
      x = _cells$x6 === void 0 ? lastX : _cells$x6,
      _cells$y6 = cells.y,
      y = _cells$y6 === void 0 ? lastY : _cells$y6;
    x = round(x, 2);
    y = round(y, 2);
    spline = {
      points: [[lastX, lastY], [x, y]],
      knots: [cells.b, cells.a, cells.c],
      degree: cells.d
    };
    lastX = x;
    lastY = y;
  }
  function getSplineKnot(cells) {
    var _cells$x7 = cells.x,
      x = _cells$x7 === void 0 ? lastX : _cells$x7,
      _cells$y7 = cells.y,
      y = _cells$y7 === void 0 ? lastY : _cells$y7,
      a = cells.a;
    lastX = x = round(x, 2);
    lastY = y = round(y, 2);
    if (spline) {
      var _spline2 = spline,
        points = _spline2.points,
        knots = _spline2.knots;
      points.push([x, y]);
      knots.splice(knots.length - 1, 0, a);
    }
  }
  function getNURBSTo(cells, dimensions) {
    var x = cells.x,
      y = cells.y,
      secondLastKnot = cells.a,
      lastWeight = cells.b,
      firstKnot = cells.c,
      firstWeight = cells.d,
      formula = cells.e;
    var width = dimensions.width,
      height = dimensions.height;
    var points = [[lastX, lastY]];
    var knots = [firstKnot];
    var weights = [firstWeight];
    // NURBS(** knotLast **, ** degree **, ** xType **, ** yType **, ** x1 **, ** y1 **, ** knot1 **, ** weight1 **, ...)
    var _parseFormula = parseFormula(formula),
      _parseFormula2 = _toArray(_parseFormula),
      lastKnot = _parseFormula2[0],
      degree = _parseFormula2[1],
      xType = _parseFormula2[2],
      yType = _parseFormula2[3],
      values = _parseFormula2.slice(4);
    var xn, yn, knot, weight;
    while (values.length > 0) {
      var _values = values;
      var _values2 = _toArray(_values);
      xn = _values2[0];
      yn = _values2[1];
      knot = _values2[2];
      weight = _values2[3];
      values = _values2.slice(4);
      // xType: Specifies how to interpret the x input data.
      // If xType is 0, all x input data is interpreted as a percentage of Width.
      // If xType is 1, all x input data is interpreted as local coordinates.
      if (xType === 0) {
        xn *= width;
      } else {
        xn = inchesToPixels(xn);
      }
      // yType: Specifies how to interpret the y input data.
      // If yType is 0, all y input data is interpreted as a percentage of Height.
      // If yType is 1, all y input data is interpreted as local coordinates.
      if (yType === 0) {
        yn *= height;
      } else {
        yn = inchesToPixels(yn);
      }
      points.push([xn, yn]);
      knots.push(knot);
      weights.push(weight);
    }
    knots.push(secondLastKnot, lastKnot);
    points.push([x, y]);
    weights.push(lastWeight);
    lastX = x;
    lastY = y;
    var nurbs = getBSplinePoints(degree, points, knots, weights).join(' ');
    if (nurbs.length === 0) return '';
    return " L ".concat(nurbs);
  }
  function getPolylineTo(cells, dimensions) {
    var x = cells.x,
      y = cells.y,
      formula = cells.a;
    var width = dimensions.width,
      height = dimensions.height;
    var _parseFormula3 = parseFormula(formula),
      _parseFormula4 = _toArray(_parseFormula3),
      xType = _parseFormula4[0],
      yType = _parseFormula4[1],
      values = _parseFormula4.slice(2);
    var points = values.map(function (value, index) {
      var coordinate;
      if (index % 2 === 0) {
        // xType: Specifies how to interpret the x input data.
        // If xType is 0, all x input data is interpreted as a percentage of Width.
        // If xType is 1, all x input data is interpreted as local coordinates.
        if (xType === 0) {
          coordinate = value * width;
        } else {
          coordinate = inchesToPixels(value);
        }
      } else {
        // yType: Specifies how to interpret the y input data.
        // If yType is 0, all y input data is interpreted as a percentage of Height.
        // If yType is 1, all y input data is interpreted as local coordinates.
        if (yType === 0) {
          coordinate = value * height;
        } else {
          coordinate = inchesToPixels(value);
        }
      }
      return round(coordinate, 2);
    });
    points.push(x, y);
    lastX = x;
    lastY = y;
    return "L ".concat(points.join(' '));
  }

  // Helpers

  function parseFormula(formula) {
    return formula.replace(/[A-Z]|\(|\)/g, '').split(/\s*,\s*/).map(function (x) {
      return Number(x);
    });
  }
  function isInsideTriangle(x, y, ax, ay, bx, by, cx, cy) {
    bx = bx - ax;
    by = by - ay;
    cx = cx - ax;
    cy = cy - ay;
    var d = bx * cy - cx * by;
    var wa = (x * (by - cy) + y * (cx - bx) + bx * cy - cx * by) / d;
    var wb = (x * cy - y * cx) / d;
    var wc = (y * bx - x * by) / d;
    if (wa > 0 && wa < 1 && wb > 0 && wb < 1 && wc > 0 && wc < 1) {
      return true;
    }
    return false;
  }
  function isReflexAngle(x0, y0, x1, y1, x2, y2, x3, y3) {
    x1 = x1 - x0;
    y1 = y1 - y0;
    y2 = y2 - y0;
    x2 = x3 - x0;
    y3 = y3 - y0;
    x0 = 0;
    y0 = 0;
    var aStart = jointjs.g.toDeg(atan2(y1, x1) - atan2(y0, x0));
    var aEnd = jointjs.g.toDeg(atan2(y2, x2) - atan2(y0, x0));
    var aCP = jointjs.g.toDeg(atan2(y3, x3) - atan2(y0, x0));
    aStart = jointjs.g.normalizeAngle(aStart - aCP);
    aEnd = jointjs.g.normalizeAngle(aEnd - aCP);
    if (aStart > 0 && aEnd < 0 || aStart < 0 && aEnd > 0) {
      if (abs(aStart - aEnd) > 180) return true;
    }
    return false;
  }

  // `Array.isArray` method
  // https://tc39.es/ecma262/#sec-array.isarray
  _export({ target: 'Array', stat: true }, {
    isArray: isArray
  });

  /**
   * @param {*|Array.<*>} somethingOrArray
   * @returns {Array.<*>}
   */
  function toArray(somethingOrArray) {
    if (Array.isArray(somethingOrArray)) return somethingOrArray;
    return [somethingOrArray];
  }

  /**
   *
   * @param {VisioItem|Array.<VisioItem>} geometryItemOrArray
   * @param {number} width
   * @param {number} height
   * @returns {*}
   */
  function geometrySingleShapeArrayToPath(geometryItemOrArray, _ref) {
    var width = _ref.width,
      height = _ref.height;
    /** @type {Array.<VisioItem>} */
    var geometryItemArray = toArray(geometryItemOrArray);
    return geometryItemArray.map(function (geometryItem) {
      return geometryItemToPath(geometryItem, {
        width: width,
        height: height
      });
    }).join(' ');
  }

  /**
   * Single shape (part of final shape)
   * @param geometryItem
   * @param {number} width
   * @param {number} height
   * @returns {string}
   */
  function geometryItemToPath(geometryItem, _ref2) {
    var width = _ref2.width,
      height = _ref2.height;
    var rows = geometryItem.rows;

    // shape parts together
    var oldWayDataset = rows.map(function (row) {
      return {
        name: row.type,
        cells: row.cells
      };
    });
    return convertToSvg(oldWayDataset, {
      width: width,
      height: height
    });
  }

  // eslint-disable-next-line es/no-object-assign -- safe
  var $assign = Object.assign;
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  var defineProperty$4 = Object.defineProperty;
  var concat$2 = functionUncurryThis([].concat);

  // `Object.assign` method
  // https://tc39.es/ecma262/#sec-object.assign
  var objectAssign = !$assign || fails(function () {
    // should have correct order of operations (Edge bug)
    if (descriptors && $assign({ b: 1 }, $assign(defineProperty$4({}, 'a', {
      enumerable: true,
      get: function () {
        defineProperty$4(this, 'b', {
          value: 3,
          enumerable: false
        });
      }
    }), { b: 2 })).b !== 1) return true;
    // should work with symbols and should have deterministic property order (V8 bug)
    var A = {};
    var B = {};
    // eslint-disable-next-line es/no-symbol -- safe
    var symbol = Symbol();
    var alphabet = 'abcdefghijklmnopqrst';
    A[symbol] = 7;
    alphabet.split('').forEach(function (chr) { B[chr] = chr; });
    return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join('') != alphabet;
  }) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`
    var T = toObject(target);
    var argumentsLength = arguments.length;
    var index = 1;
    var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
    var propertyIsEnumerable = objectPropertyIsEnumerable.f;
    while (argumentsLength > index) {
      var S = indexedObject(arguments[index++]);
      var keys = getOwnPropertySymbols ? concat$2(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);
      var length = keys.length;
      var j = 0;
      var key;
      while (length > j) {
        key = keys[j++];
        if (!descriptors || functionCall(propertyIsEnumerable, S, key)) T[key] = S[key];
      }
    } return T;
  } : $assign;

  // `Object.assign` method
  // https://tc39.es/ecma262/#sec-object.assign
  // eslint-disable-next-line es/no-object-assign -- required for testing
  _export({ target: 'Object', stat: true, arity: 2, forced: Object.assign !== objectAssign }, {
    assign: objectAssign
  });

  var iterators = {};

  var correctPrototypeGetter = !fails(function () {
    function F() { /* empty */ }
    F.prototype.constructor = null;
    // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
    return Object.getPrototypeOf(new F()) !== F.prototype;
  });

  var IE_PROTO$1 = sharedKey('IE_PROTO');
  var $Object$4 = Object;
  var ObjectPrototype = $Object$4.prototype;

  // `Object.getPrototypeOf` method
  // https://tc39.es/ecma262/#sec-object.getprototypeof
  // eslint-disable-next-line es/no-object-getprototypeof -- safe
  var objectGetPrototypeOf = correctPrototypeGetter ? $Object$4.getPrototypeOf : function (O) {
    var object = toObject(O);
    if (hasOwnProperty_1(object, IE_PROTO$1)) return object[IE_PROTO$1];
    var constructor = object.constructor;
    if (isCallable(constructor) && object instanceof constructor) {
      return constructor.prototype;
    } return object instanceof $Object$4 ? ObjectPrototype : null;
  };

  var ITERATOR$1 = wellKnownSymbol('iterator');
  var BUGGY_SAFARI_ITERATORS = false;

  // `%IteratorPrototype%` object
  // https://tc39.es/ecma262/#sec-%iteratorprototype%-object
  var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

  /* eslint-disable es/no-array-prototype-keys -- safe */
  if ([].keys) {
    arrayIterator = [].keys();
    // Safari 8 has buggy iterators w/o `next`
    if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
    else {
      PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
      if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
    }
  }

  var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function () {
    var test = {};
    // FF44- legacy iterators case
    return IteratorPrototype[ITERATOR$1].call(test) !== test;
  });

  if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};

  // `%IteratorPrototype%[@@iterator]()` method
  // https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
  if (!isCallable(IteratorPrototype[ITERATOR$1])) {
    defineBuiltIn(IteratorPrototype, ITERATOR$1, function () {
      return this;
    });
  }

  var iteratorsCore = {
    IteratorPrototype: IteratorPrototype,
    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
  };

  var defineProperty$5 = objectDefineProperty.f;



  var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');

  var setToStringTag = function (target, TAG, STATIC) {
    if (target && !STATIC) target = target.prototype;
    if (target && !hasOwnProperty_1(target, TO_STRING_TAG$2)) {
      defineProperty$5(target, TO_STRING_TAG$2, { configurable: true, value: TAG });
    }
  };

  var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;





  var returnThis = function () { return this; };

  var iteratorCreateConstructor = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
    var TO_STRING_TAG = NAME + ' Iterator';
    IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
    setToStringTag(IteratorConstructor, TO_STRING_TAG, false);
    iterators[TO_STRING_TAG] = returnThis;
    return IteratorConstructor;
  };

  var PROPER_FUNCTION_NAME$1 = functionName.PROPER;
  var CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;
  var IteratorPrototype$2 = iteratorsCore.IteratorPrototype;
  var BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;
  var ITERATOR$2 = wellKnownSymbol('iterator');
  var KEYS = 'keys';
  var VALUES = 'values';
  var ENTRIES = 'entries';

  var returnThis$1 = function () { return this; };

  var iteratorDefine = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
    iteratorCreateConstructor(IteratorConstructor, NAME, next);

    var getIterationMethod = function (KIND) {
      if (KIND === DEFAULT && defaultIterator) return defaultIterator;
      if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) return IterablePrototype[KIND];
      switch (KIND) {
        case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
        case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
        case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
      } return function () { return new IteratorConstructor(this); };
    };

    var TO_STRING_TAG = NAME + ' Iterator';
    var INCORRECT_VALUES_NAME = false;
    var IterablePrototype = Iterable.prototype;
    var nativeIterator = IterablePrototype[ITERATOR$2]
      || IterablePrototype['@@iterator']
      || DEFAULT && IterablePrototype[DEFAULT];
    var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);
    var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
    var CurrentIteratorPrototype, methods, KEY;

    // fix native
    if (anyNativeIterator) {
      CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));
      if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
        if ( objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype$2) {
          if (objectSetPrototypeOf) {
            objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype$2);
          } else if (!isCallable(CurrentIteratorPrototype[ITERATOR$2])) {
            defineBuiltIn(CurrentIteratorPrototype, ITERATOR$2, returnThis$1);
          }
        }
        // Set @@toStringTag to native iterators
        setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);
      }
    }

    // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
    if (PROPER_FUNCTION_NAME$1 && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
      if ( CONFIGURABLE_FUNCTION_NAME) {
        createNonEnumerableProperty(IterablePrototype, 'name', VALUES);
      } else {
        INCORRECT_VALUES_NAME = true;
        defaultIterator = function values() { return functionCall(nativeIterator, this); };
      }
    }

    // export additional methods
    if (DEFAULT) {
      methods = {
        values: getIterationMethod(VALUES),
        keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
        entries: getIterationMethod(ENTRIES)
      };
      if (FORCED) for (KEY in methods) {
        if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
          defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
        }
      } else _export({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME }, methods);
    }

    // define iterator
    if ( IterablePrototype[ITERATOR$2] !== defaultIterator) {
      defineBuiltIn(IterablePrototype, ITERATOR$2, defaultIterator, { name: DEFAULT });
    }
    iterators[NAME] = defaultIterator;

    return methods;
  };

  // `CreateIterResultObject` abstract operation
  // https://tc39.es/ecma262/#sec-createiterresultobject
  var createIterResultObject = function (value, done) {
    return { value: value, done: done };
  };

  var defineProperty$6 = objectDefineProperty.f;





  var ARRAY_ITERATOR = 'Array Iterator';
  var setInternalState = internalState.set;
  var getInternalState$1 = internalState.getterFor(ARRAY_ITERATOR);

  // `Array.prototype.entries` method
  // https://tc39.es/ecma262/#sec-array.prototype.entries
  // `Array.prototype.keys` method
  // https://tc39.es/ecma262/#sec-array.prototype.keys
  // `Array.prototype.values` method
  // https://tc39.es/ecma262/#sec-array.prototype.values
  // `Array.prototype[@@iterator]` method
  // https://tc39.es/ecma262/#sec-array.prototype-@@iterator
  // `CreateArrayIterator` internal method
  // https://tc39.es/ecma262/#sec-createarrayiterator
  var es_array_iterator = iteratorDefine(Array, 'Array', function (iterated, kind) {
    setInternalState(this, {
      type: ARRAY_ITERATOR,
      target: toIndexedObject(iterated), // target
      index: 0,                          // next index
      kind: kind                         // kind
    });
  // `%ArrayIteratorPrototype%.next` method
  // https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
  }, function () {
    var state = getInternalState$1(this);
    var target = state.target;
    var kind = state.kind;
    var index = state.index++;
    if (!target || index >= target.length) {
      state.target = undefined;
      return createIterResultObject(undefined, true);
    }
    if (kind == 'keys') return createIterResultObject(index, false);
    if (kind == 'values') return createIterResultObject(target[index], false);
    return createIterResultObject([index, target[index]], false);
  }, 'values');

  // argumentsList[@@iterator] is %ArrayProto_values%
  // https://tc39.es/ecma262/#sec-createunmappedargumentsobject
  // https://tc39.es/ecma262/#sec-createmappedargumentsobject
  var values = iterators.Arguments = iterators.Array;

  // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
  addToUnscopables('keys');
  addToUnscopables('values');
  addToUnscopables('entries');

  // V8 ~ Chrome 45- bug
  if ( descriptors && values.name !== 'values') try {
    defineProperty$6(values, 'name', { value: 'values' });
  } catch (error) { /* empty */ }

  /* eslint-disable es/no-object-getownpropertynames -- safe */


  var $getOwnPropertyNames = objectGetOwnPropertyNames.f;


  var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
    ? Object.getOwnPropertyNames(window) : [];

  var getWindowNames = function (it) {
    try {
      return $getOwnPropertyNames(it);
    } catch (error) {
      return arraySliceSimple(windowNames);
    }
  };

  // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
  var f$6 = function getOwnPropertyNames(it) {
    return windowNames && classofRaw(it) == 'Window'
      ? getWindowNames(it)
      : $getOwnPropertyNames(toIndexedObject(it));
  };

  var objectGetOwnPropertyNamesExternal = {
  	f: f$6
  };

  // FF26- bug: ArrayBuffers are non-extensible, but Object.isExtensible does not report it


  var arrayBufferNonExtensible = fails(function () {
    if (typeof ArrayBuffer == 'function') {
      var buffer = new ArrayBuffer(8);
      // eslint-disable-next-line es/no-object-isextensible, es/no-object-defineproperty -- safe
      if (Object.isExtensible(buffer)) Object.defineProperty(buffer, 'a', { value: 8 });
    }
  });

  // eslint-disable-next-line es/no-object-isextensible -- safe
  var $isExtensible = Object.isExtensible;
  var FAILS_ON_PRIMITIVES$1 = fails(function () { $isExtensible(1); });

  // `Object.isExtensible` method
  // https://tc39.es/ecma262/#sec-object.isextensible
  var objectIsExtensible = (FAILS_ON_PRIMITIVES$1 || arrayBufferNonExtensible) ? function isExtensible(it) {
    if (!isObject(it)) return false;
    if (arrayBufferNonExtensible && classofRaw(it) == 'ArrayBuffer') return false;
    return $isExtensible ? $isExtensible(it) : true;
  } : $isExtensible;

  var freezing = !fails(function () {
    // eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing
    return Object.isExtensible(Object.preventExtensions({}));
  });

  var internalMetadata = createCommonjsModule(function (module) {
  var defineProperty = objectDefineProperty.f;






  var REQUIRED = false;
  var METADATA = uid('meta');
  var id = 0;

  var setMetadata = function (it) {
    defineProperty(it, METADATA, { value: {
      objectID: 'O' + id++, // object ID
      weakData: {}          // weak collections IDs
    } });
  };

  var fastKey = function (it, create) {
    // return a primitive with prefix
    if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
    if (!hasOwnProperty_1(it, METADATA)) {
      // can't set metadata to uncaught frozen object
      if (!objectIsExtensible(it)) return 'F';
      // not necessary to add metadata
      if (!create) return 'E';
      // add missing metadata
      setMetadata(it);
    // return object ID
    } return it[METADATA].objectID;
  };

  var getWeakData = function (it, create) {
    if (!hasOwnProperty_1(it, METADATA)) {
      // can't set metadata to uncaught frozen object
      if (!objectIsExtensible(it)) return true;
      // not necessary to add metadata
      if (!create) return false;
      // add missing metadata
      setMetadata(it);
    // return the store of weak collections IDs
    } return it[METADATA].weakData;
  };

  // add metadata on freeze-family methods calling
  var onFreeze = function (it) {
    if (freezing && REQUIRED && objectIsExtensible(it) && !hasOwnProperty_1(it, METADATA)) setMetadata(it);
    return it;
  };

  var enable = function () {
    meta.enable = function () { /* empty */ };
    REQUIRED = true;
    var getOwnPropertyNames = objectGetOwnPropertyNames.f;
    var splice = functionUncurryThis([].splice);
    var test = {};
    test[METADATA] = 1;

    // prevent exposing of metadata key
    if (getOwnPropertyNames(test).length) {
      objectGetOwnPropertyNames.f = function (it) {
        var result = getOwnPropertyNames(it);
        for (var i = 0, length = result.length; i < length; i++) {
          if (result[i] === METADATA) {
            splice(result, i, 1);
            break;
          }
        } return result;
      };

      _export({ target: 'Object', stat: true, forced: true }, {
        getOwnPropertyNames: objectGetOwnPropertyNamesExternal.f
      });
    }
  };

  var meta = module.exports = {
    enable: enable,
    fastKey: fastKey,
    getWeakData: getWeakData,
    onFreeze: onFreeze
  };

  hiddenKeys[METADATA] = true;
  });
  var internalMetadata_1 = internalMetadata.enable;
  var internalMetadata_2 = internalMetadata.fastKey;
  var internalMetadata_3 = internalMetadata.getWeakData;
  var internalMetadata_4 = internalMetadata.onFreeze;

  var ITERATOR$3 = wellKnownSymbol('iterator');
  var ArrayPrototype$1 = Array.prototype;

  // check on default Array iterator
  var isArrayIteratorMethod = function (it) {
    return it !== undefined && (iterators.Array === it || ArrayPrototype$1[ITERATOR$3] === it);
  };

  var ITERATOR$4 = wellKnownSymbol('iterator');

  var getIteratorMethod = function (it) {
    if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR$4)
      || getMethod(it, '@@iterator')
      || iterators[classof(it)];
  };

  var $TypeError$d = TypeError;

  var getIterator = function (argument, usingIterator) {
    var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
    if (aCallable(iteratorMethod)) return anObject(functionCall(iteratorMethod, argument));
    throw $TypeError$d(tryToString(argument) + ' is not iterable');
  };

  var iteratorClose = function (iterator, kind, value) {
    var innerResult, innerError;
    anObject(iterator);
    try {
      innerResult = getMethod(iterator, 'return');
      if (!innerResult) {
        if (kind === 'throw') throw value;
        return value;
      }
      innerResult = functionCall(innerResult, iterator);
    } catch (error) {
      innerError = true;
      innerResult = error;
    }
    if (kind === 'throw') throw value;
    if (innerError) throw innerResult;
    anObject(innerResult);
    return value;
  };

  var $TypeError$e = TypeError;

  var Result = function (stopped, result) {
    this.stopped = stopped;
    this.result = result;
  };

  var ResultPrototype = Result.prototype;

  var iterate = function (iterable, unboundFunction, options) {
    var that = options && options.that;
    var AS_ENTRIES = !!(options && options.AS_ENTRIES);
    var IS_RECORD = !!(options && options.IS_RECORD);
    var IS_ITERATOR = !!(options && options.IS_ITERATOR);
    var INTERRUPTED = !!(options && options.INTERRUPTED);
    var fn = functionBindContext(unboundFunction, that);
    var iterator, iterFn, index, length, result, next, step;

    var stop = function (condition) {
      if (iterator) iteratorClose(iterator, 'normal', condition);
      return new Result(true, condition);
    };

    var callFn = function (value) {
      if (AS_ENTRIES) {
        anObject(value);
        return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
      } return INTERRUPTED ? fn(value, stop) : fn(value);
    };

    if (IS_RECORD) {
      iterator = iterable.iterator;
    } else if (IS_ITERATOR) {
      iterator = iterable;
    } else {
      iterFn = getIteratorMethod(iterable);
      if (!iterFn) throw $TypeError$e(tryToString(iterable) + ' is not iterable');
      // optimisation for array iterators
      if (isArrayIteratorMethod(iterFn)) {
        for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
          result = callFn(iterable[index]);
          if (result && objectIsPrototypeOf(ResultPrototype, result)) return result;
        } return new Result(false);
      }
      iterator = getIterator(iterable, iterFn);
    }

    next = IS_RECORD ? iterable.next : iterator.next;
    while (!(step = functionCall(next, iterator)).done) {
      try {
        result = callFn(step.value);
      } catch (error) {
        iteratorClose(iterator, 'throw', error);
      }
      if (typeof result == 'object' && result && objectIsPrototypeOf(ResultPrototype, result)) return result;
    } return new Result(false);
  };

  var $TypeError$f = TypeError;

  var anInstance = function (it, Prototype) {
    if (objectIsPrototypeOf(Prototype, it)) return it;
    throw $TypeError$f('Incorrect invocation');
  };

  var ITERATOR$5 = wellKnownSymbol('iterator');
  var SAFE_CLOSING = false;

  try {
    var called = 0;
    var iteratorWithReturn = {
      next: function () {
        return { done: !!called++ };
      },
      'return': function () {
        SAFE_CLOSING = true;
      }
    };
    iteratorWithReturn[ITERATOR$5] = function () {
      return this;
    };
    // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
    Array.from(iteratorWithReturn, function () { throw 2; });
  } catch (error) { /* empty */ }

  var checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {
    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
    var ITERATION_SUPPORT = false;
    try {
      var object = {};
      object[ITERATOR$5] = function () {
        return {
          next: function () {
            return { done: ITERATION_SUPPORT = true };
          }
        };
      };
      exec(object);
    } catch (error) { /* empty */ }
    return ITERATION_SUPPORT;
  };

  var collection = function (CONSTRUCTOR_NAME, wrapper, common) {
    var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
    var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
    var ADDER = IS_MAP ? 'set' : 'add';
    var NativeConstructor = global_1[CONSTRUCTOR_NAME];
    var NativePrototype = NativeConstructor && NativeConstructor.prototype;
    var Constructor = NativeConstructor;
    var exported = {};

    var fixMethod = function (KEY) {
      var uncurriedNativeMethod = functionUncurryThis(NativePrototype[KEY]);
      defineBuiltIn(NativePrototype, KEY,
        KEY == 'add' ? function add(value) {
          uncurriedNativeMethod(this, value === 0 ? 0 : value);
          return this;
        } : KEY == 'delete' ? function (key) {
          return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
        } : KEY == 'get' ? function get(key) {
          return IS_WEAK && !isObject(key) ? undefined : uncurriedNativeMethod(this, key === 0 ? 0 : key);
        } : KEY == 'has' ? function has(key) {
          return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
        } : function set(key, value) {
          uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
          return this;
        }
      );
    };

    var REPLACE = isForced_1(
      CONSTRUCTOR_NAME,
      !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
        new NativeConstructor().entries().next();
      }))
    );

    if (REPLACE) {
      // create collection constructor
      Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
      internalMetadata.enable();
    } else if (isForced_1(CONSTRUCTOR_NAME, true)) {
      var instance = new Constructor();
      // early implementations not supports chaining
      var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
      // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
      var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
      // most early implementations doesn't supports iterables, most modern - not close it correctly
      // eslint-disable-next-line no-new -- required for testing
      var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });
      // for early implementations -0 and +0 not the same
      var BUGGY_ZERO = !IS_WEAK && fails(function () {
        // V8 ~ Chromium 42- fails only with 5+ elements
        var $instance = new NativeConstructor();
        var index = 5;
        while (index--) $instance[ADDER](index, index);
        return !$instance.has(-0);
      });

      if (!ACCEPT_ITERABLES) {
        Constructor = wrapper(function (dummy, iterable) {
          anInstance(dummy, NativePrototype);
          var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
          if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
          return that;
        });
        Constructor.prototype = NativePrototype;
        NativePrototype.constructor = Constructor;
      }

      if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
        fixMethod('delete');
        fixMethod('has');
        IS_MAP && fixMethod('get');
      }

      if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);

      // weak collections should not contains .clear method
      if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
    }

    exported[CONSTRUCTOR_NAME] = Constructor;
    _export({ global: true, constructor: true, forced: Constructor != NativeConstructor }, exported);

    setToStringTag(Constructor, CONSTRUCTOR_NAME);

    if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);

    return Constructor;
  };

  var defineBuiltIns = function (target, src, options) {
    for (var key in src) defineBuiltIn(target, key, src[key], options);
    return target;
  };

  var SPECIES$5 = wellKnownSymbol('species');

  var setSpecies = function (CONSTRUCTOR_NAME) {
    var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
    var defineProperty = objectDefineProperty.f;

    if (descriptors && Constructor && !Constructor[SPECIES$5]) {
      defineProperty(Constructor, SPECIES$5, {
        configurable: true,
        get: function () { return this; }
      });
    }
  };

  var defineProperty$7 = objectDefineProperty.f;










  var fastKey = internalMetadata.fastKey;


  var setInternalState$1 = internalState.set;
  var internalStateGetterFor = internalState.getterFor;

  var collectionStrong = {
    getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
      var Constructor = wrapper(function (that, iterable) {
        anInstance(that, Prototype);
        setInternalState$1(that, {
          type: CONSTRUCTOR_NAME,
          index: objectCreate(null),
          first: undefined,
          last: undefined,
          size: 0
        });
        if (!descriptors) that.size = 0;
        if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
      });

      var Prototype = Constructor.prototype;

      var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

      var define = function (that, key, value) {
        var state = getInternalState(that);
        var entry = getEntry(that, key);
        var previous, index;
        // change existing entry
        if (entry) {
          entry.value = value;
        // create new entry
        } else {
          state.last = entry = {
            index: index = fastKey(key, true),
            key: key,
            value: value,
            previous: previous = state.last,
            next: undefined,
            removed: false
          };
          if (!state.first) state.first = entry;
          if (previous) previous.next = entry;
          if (descriptors) state.size++;
          else that.size++;
          // add to index
          if (index !== 'F') state.index[index] = entry;
        } return that;
      };

      var getEntry = function (that, key) {
        var state = getInternalState(that);
        // fast case
        var index = fastKey(key);
        var entry;
        if (index !== 'F') return state.index[index];
        // frozen object case
        for (entry = state.first; entry; entry = entry.next) {
          if (entry.key == key) return entry;
        }
      };

      defineBuiltIns(Prototype, {
        // `{ Map, Set }.prototype.clear()` methods
        // https://tc39.es/ecma262/#sec-map.prototype.clear
        // https://tc39.es/ecma262/#sec-set.prototype.clear
        clear: function clear() {
          var that = this;
          var state = getInternalState(that);
          var data = state.index;
          var entry = state.first;
          while (entry) {
            entry.removed = true;
            if (entry.previous) entry.previous = entry.previous.next = undefined;
            delete data[entry.index];
            entry = entry.next;
          }
          state.first = state.last = undefined;
          if (descriptors) state.size = 0;
          else that.size = 0;
        },
        // `{ Map, Set }.prototype.delete(key)` methods
        // https://tc39.es/ecma262/#sec-map.prototype.delete
        // https://tc39.es/ecma262/#sec-set.prototype.delete
        'delete': function (key) {
          var that = this;
          var state = getInternalState(that);
          var entry = getEntry(that, key);
          if (entry) {
            var next = entry.next;
            var prev = entry.previous;
            delete state.index[entry.index];
            entry.removed = true;
            if (prev) prev.next = next;
            if (next) next.previous = prev;
            if (state.first == entry) state.first = next;
            if (state.last == entry) state.last = prev;
            if (descriptors) state.size--;
            else that.size--;
          } return !!entry;
        },
        // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
        // https://tc39.es/ecma262/#sec-map.prototype.foreach
        // https://tc39.es/ecma262/#sec-set.prototype.foreach
        forEach: function forEach(callbackfn /* , that = undefined */) {
          var state = getInternalState(this);
          var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
          var entry;
          while (entry = entry ? entry.next : state.first) {
            boundFunction(entry.value, entry.key, this);
            // revert to the last existing entry
            while (entry && entry.removed) entry = entry.previous;
          }
        },
        // `{ Map, Set}.prototype.has(key)` methods
        // https://tc39.es/ecma262/#sec-map.prototype.has
        // https://tc39.es/ecma262/#sec-set.prototype.has
        has: function has(key) {
          return !!getEntry(this, key);
        }
      });

      defineBuiltIns(Prototype, IS_MAP ? {
        // `Map.prototype.get(key)` method
        // https://tc39.es/ecma262/#sec-map.prototype.get
        get: function get(key) {
          var entry = getEntry(this, key);
          return entry && entry.value;
        },
        // `Map.prototype.set(key, value)` method
        // https://tc39.es/ecma262/#sec-map.prototype.set
        set: function set(key, value) {
          return define(this, key === 0 ? 0 : key, value);
        }
      } : {
        // `Set.prototype.add(value)` method
        // https://tc39.es/ecma262/#sec-set.prototype.add
        add: function add(value) {
          return define(this, value = value === 0 ? 0 : value, value);
        }
      });
      if (descriptors) defineProperty$7(Prototype, 'size', {
        get: function () {
          return getInternalState(this).size;
        }
      });
      return Constructor;
    },
    setStrong: function (Constructor, CONSTRUCTOR_NAME, IS_MAP) {
      var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
      var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
      var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
      // `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods
      // https://tc39.es/ecma262/#sec-map.prototype.entries
      // https://tc39.es/ecma262/#sec-map.prototype.keys
      // https://tc39.es/ecma262/#sec-map.prototype.values
      // https://tc39.es/ecma262/#sec-map.prototype-@@iterator
      // https://tc39.es/ecma262/#sec-set.prototype.entries
      // https://tc39.es/ecma262/#sec-set.prototype.keys
      // https://tc39.es/ecma262/#sec-set.prototype.values
      // https://tc39.es/ecma262/#sec-set.prototype-@@iterator
      iteratorDefine(Constructor, CONSTRUCTOR_NAME, function (iterated, kind) {
        setInternalState$1(this, {
          type: ITERATOR_NAME,
          target: iterated,
          state: getInternalCollectionState(iterated),
          kind: kind,
          last: undefined
        });
      }, function () {
        var state = getInternalIteratorState(this);
        var kind = state.kind;
        var entry = state.last;
        // revert to the last existing entry
        while (entry && entry.removed) entry = entry.previous;
        // get next entry
        if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
          // or finish the iteration
          state.target = undefined;
          return createIterResultObject(undefined, true);
        }
        // return step by kind
        if (kind == 'keys') return createIterResultObject(entry.key, false);
        if (kind == 'values') return createIterResultObject(entry.value, false);
        return createIterResultObject([entry.key, entry.value], false);
      }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

      // `{ Map, Set }.prototype[@@species]` accessors
      // https://tc39.es/ecma262/#sec-get-map-@@species
      // https://tc39.es/ecma262/#sec-get-set-@@species
      setSpecies(CONSTRUCTOR_NAME);
    }
  };

  // `Set` constructor
  // https://tc39.es/ecma262/#sec-set-objects
  collection('Set', function (init) {
    return function Set() { return init(this, arguments.length ? arguments[0] : undefined); };
  }, collectionStrong);

  var charAt$5 = stringMultibyte.charAt;





  var STRING_ITERATOR = 'String Iterator';
  var setInternalState$2 = internalState.set;
  var getInternalState$2 = internalState.getterFor(STRING_ITERATOR);

  // `String.prototype[@@iterator]` method
  // https://tc39.es/ecma262/#sec-string.prototype-@@iterator
  iteratorDefine(String, 'String', function (iterated) {
    setInternalState$2(this, {
      type: STRING_ITERATOR,
      string: toString_1(iterated),
      index: 0
    });
  // `%StringIteratorPrototype%.next` method
  // https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
  }, function next() {
    var state = getInternalState$2(this);
    var string = state.string;
    var index = state.index;
    var point;
    if (index >= string.length) return createIterResultObject(undefined, true);
    point = charAt$5(string, index);
    state.index += point.length;
    return createIterResultObject(point, false);
  });

  var ITERATOR$6 = wellKnownSymbol('iterator');
  var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');
  var ArrayValues = es_array_iterator.values;

  var handlePrototype$1 = function (CollectionPrototype, COLLECTION_NAME) {
    if (CollectionPrototype) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[ITERATOR$6] !== ArrayValues) try {
        createNonEnumerableProperty(CollectionPrototype, ITERATOR$6, ArrayValues);
      } catch (error) {
        CollectionPrototype[ITERATOR$6] = ArrayValues;
      }
      if (!CollectionPrototype[TO_STRING_TAG$3]) {
        createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG$3, COLLECTION_NAME);
      }
      if (domIterables[COLLECTION_NAME]) for (var METHOD_NAME in es_array_iterator) {
        // some Chrome versions have non-configurable methods on DOMTokenList
        if (CollectionPrototype[METHOD_NAME] !== es_array_iterator[METHOD_NAME]) try {
          createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, es_array_iterator[METHOD_NAME]);
        } catch (error) {
          CollectionPrototype[METHOD_NAME] = es_array_iterator[METHOD_NAME];
        }
      }
    }
  };

  for (var COLLECTION_NAME$1 in domIterables) {
    handlePrototype$1(global_1[COLLECTION_NAME$1] && global_1[COLLECTION_NAME$1].prototype, COLLECTION_NAME$1);
  }

  handlePrototype$1(domTokenListPrototype, 'DOMTokenList');

  var $propertyIsEnumerable$1 = objectPropertyIsEnumerable.f;

  var propertyIsEnumerable = functionUncurryThis($propertyIsEnumerable$1);
  var push$5 = functionUncurryThis([].push);

  // `Object.{ entries, values }` methods implementation
  var createMethod$4 = function (TO_ENTRIES) {
    return function (it) {
      var O = toIndexedObject(it);
      var keys = objectKeys(O);
      var length = keys.length;
      var i = 0;
      var result = [];
      var key;
      while (length > i) {
        key = keys[i++];
        if (!descriptors || propertyIsEnumerable(O, key)) {
          push$5(result, TO_ENTRIES ? [key, O[key]] : O[key]);
        }
      }
      return result;
    };
  };

  var objectToArray = {
    // `Object.entries` method
    // https://tc39.es/ecma262/#sec-object.entries
    entries: createMethod$4(true),
    // `Object.values` method
    // https://tc39.es/ecma262/#sec-object.values
    values: createMethod$4(false)
  };

  var $entries = objectToArray.entries;

  // `Object.entries` method
  // https://tc39.es/ecma262/#sec-object.entries
  _export({ target: 'Object', stat: true }, {
    entries: function entries(O) {
      return $entries(O);
    }
  });

  var $some = arrayIteration.some;


  var STRICT_METHOD$3 = arrayMethodIsStrict('some');

  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  _export({ target: 'Array', proto: true, forced: !STRICT_METHOD$3 }, {
    some: function some(callbackfn /* , thisArg */) {
      return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  /**
   * Top parent class for all objects
   *
   * @property {Visio} _visio
   * @property {string} _xmlPath
   * @property {VisioRelationMap} _rels
   */
  var VisioObject = /*#__PURE__*/function () {
    function VisioObject(init) {
      var prefixList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();
      _classCallCheck(this, VisioObject);
      this.assertArchiveDefined(init);
      var initWithDefaults = _objectSpread2(_objectSpread2({}, this.getDefaultAttributes()), init);
      prefixList.add(VisioAttribute.archive);
      this._prefixList = prefixList;
      this.setAttributes(initWithDefaults);
    }
    _createClass(VisioObject, [{
      key: "getDefaultAttributes",
      value: function getDefaultAttributes() {
        return {
          archive: null // required in constructor
        };
      }
    }, {
      key: "prefixList",
      get: function get() {
        return this._prefixList;
      }
    }, {
      key: "setAttribute",
      value: function setAttribute(attributeName, value) {
        // prefix
        if (this.prefixList.has(attributeName)) attributeName = "_".concat(attributeName);
        this[attributeName] = value;
      }
    }, {
      key: "setAttributes",
      value: function setAttributes(init) {
        var _this = this;
        Object.entries(init).forEach(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
            attributeName = _ref2[0],
            value = _ref2[1];
          return _this.setAttribute(attributeName, value);
        });
        if ('structurePath' in init) {
          this.setOwner(init.structurePath);
        }
      }
    }, {
      key: "setOwner",
      value: function setOwner(structurePath) {
        if (structurePath.length === 1) {
          this.owner = structurePath[0].jxonType;
          return;
        }
        if (hasJxonType(structurePath, VisioJxonType.StyleSheet)) this.owner = 'Document-Stylesheet';else if (hasJxonType(structurePath, VisioJxonType.DocumentSheet)) this.owner = 'Document-DocumentSheet';else if (hasJxonType(structurePath, VisioJxonType.PageSheet)) {
          if (hasJxonType(structurePath, VisioJxonType.Page)) {
            this.owner = 'Page-PageSheet';
          } else if (hasJxonType(structurePath, VisioJxonType.Master)) {
            this.owner = 'Master-PageSheet';
          } else {
            debug.log('Unknown PageSheet owner');
          }
        } else if (hasJxonType(structurePath, VisioJxonType.Shape)) {
          if (hasJxonType(structurePath, VisioJxonType.Page)) {
            this.owner = 'Page-Shape';
          } else if (hasJxonType(structurePath, VisioJxonType.Master)) {
            this.owner = 'Master-Shape';
          } else {
            debug.log('Unknown Shape owner');
          }
        }
      }
    }, {
      key: "parent",
      get: function get() {
        return this._parent;
      },
      set: function set(parent) {
        this._parent = parent;
      }
    }, {
      key: "archive",
      get: function get() {
        return this._archive; // required in constructor
      }
    }, {
      key: "assertArchiveDefined",
      value: function assertArchiveDefined(init) {
        if (!init.hasOwnProperty('archive') || !init.archive) {
          debug.log('Missing archive reference in constructor', this);
        }
      }
    }]);
    return VisioObject;
  }();

  /**
   * @param {VisioStructurePath} structurePath
   * @param {VisioJxonType} jxonType
   */
  function hasJxonType(structurePath, jxonType) {
    return structurePath.some(function (fragment) {
      return fragment.jxonType === jxonType;
    });
  }

  /**
   * @param {string} string
   * @returns {string}
   */
  function firstLetterLowercase(string) {
    if (typeof string !== 'string') return '';
    return string.charAt(0).toLowerCase() + string.slice(1);
  }

  var VisioCell = /*#__PURE__*/function () {
    function VisioCell() {
      var init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, VisioCell);
      this._name = init.name;
      this._value = init.value;
      this._formula = init.formula;
      this._units = init.units;
      this._cells = init.cells;
    }
    _createClass(VisioCell, [{
      key: "name",
      get: function get() {
        return this._name;
      }
    }, {
      key: "value",
      get: function get() {
        return this._value;
      }
    }, {
      key: "formula",
      get: function get() {
        return this._formula;
      }
    }, {
      key: "units",
      get: function get() {
        return this._units;
      }
    }, {
      key: "eval",
      value: function _eval() {
        return this._cells[firstLetterLowercase(this.name)];
      }
    }]);
    return VisioCell;
  }();

  var VisioSheetObject = /*#__PURE__*/function (_VisioObject) {
    _inherits(VisioSheetObject, _VisioObject);
    var _super = _createSuper(VisioSheetObject);
    function VisioSheetObject() {
      _classCallCheck(this, VisioSheetObject);
      return _super.apply(this, arguments);
    }
    _createClass(VisioSheetObject, [{
      key: "getOwnCellNames",
      value: function getOwnCellNames() {
        var cells = this.cells;
        if (!cells) return [];
        return cells.getOwnNames();
      }
    }, {
      key: "getCell",
      value: function getCell(cellName) {
        var cells = this.cells;
        if (!cells) {
          debug.log('Visio object does not contain cells.');
          return null;
        }
        var cell = cells.get(cellName);
        if (!cell) return null;
        return new VisioCell(_objectSpread2(_objectSpread2({}, cell), {}, {
          cells: cells
        }));
      }
    }, {
      key: "setCell",
      value: function setCell(cellName, attributes) {
        var cells = this.cells,
          jxon = this.jxon;
        if (!cells) {
          debug.log('Visio object does not contain cells.');
          return;
        }
        cells.set(cellName, attributes, jxon);
      }
    }, {
      key: "removeCell",
      value: function removeCell(name) {
        var cells = this.cells,
          jxon = this.jxon;
        if (!cells || !cells.get(name)) {
          return;
        }
        cells.remove(name, jxon);
      }
    }]);
    return VisioSheetObject;
  }(VisioObject);

  var $every = arrayIteration.every;


  var STRICT_METHOD$4 = arrayMethodIsStrict('every');

  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  _export({ target: 'Array', proto: true, forced: !STRICT_METHOD$4 }, {
    every: function every(callbackfn /* , thisArg */) {
      return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }
  });

  var $TypeError$g = TypeError;

  // `Array.prototype.{ reduce, reduceRight }` methods implementation
  var createMethod$5 = function (IS_RIGHT) {
    return function (that, callbackfn, argumentsLength, memo) {
      aCallable(callbackfn);
      var O = toObject(that);
      var self = indexedObject(O);
      var length = lengthOfArrayLike(O);
      var index = IS_RIGHT ? length - 1 : 0;
      var i = IS_RIGHT ? -1 : 1;
      if (argumentsLength < 2) while (true) {
        if (index in self) {
          memo = self[index];
          index += i;
          break;
        }
        index += i;
        if (IS_RIGHT ? index < 0 : length <= index) {
          throw $TypeError$g('Reduce of empty array with no initial value');
        }
      }
      for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
        memo = callbackfn(memo, self[index], index, O);
      }
      return memo;
    };
  };

  var arrayReduce = {
    // `Array.prototype.reduce` method
    // https://tc39.es/ecma262/#sec-array.prototype.reduce
    left: createMethod$5(false),
    // `Array.prototype.reduceRight` method
    // https://tc39.es/ecma262/#sec-array.prototype.reduceright
    right: createMethod$5(true)
  };

  var engineIsNode = classofRaw(global_1.process) == 'process';

  var $reduce = arrayReduce.left;




  var STRICT_METHOD$5 = arrayMethodIsStrict('reduce');
  // Chrome 80-82 has a critical bug
  // https://bugs.chromium.org/p/chromium/issues/detail?id=1049982
  var CHROME_BUG = !engineIsNode && engineV8Version > 79 && engineV8Version < 83;

  // `Array.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduce
  _export({ target: 'Array', proto: true, forced: !STRICT_METHOD$5 || CHROME_BUG }, {
    reduce: function reduce(callbackfn /* , initialValue */) {
      var length = arguments.length;
      return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : undefined);
    }
  });

  // /**
  //  * when setting cell (all parts value, units, formula)
  //  *
  //  * @param {string} value
  //  * @param {VisioValueType} visioType
  //  */
  // export function convertCellValue(value, visioType) {
  //     const valueType = getCellType(visioType);
  //
  //
  //     return value;
  // }

  /**
   *
   * @param {VisioValueType} visioType - documentation type
   * @param {VisioCell} cell - for debug
   * @return {VisioConvertType | string} - "exact convert function"
   */
  function getConvertType(visioType, cell) {
    //return VisioConvertType.ignore;

    var specialConvertType = getSpecialConvertType(visioType, cell);
    if (specialConvertType !== null) return specialConvertType;
    if (cell.units === VisioUnitType.PER) return VisioConvertType.percentage;
    switch (visioType) {
      case VisioValueType.vScalar:
      case VisioValueType.PtgNum: // docs: double precision floating-point number
      case VisioValueType.PtgByte:
      case VisioValueType.PtgShort:
      case VisioValueType.PtgUnsShort:
      case VisioValueType.PtgInt:
      case VisioValueType.PtgNumI:
        return VisioConvertType.number;
      case VisioValueType.vLength:
        // MUST be interpreted as a lengthInternalUnitNumber
        return VisioConvertType.internalUnitsToPixels;
      case VisioValueType.PtgDate:
        return VisioConvertType.date;
      case VisioValueType.vAngle:
        return VisioConvertType.internalUnitsToDegrees;
      case VisioValueType.PtgBool:
        //return VisioConvertType.booleanTriState;
        return VisioConvertType.booleanStrict;
      case VisioValueType.PtgColorRGB:
      case VisioValueType.vColor:
        return VisioConvertType.color;

      //TODO miky resolve according to doc
      case VisioValueType.vAny:
        if (cell.units !== 'STR' && cell.name !== 'value') debug.log('resolve VisioValueType.vAny', cell);
      // eslint-disable-next-line
      case VisioValueType.vFont:
      case VisioValueType.vLanguageString:
      case VisioValueType.vFormatString:
      case VisioValueType.PtgString:
      case VisioValueType.formulaExpression:
        return VisioConvertType.asIs;
    }
    debug.log('unresolved cell type');
  }
  function getSpecialConvertType(visioType, cell) {
    // by docs vScalar treating as vLength
    if (['pageBottomMargin', 'pageLeftMargin', 'pageRightMargin', 'pageTopMargin'].includes(cell.name)) {
      return VisioConvertType.internalUnitsToPixels;
    }
    return null;
  }

  // import { VisioAttribute } from '../types/enums.mjs';
  // import { util } from 'jointjs';
  // import {
  //     LineVisioCellAttributeName,
  //     TextVisioCellAttributeName,
  //     FillVisioCellAttributeName
  // } from '../types/enums.mjs';
  // import { firstLetterLowercase } from '../helpers/firstLetterLowercase.mjs';

  // const styleAttributes = {
  //     [VisioAttribute.fillStyle]: Object.values(FillVisioCellAttributeName).map(firstLetterLowercase),
  //     [VisioAttribute.lineStyle]: Object.values(LineVisioCellAttributeName).map(firstLetterLowercase),
  //     [VisioAttribute.textStyle]: Object.values(TextVisioCellAttributeName).map(firstLetterLowercase)
  // };

  // export function enrichShapeWithStyleSheet(shapes, styleSheets) {
  //     if (!styleSheets) return shapes;
  //     util.toArray(shapes).forEach(shape => {
  //         if (!shape) return;
  //         Object.keys(styleAttributes).forEach((style) => {
  //             const attributes = styleAttributes[style];
  //             if (style in shape) {
  //                 attributes.forEach(attribute => {
  //                     const { cells } = shape;
  //                     // ? should we create cells if they don't exists
  //                     if (!cells || attribute in cells) return;
  //                     const val = getAttributeValueFromStylesheet(
  //                         styleSheets,
  //                         shape[style],
  //                         style,
  //                         attribute
  //                     );
  //                     if (val !== null) {
  //                         cells[attribute] = val;
  //                     }
  //                 });
  //             }
  //         });
  //         if (VisioAttribute.shapes in shape) {
  //             enrichShapeWithStyleSheet(shape[VisioAttribute.shapes], styleSheets);
  //         }
  //     });
  //
  //     return shapes;
  // }

  /**
   *
   * @param {Map.<number,VisioStylesheet>} styleSheets
   * @param {number} index
   * @param {
   *         VisioAttribute.fillStyle|
   *         VisioAttribute.lineStyle|
   *         VisioAttribute.textStyle
   *      } type
   * @param {VisioCellName} attributeName
   * @returns {VisioCell|null}
   */
  function getAttributeValueFromStylesheet(styleSheets, index, type, attributeName) {
    var styleSheet = styleSheets.get(index);
    if (!styleSheet) return null;
    var cells = styleSheet.cells;
    if (cells.has(attributeName)) return cells.get(attributeName);else if (type in styleSheet) return getAttributeValueFromStylesheet(styleSheets, styleSheet[type], type, attributeName);
    return null;
  }

  var config = {
    evaluateFormulas: false
  };

  function themedResolver(cell, valueType) {
    var name = cell.name;
    if (name === 'lineColor') return themeVal(VisioThemeValKey.Dark);
    if (name === 'linePattern') return 1; // solid line
    if (name === 'lineColorTrans') return false;
    if (name === 'fillForegnd') return themeVal(VisioThemeValKey.Light);
    if (name === 'fillPattern') return 1; // solid fill color
    if (name === 'fillForegndTrans') return 0; // 0-1

    if (name === 'style') return 0; // 0 - unformatted
    if (name === 'lineWeight') return 1; //TODO

    //TODO find right value
    if (name === 'font') return undefined;
    if (name === 'asianFont') return undefined;
    if (name === 'complexScriptFont') return undefined;
    if (name === 'color') return themeVal(VisioThemeValKey.Dark);
    if (name === 'fillBkgnd') return themeVal(VisioThemeValKey.Light);
    if (name === 'fillBkgndTrans') return false;

    // todo: finish this up ...
  }

  /**
   * @param {VisioThemeValKey} key
   */
  function themeVal(key) {
    // exact
    if (key === VisioThemeValKey.Light) return '#ffffff';
    if (key === VisioThemeValKey.Dark) return '#000000';
    if (key === VisioThemeValKey.AccentColor) return '#c05046';
    if (key === VisioThemeValKey.AccentColor2) return '#9dbb61';
    if (key === VisioThemeValKey.AccentColor3) return '#ab9ac0';
    if (key === VisioThemeValKey.AccentColor4) return '#4bacc6';
    if (key === VisioThemeValKey.AccentColor5) return '#f59d56';
    if (key === VisioThemeValKey.AccentColor6) return '#ffc000';
    if (key === VisioThemeValKey.VariantColor1) return '#c05046';
    if (key === VisioThemeValKey.VariantColor2) return '#9dbb61';
    if (key === VisioThemeValKey.VariantColor3) return '#ab9ac0';
    if (key === VisioThemeValKey.VariantColor4) return '#4bacc6';
    if (key === VisioThemeValKey.VariantColor5) return '#f59d56';
    if (key === VisioThemeValKey.VariantColor6) return '#ffc000';
    if (key === VisioThemeValKey.VariantColor7) return '#000000';
    debug.log('Unknown themeVal');
    // if (key === 'FillColor') return 'red';
  }

  /**
   * Root value means - directly converted to key value on {VisioObject}
   *
   * @param {string} attributeName - (normalizedAttributeName)
   * @param {string|null} value - in jxon everything is string
   * @param {VisioJxonType} jxonType
   * @returns {string|number|boolean|null}
   */
  function parseRootValue(attributeName, value, jxonType) {
    // root value must be whitelisted
    if (!VisioAttribute.hasOwnProperty(attributeName))
      // logAndThrow(`Unknown "VisioAttribute.${attributeName}"`);
      debug.log("Unknown VisioAttribute.".concat(attributeName));
    if (value === null) return null;

    //TODO miky number enums

    //TODO miky use doc dump
    //TODO miky use doc dump
    //TODO miky use doc dump

    // as integer ------------------------------------------------------------------------
    if ([VisioAttribute.id,
    // by docs unsignedInt
    VisioAttribute.masterId,
    // check docs
    VisioAttribute.masterShapeId,
    // check docs
    VisioAttribute.fromSheet,
    // check docs
    VisioAttribute.fromPart,
    // check docs
    VisioAttribute.toSheet,
    // check docs
    VisioAttribute.toPart,
    // check docs
    VisioAttribute.index
    // VisioAttribute.,
    ].includes(attributeName)) return asInteger(value);

    // as number -------------------------------------------------------------------------
    if ([VisioAttribute.patternFlags,
    // by docs unsignedShort
    VisioAttribute.masterType,
    // by docs unsignedShort
    VisioAttribute.alignName,
    // by docs unsignedShort
    VisioAttribute.iconSize,
    // by docs unsignedShort
    VisioAttribute.topPage, VisioAttribute.defaultTextStyle, VisioAttribute.defaultLineStyle, VisioAttribute.defaultFillStyle, VisioAttribute.defaultGuideStyle, VisioAttribute.glueSettings, VisioAttribute.snapSettings, VisioAttribute.snapExtensions, VisioAttribute.fillStyle, VisioAttribute.lineStyle, VisioAttribute.textStyle, VisioAttribute.backPage
    // VisioAttribute.,
    ].includes(attributeName)) return asNumber(value);

    // as boolean ------------------------------------------------------------------------
    if ([VisioAttribute.isCustomNameU, VisioAttribute.isCustomName, VisioAttribute.hidden, VisioAttribute.iconUpdate,
    //TODO miky investigate
    VisioAttribute.matchByName,
    //TODO miky investigate
    VisioAttribute.protectStyles, VisioAttribute.protectShapes, VisioAttribute.protectMasters, VisioAttribute.protectBkgnds, VisioAttribute.dynamicGridEnabled, VisioAttribute.deleted, VisioAttribute.background].includes(attributeName)) return asBooleanTristate(value);
    return value;
  }

  /**
   * @param {VisioShapeJxon|VisioMasterJXON|VisioJxon} jxon
   * @param {VisioJxonShapeKey|string} jxonType
   * @returns {{string: string}}
   * @param {VisioStructurePath} structurePath
   * @param {Object} [base]
   * @param {boolean} [ignoreNamespace]
   */
  function getRootAttributes(jxon, jxonType, structurePath) {
    var base = {};
    if (!structurePath) debug.log('Structure path not set.', {
      jxon: jxon,
      jxonType: jxonType
    });
    if (!VisioJxonType.hasOwnProperty(jxonType)) debug.log("Unknown \"VisioJXONType.".concat(jxonType, "\""));
    var result = /** @type {{string: string}} */Object.entries(jxon)
    // only attributes (starting with @)
    .filter(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
        key = _ref2[0],
        _value = _ref2[1];
      return key[0] === '@';
    })
    // no namespace specific
    .filter(function (_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
        key = _ref4[0],
        _value = _ref4[1];
      return ![VisioJxonKey.xmlns, VisioJxonKey.xmlnsR, VisioJxonKey.xmlSpace].includes(key);
    })
    // type specific
    // .filter(([key, _value]) => {
    //     if (jxonType === VisioJxonType.Section &&
    //         key === VisioJxonSectionKey.Name) return false;
    //
    //     return true;
    // })
    // convert to key: value structure
    .reduce(function (objectRootAttributes, _ref5) {
      var _ref6 = _slicedToArray(_ref5, 2),
        attributeName = _ref6[0],
        value = _ref6[1];
      var normalizedAttributeName = normalizeRootKey(attributeName.substring(1), jxonType);
      objectRootAttributes[normalizedAttributeName] = parseRootValue(normalizedAttributeName, value);
      return objectRootAttributes;
    }, base);
    return result;
  }

  /**
   * @param {string} attributeNameFromXML
   * @param {VisioJxonType} jxonType
   * @returns {string}
   */
  function normalizeRootKey(attributeNameFromXML, jxonType) {
    // KEEP VISIO SYNTAX !!!

    // Visio related - common for all types - lower "d" in "ID" only
    if (attributeNameFromXML === 'IX') return 'index';
    if (attributeNameFromXML === 'ID') return 'id';
    if (attributeNameFromXML === 'UniqueID') return 'uniqueId';
    if (attributeNameFromXML === 'OriginalID') return 'originalId';
    if (attributeNameFromXML === VisioJxonRowAttributeName.Deleted.substring(1)) return VisioAttribute.deleted;

    // Visio unrelated - ShapeText - JXONTree syntax
    if (jxonType === VisioJxonType.ShapeText && attributeNameFromXML === VisioJxonShapeTextKey.Content)
      // 'keyValue' =>
      return 'content';

    // section
    if (jxonType === VisioJxonType.Section && attributeNameFromXML === VisioJxonSectionKey.Name.substring(1)) {
      // '@N' =>
      //TODO miky name or type?
      return 'type';
    }

    // section
    if (jxonType === VisioJxonType.Row) {
      if (attributeNameFromXML === VisioJxonRowAttributeName.Type.substring(1))
        // '@T' =>
        //TODO miky name or type?
        return 'type';
      if (attributeNameFromXML === VisioJxonRowAttributeName.Name.substring(1))
        // '@N' =>
        //TODO miky name or type?
        return 'name';
    }

    // shape
    if (jxonType === VisioJxonType.Shape) {
      if (attributeNameFromXML === VisioJxonShapeKey.MasterShapeId.substring(1)) return VisioAttribute.masterShapeId; // '@MasterShape'
      if (attributeNameFromXML === VisioJxonShapeKey.MasterId.substring(1)) return VisioAttribute.masterId; // '@MasterShape'
    }

    // default
    return firstLetterLowercase(attributeNameFromXML);
  }

  /**
   * @param {VisioJxonType} jxonType
   * @param {VisioJxon} jxon
   * @param {VisioStructurePath} structurePath
   * @param {string|null} [typeOverride]
   * @param {*|null} [structurePathEnrichObject]
   * @returns {VisioStructurePathFragment}
   */
  function getStructurePathFragment(jxonType, jxon, structurePath) {
    var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
      _ref$typeOverride = _ref.typeOverride,
      typeOverride = _ref$typeOverride === void 0 ? null : _ref$typeOverride,
      _ref$structurePathEnr = _ref.structurePathEnrichObject,
      structurePathEnrichObject = _ref$structurePathEnr === void 0 ? null : _ref$structurePathEnr;
    if (!structurePath || !jxon) debug.log('Missing required attributes.');
    var result = {
      jxonType: jxonType,
      xsdType: xsdTypeFromJxonType(jxonType)
    };

    //TODO miky
    // temporarily root attrs (this fragment will be used for final one)
    // structure path is one step behind
    var rootAttributes = getRootAttributes(jxon, jxonType, structurePath);
    var whiteList = [VisioAttribute.id, VisioAttribute.name, VisioAttribute.masterId, VisioAttribute.masterShapeId, VisioAttribute.type, VisioAttribute.index];
    whiteList.forEach(function (attributeName) {
      if (rootAttributes.hasOwnProperty(attributeName)) result[attributeName] = rootAttributes[attributeName];
    });

    //TODO miky resolve correctly in getRootAttributes
    if (typeOverride) result.type = typeOverride;
    if (structurePathEnrichObject) {
      result = _objectSpread2(_objectSpread2({}, result), structurePathEnrichObject);
    }
    return result;
  }

  /**
   * @param {string} jxonType
   * @returns {string}
   */
  function xsdTypeFromJxonType(jxonType) {
    //TODO miky exceptions (if any)

    return "".concat(jxonType, "_Type");
  }
  function sectionAndRowHappyCase(structurePath) {
    var shapeReached = false;
    var result = {};
    structurePath.forEach(function (fragment) {
      if (fragment.jxonType === VisioJxonType.Shape) {
        shapeReached = true;
        return;
      }
      if (!shapeReached) return;
      if (fragment.jxonType === VisioJxonType.Section) result.section = fragment;
      if (fragment.jxonType === VisioJxonType.Row) result.row = fragment;
    });
    return result;
  }

  var $Function = Function;
  var concat$3 = functionUncurryThis([].concat);
  var join = functionUncurryThis([].join);
  var factories = {};

  var construct$1 = function (C, argsLength, args) {
    if (!hasOwnProperty_1(factories, argsLength)) {
      for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';
      factories[argsLength] = $Function('C,a', 'return new C(' + join(list, ',') + ')');
    } return factories[argsLength](C, args);
  };

  // `Function.prototype.bind` method implementation
  // https://tc39.es/ecma262/#sec-function.prototype.bind
  var functionBind = functionBindNative ? $Function.bind : function bind(that /* , ...args */) {
    var F = aCallable(this);
    var Prototype = F.prototype;
    var partArgs = arraySlice$1(arguments, 1);
    var boundFunction = function bound(/* args... */) {
      var args = concat$3(partArgs, arraySlice$1(arguments));
      return this instanceof boundFunction ? construct$1(F, args.length, args) : F.apply(that, args);
    };
    if (isObject(Prototype)) boundFunction.prototype = Prototype;
    return boundFunction;
  };

  // TODO: Remove from `core-js@4`



  // `Function.prototype.bind` method
  // https://tc39.es/ecma262/#sec-function.prototype.bind
  _export({ target: 'Function', proto: true, forced: Function.bind !== functionBind }, {
    bind: functionBind
  });

  var trim$2 = stringTrim.trim;


  var $parseInt = global_1.parseInt;
  var Symbol$3 = global_1.Symbol;
  var ITERATOR$7 = Symbol$3 && Symbol$3.iterator;
  var hex = /^[+-]?0x/i;
  var exec$2 = functionUncurryThis(hex.exec);
  var FORCED$3 = $parseInt(whitespaces + '08') !== 8 || $parseInt(whitespaces + '0x16') !== 22
    // MS Edge 18- broken with boxed symbols
    || (ITERATOR$7 && !fails(function () { $parseInt(Object(ITERATOR$7)); }));

  // `parseInt` method
  // https://tc39.es/ecma262/#sec-parseint-string-radix
  var numberParseInt = FORCED$3 ? function parseInt(string, radix) {
    var S = trim$2(toString_1(string));
    return $parseInt(S, (radix >>> 0) || (exec$2(hex, S) ? 16 : 10));
  } : $parseInt;

  // `parseInt` method
  // https://tc39.es/ecma262/#sec-parseint-string-radix
  _export({ global: true, forced: parseInt != numberParseInt }, {
    parseInt: numberParseInt
  });

  var PROPER_FUNCTION_NAME$2 = functionName.PROPER;



  var non = '\u200B\u0085\u180E';

  // check that a method works with the correct list
  // of whitespaces and has a correct name
  var stringTrimForced = function (METHOD_NAME) {
    return fails(function () {
      return !!whitespaces[METHOD_NAME]()
        || non[METHOD_NAME]() !== non
        || (PROPER_FUNCTION_NAME$2 && whitespaces[METHOD_NAME].name !== METHOD_NAME);
    });
  };

  var $trimEnd = stringTrim.end;


  // `String.prototype.{ trimEnd, trimRight }` method
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  // https://tc39.es/ecma262/#String.prototype.trimright
  var stringTrimEnd = stringTrimForced('trimEnd') ? function trimEnd() {
    return $trimEnd(this);
  // eslint-disable-next-line es/no-string-prototype-trimstart-trimend -- safe
  } : ''.trimEnd;

  // `String.prototype.trimRight` method
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  // eslint-disable-next-line es/no-string-prototype-trimleft-trimright -- safe
  _export({ target: 'String', proto: true, name: 'trimEnd', forced: ''.trimRight !== stringTrimEnd }, {
    trimRight: stringTrimEnd
  });

  // TODO: Remove this line from `core-js@4`




  // `String.prototype.trimEnd` method
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  // eslint-disable-next-line es/no-string-prototype-trimstart-trimend -- safe
  _export({ target: 'String', proto: true, name: 'trimEnd', forced: ''.trimEnd !== stringTrimEnd }, {
    trimEnd: stringTrimEnd
  });

  function getLineHeight(spLine, text, defaultCharacterCells) {
    // greater than or equal to zero, then the height of the line is equal to the value
    if (spLine >= 0) return spLine;

    // less than zero, then the height of the line is equal to the absolute value
    // of the structure multiplied by the largest font size of text in the line

    //TODO miky better way rough value
    //TODO miky work with lines separately
    var roughSpLine = pixelsToInches(-spLine);
    return getLargestFontSize(text, defaultCharacterCells) * roughSpLine;
  }
  function getLargestFontSize(text, defaultCharacterCells) {
    var size = defaultCharacterCells.size;
    text.forEach(function (textFragment) {
      var characterProperties = textFragment.characterProperties;
      if (characterProperties) {
        var customSize = characterProperties.values.size;
        if (characterProperties.values.size !== undefined) size = Math.max(size, customSize);
      }
    });
    return size;
  }

  /**
   * @param {string} string
   * @returns {string}
   */
  function firstLetterUppercase(string) {
    if (typeof string !== 'string') return '';
    return string.charAt(0).toUpperCase() + string.slice(1);
  }

  var $TypeError$h = TypeError;

  var validateArgumentsLength = function (passed, required) {
    if (passed < required) throw $TypeError$h('Not enough arguments');
    return passed;
  };

  var engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(engineUserAgent);

  var set$1 = global_1.setImmediate;
  var clear = global_1.clearImmediate;
  var process$1 = global_1.process;
  var Dispatch = global_1.Dispatch;
  var Function$1 = global_1.Function;
  var MessageChannel = global_1.MessageChannel;
  var String$1 = global_1.String;
  var counter = 0;
  var queue = {};
  var ONREADYSTATECHANGE = 'onreadystatechange';
  var $location, defer, channel, port;

  try {
    // Deno throws a ReferenceError on `location` access without `--location` flag
    $location = global_1.location;
  } catch (error) { /* empty */ }

  var run = function (id) {
    if (hasOwnProperty_1(queue, id)) {
      var fn = queue[id];
      delete queue[id];
      fn();
    }
  };

  var runner = function (id) {
    return function () {
      run(id);
    };
  };

  var listener = function (event) {
    run(event.data);
  };

  var post = function (id) {
    // old engines have not location.origin
    global_1.postMessage(String$1(id), $location.protocol + '//' + $location.host);
  };

  // Node.js 0.9+ & IE10+ has setImmediate, otherwise:
  if (!set$1 || !clear) {
    set$1 = function setImmediate(handler) {
      validateArgumentsLength(arguments.length, 1);
      var fn = isCallable(handler) ? handler : Function$1(handler);
      var args = arraySlice$1(arguments, 1);
      queue[++counter] = function () {
        functionApply(fn, undefined, args);
      };
      defer(counter);
      return counter;
    };
    clear = function clearImmediate(id) {
      delete queue[id];
    };
    // Node.js 0.8-
    if (engineIsNode) {
      defer = function (id) {
        process$1.nextTick(runner(id));
      };
    // Sphere (JS game engine) Dispatch API
    } else if (Dispatch && Dispatch.now) {
      defer = function (id) {
        Dispatch.now(runner(id));
      };
    // Browsers with MessageChannel, includes WebWorkers
    // except iOS - https://github.com/zloirock/core-js/issues/624
    } else if (MessageChannel && !engineIsIos) {
      channel = new MessageChannel();
      port = channel.port2;
      channel.port1.onmessage = listener;
      defer = functionBindContext(port.postMessage, port);
    // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
    } else if (
      global_1.addEventListener &&
      isCallable(global_1.postMessage) &&
      !global_1.importScripts &&
      $location && $location.protocol !== 'file:' &&
      !fails(post)
    ) {
      defer = post;
      global_1.addEventListener('message', listener, false);
    // IE8-
    } else if (ONREADYSTATECHANGE in documentCreateElement('script')) {
      defer = function (id) {
        html.appendChild(documentCreateElement('script'))[ONREADYSTATECHANGE] = function () {
          html.removeChild(this);
          run(id);
        };
      };
    // Rest old browsers
    } else {
      defer = function (id) {
        setTimeout(runner(id), 0);
      };
    }
  }

  var task = {
    set: set$1,
    clear: clear
  };

  var engineIsIosPebble = /ipad|iphone|ipod/i.test(engineUserAgent) && global_1.Pebble !== undefined;

  var engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(engineUserAgent);

  var getOwnPropertyDescriptor$4 = objectGetOwnPropertyDescriptor.f;
  var macrotask = task.set;





  var MutationObserver = global_1.MutationObserver || global_1.WebKitMutationObserver;
  var document$2 = global_1.document;
  var process$2 = global_1.process;
  var Promise$1 = global_1.Promise;
  // Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
  var queueMicrotaskDescriptor = getOwnPropertyDescriptor$4(global_1, 'queueMicrotask');
  var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

  var flush, head, last, notify, toggle, node, promise, then;

  // modern engines have queueMicrotask method
  if (!queueMicrotask) {
    flush = function () {
      var parent, fn;
      if (engineIsNode && (parent = process$2.domain)) parent.exit();
      while (head) {
        fn = head.fn;
        head = head.next;
        try {
          fn();
        } catch (error) {
          if (head) notify();
          else last = undefined;
          throw error;
        }
      } last = undefined;
      if (parent) parent.enter();
    };

    // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
    // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
    if (!engineIsIos && !engineIsNode && !engineIsWebosWebkit && MutationObserver && document$2) {
      toggle = true;
      node = document$2.createTextNode('');
      new MutationObserver(flush).observe(node, { characterData: true });
      notify = function () {
        node.data = toggle = !toggle;
      };
    // environments with maybe non-completely correct, but existent Promise
    } else if (!engineIsIosPebble && Promise$1 && Promise$1.resolve) {
      // Promise.resolve without an argument throws an error in LG WebOS 2
      promise = Promise$1.resolve(undefined);
      // workaround of WebKit ~ iOS Safari 10.1 bug
      promise.constructor = Promise$1;
      then = functionBindContext(promise.then, promise);
      notify = function () {
        then(flush);
      };
    // Node.js without promises
    } else if (engineIsNode) {
      notify = function () {
        process$2.nextTick(flush);
      };
    // for other environments - macrotask based on:
    // - setImmediate
    // - MessageChannel
    // - window.postMessage
    // - onreadystatechange
    // - setTimeout
    } else {
      // strange IE + webpack dev server bug - use .bind(global)
      macrotask = functionBindContext(macrotask, global_1);
      notify = function () {
        macrotask(flush);
      };
    }
  }

  var microtask = queueMicrotask || function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };

  var hostReportErrors = function (a, b) {
    var console = global_1.console;
    if (console && console.error) {
      arguments.length == 1 ? console.error(a) : console.error(a, b);
    }
  };

  var perform = function (exec) {
    try {
      return { error: false, value: exec() };
    } catch (error) {
      return { error: true, value: error };
    }
  };

  var Queue = function () {
    this.head = null;
    this.tail = null;
  };

  Queue.prototype = {
    add: function (item) {
      var entry = { item: item, next: null };
      if (this.head) this.tail.next = entry;
      else this.head = entry;
      this.tail = entry;
    },
    get: function () {
      var entry = this.head;
      if (entry) {
        this.head = entry.next;
        if (this.tail === entry) this.tail = null;
        return entry.item;
      }
    }
  };

  var queue$1 = Queue;

  var promiseNativeConstructor = global_1.Promise;

  /* global Deno -- Deno case */
  var engineIsDeno = typeof Deno == 'object' && Deno && typeof Deno.version == 'object';

  var engineIsBrowser = !engineIsDeno && !engineIsNode
    && typeof window == 'object'
    && typeof document == 'object';

  var NativePromisePrototype = promiseNativeConstructor && promiseNativeConstructor.prototype;
  var SPECIES$6 = wellKnownSymbol('species');
  var SUBCLASSING = false;
  var NATIVE_PROMISE_REJECTION_EVENT = isCallable(global_1.PromiseRejectionEvent);

  var FORCED_PROMISE_CONSTRUCTOR = isForced_1('Promise', function () {
    var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(promiseNativeConstructor);
    var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(promiseNativeConstructor);
    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // We can't detect it synchronously, so just check versions
    if (!GLOBAL_CORE_JS_PROMISE && engineV8Version === 66) return true;
    // We can't use @@species feature detection in V8 since it causes
    // deoptimization and performance degradation
    // https://github.com/zloirock/core-js/issues/679
    if (!engineV8Version || engineV8Version < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
      // Detect correctness of subclassing with @@species support
      var promise = new promiseNativeConstructor(function (resolve) { resolve(1); });
      var FakePromise = function (exec) {
        exec(function () { /* empty */ }, function () { /* empty */ });
      };
      var constructor = promise.constructor = {};
      constructor[SPECIES$6] = FakePromise;
      SUBCLASSING = promise.then(function () { /* empty */ }) instanceof FakePromise;
      if (!SUBCLASSING) return true;
    // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    } return !GLOBAL_CORE_JS_PROMISE && (engineIsBrowser || engineIsDeno) && !NATIVE_PROMISE_REJECTION_EVENT;
  });

  var promiseConstructorDetection = {
    CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR,
    REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT,
    SUBCLASSING: SUBCLASSING
  };

  var $TypeError$i = TypeError;

  var PromiseCapability = function (C) {
    var resolve, reject;
    this.promise = new C(function ($$resolve, $$reject) {
      if (resolve !== undefined || reject !== undefined) throw $TypeError$i('Bad Promise constructor');
      resolve = $$resolve;
      reject = $$reject;
    });
    this.resolve = aCallable(resolve);
    this.reject = aCallable(reject);
  };

  // `NewPromiseCapability` abstract operation
  // https://tc39.es/ecma262/#sec-newpromisecapability
  var f$7 = function (C) {
    return new PromiseCapability(C);
  };

  var newPromiseCapability = {
  	f: f$7
  };

  var task$1 = task.set;









  var PROMISE = 'Promise';
  var FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR;
  var NATIVE_PROMISE_REJECTION_EVENT$1 = promiseConstructorDetection.REJECTION_EVENT;
  var NATIVE_PROMISE_SUBCLASSING = promiseConstructorDetection.SUBCLASSING;
  var getInternalPromiseState = internalState.getterFor(PROMISE);
  var setInternalState$3 = internalState.set;
  var NativePromisePrototype$1 = promiseNativeConstructor && promiseNativeConstructor.prototype;
  var PromiseConstructor = promiseNativeConstructor;
  var PromisePrototype = NativePromisePrototype$1;
  var TypeError$3 = global_1.TypeError;
  var document$3 = global_1.document;
  var process$3 = global_1.process;
  var newPromiseCapability$1 = newPromiseCapability.f;
  var newGenericPromiseCapability = newPromiseCapability$1;

  var DISPATCH_EVENT = !!(document$3 && document$3.createEvent && global_1.dispatchEvent);
  var UNHANDLED_REJECTION = 'unhandledrejection';
  var REJECTION_HANDLED = 'rejectionhandled';
  var PENDING = 0;
  var FULFILLED = 1;
  var REJECTED = 2;
  var HANDLED = 1;
  var UNHANDLED = 2;

  var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

  // helpers
  var isThenable = function (it) {
    var then;
    return isObject(it) && isCallable(then = it.then) ? then : false;
  };

  var callReaction = function (reaction, state) {
    var value = state.value;
    var ok = state.state == FULFILLED;
    var handler = ok ? reaction.ok : reaction.fail;
    var resolve = reaction.resolve;
    var reject = reaction.reject;
    var domain = reaction.domain;
    var result, then, exited;
    try {
      if (handler) {
        if (!ok) {
          if (state.rejection === UNHANDLED) onHandleUnhandled(state);
          state.rejection = HANDLED;
        }
        if (handler === true) result = value;
        else {
          if (domain) domain.enter();
          result = handler(value); // can throw
          if (domain) {
            domain.exit();
            exited = true;
          }
        }
        if (result === reaction.promise) {
          reject(TypeError$3('Promise-chain cycle'));
        } else if (then = isThenable(result)) {
          functionCall(then, result, resolve, reject);
        } else resolve(result);
      } else reject(value);
    } catch (error) {
      if (domain && !exited) domain.exit();
      reject(error);
    }
  };

  var notify$1 = function (state, isReject) {
    if (state.notified) return;
    state.notified = true;
    microtask(function () {
      var reactions = state.reactions;
      var reaction;
      while (reaction = reactions.get()) {
        callReaction(reaction, state);
      }
      state.notified = false;
      if (isReject && !state.rejection) onUnhandled(state);
    });
  };

  var dispatchEvent = function (name, promise, reason) {
    var event, handler;
    if (DISPATCH_EVENT) {
      event = document$3.createEvent('Event');
      event.promise = promise;
      event.reason = reason;
      event.initEvent(name, false, true);
      global_1.dispatchEvent(event);
    } else event = { promise: promise, reason: reason };
    if (!NATIVE_PROMISE_REJECTION_EVENT$1 && (handler = global_1['on' + name])) handler(event);
    else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
  };

  var onUnhandled = function (state) {
    functionCall(task$1, global_1, function () {
      var promise = state.facade;
      var value = state.value;
      var IS_UNHANDLED = isUnhandled(state);
      var result;
      if (IS_UNHANDLED) {
        result = perform(function () {
          if (engineIsNode) {
            process$3.emit('unhandledRejection', value, promise);
          } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
        });
        // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
        state.rejection = engineIsNode || isUnhandled(state) ? UNHANDLED : HANDLED;
        if (result.error) throw result.value;
      }
    });
  };

  var isUnhandled = function (state) {
    return state.rejection !== HANDLED && !state.parent;
  };

  var onHandleUnhandled = function (state) {
    functionCall(task$1, global_1, function () {
      var promise = state.facade;
      if (engineIsNode) {
        process$3.emit('rejectionHandled', promise);
      } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
    });
  };

  var bind$1 = function (fn, state, unwrap) {
    return function (value) {
      fn(state, value, unwrap);
    };
  };

  var internalReject = function (state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    state.value = value;
    state.state = REJECTED;
    notify$1(state, true);
  };

  var internalResolve = function (state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    try {
      if (state.facade === value) throw TypeError$3("Promise can't be resolved itself");
      var then = isThenable(value);
      if (then) {
        microtask(function () {
          var wrapper = { done: false };
          try {
            functionCall(then, value,
              bind$1(internalResolve, wrapper, state),
              bind$1(internalReject, wrapper, state)
            );
          } catch (error) {
            internalReject(wrapper, error, state);
          }
        });
      } else {
        state.value = value;
        state.state = FULFILLED;
        notify$1(state, false);
      }
    } catch (error) {
      internalReject({ done: false }, error, state);
    }
  };

  // constructor polyfill
  if (FORCED_PROMISE_CONSTRUCTOR$1) {
    // 25.4.3.1 Promise(executor)
    PromiseConstructor = function Promise(executor) {
      anInstance(this, PromisePrototype);
      aCallable(executor);
      functionCall(Internal, this);
      var state = getInternalPromiseState(this);
      try {
        executor(bind$1(internalResolve, state), bind$1(internalReject, state));
      } catch (error) {
        internalReject(state, error);
      }
    };

    PromisePrototype = PromiseConstructor.prototype;

    // eslint-disable-next-line no-unused-vars -- required for `.length`
    Internal = function Promise(executor) {
      setInternalState$3(this, {
        type: PROMISE,
        done: false,
        notified: false,
        parent: false,
        reactions: new queue$1(),
        rejection: false,
        state: PENDING,
        value: undefined
      });
    };

    // `Promise.prototype.then` method
    // https://tc39.es/ecma262/#sec-promise.prototype.then
    Internal.prototype = defineBuiltIn(PromisePrototype, 'then', function then(onFulfilled, onRejected) {
      var state = getInternalPromiseState(this);
      var reaction = newPromiseCapability$1(speciesConstructor(this, PromiseConstructor));
      state.parent = true;
      reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
      reaction.fail = isCallable(onRejected) && onRejected;
      reaction.domain = engineIsNode ? process$3.domain : undefined;
      if (state.state == PENDING) state.reactions.add(reaction);
      else microtask(function () {
        callReaction(reaction, state);
      });
      return reaction.promise;
    });

    OwnPromiseCapability = function () {
      var promise = new Internal();
      var state = getInternalPromiseState(promise);
      this.promise = promise;
      this.resolve = bind$1(internalResolve, state);
      this.reject = bind$1(internalReject, state);
    };

    newPromiseCapability.f = newPromiseCapability$1 = function (C) {
      return C === PromiseConstructor || C === PromiseWrapper
        ? new OwnPromiseCapability(C)
        : newGenericPromiseCapability(C);
    };

    if ( isCallable(promiseNativeConstructor) && NativePromisePrototype$1 !== Object.prototype) {
      nativeThen = NativePromisePrototype$1.then;

      if (!NATIVE_PROMISE_SUBCLASSING) {
        // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs
        defineBuiltIn(NativePromisePrototype$1, 'then', function then(onFulfilled, onRejected) {
          var that = this;
          return new PromiseConstructor(function (resolve, reject) {
            functionCall(nativeThen, that, resolve, reject);
          }).then(onFulfilled, onRejected);
        // https://github.com/zloirock/core-js/issues/640
        }, { unsafe: true });
      }

      // make `.constructor === Promise` work for native promise-based APIs
      try {
        delete NativePromisePrototype$1.constructor;
      } catch (error) { /* empty */ }

      // make `instanceof Promise` work for native promise-based APIs
      if (objectSetPrototypeOf) {
        objectSetPrototypeOf(NativePromisePrototype$1, PromisePrototype);
      }
    }
  }

  _export({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR$1 }, {
    Promise: PromiseConstructor
  });

  setToStringTag(PromiseConstructor, PROMISE, false);
  setSpecies(PROMISE);

  var FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;

  var promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$2 || !checkCorrectnessOfIteration(function (iterable) {
    promiseNativeConstructor.all(iterable).then(undefined, function () { /* empty */ });
  });

  // `Promise.all` method
  // https://tc39.es/ecma262/#sec-promise.all
  _export({ target: 'Promise', stat: true, forced: promiseStaticsIncorrectIteration }, {
    all: function all(iterable) {
      var C = this;
      var capability = newPromiseCapability.f(C);
      var resolve = capability.resolve;
      var reject = capability.reject;
      var result = perform(function () {
        var $promiseResolve = aCallable(C.resolve);
        var values = [];
        var counter = 0;
        var remaining = 1;
        iterate(iterable, function (promise) {
          var index = counter++;
          var alreadyCalled = false;
          remaining++;
          functionCall($promiseResolve, C, promise).then(function (value) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values[index] = value;
            --remaining || resolve(values);
          }, reject);
        });
        --remaining || resolve(values);
      });
      if (result.error) reject(result.value);
      return capability.promise;
    }
  });

  var FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;





  var NativePromisePrototype$2 = promiseNativeConstructor && promiseNativeConstructor.prototype;

  // `Promise.prototype.catch` method
  // https://tc39.es/ecma262/#sec-promise.prototype.catch
  _export({ target: 'Promise', proto: true, forced: FORCED_PROMISE_CONSTRUCTOR$3, real: true }, {
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });

  // makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`
  if ( isCallable(promiseNativeConstructor)) {
    var method = getBuiltIn('Promise').prototype['catch'];
    if (NativePromisePrototype$2['catch'] !== method) {
      defineBuiltIn(NativePromisePrototype$2, 'catch', method, { unsafe: true });
    }
  }

  // `Promise.race` method
  // https://tc39.es/ecma262/#sec-promise.race
  _export({ target: 'Promise', stat: true, forced: promiseStaticsIncorrectIteration }, {
    race: function race(iterable) {
      var C = this;
      var capability = newPromiseCapability.f(C);
      var reject = capability.reject;
      var result = perform(function () {
        var $promiseResolve = aCallable(C.resolve);
        iterate(iterable, function (promise) {
          functionCall($promiseResolve, C, promise).then(capability.resolve, reject);
        });
      });
      if (result.error) reject(result.value);
      return capability.promise;
    }
  });

  var FORCED_PROMISE_CONSTRUCTOR$4 = promiseConstructorDetection.CONSTRUCTOR;

  // `Promise.reject` method
  // https://tc39.es/ecma262/#sec-promise.reject
  _export({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$4 }, {
    reject: function reject(r) {
      var capability = newPromiseCapability.f(this);
      functionCall(capability.reject, undefined, r);
      return capability.promise;
    }
  });

  var promiseResolve = function (C, x) {
    anObject(C);
    if (isObject(x) && x.constructor === C) return x;
    var promiseCapability = newPromiseCapability.f(C);
    var resolve = promiseCapability.resolve;
    resolve(x);
    return promiseCapability.promise;
  };

  var FORCED_PROMISE_CONSTRUCTOR$5 = promiseConstructorDetection.CONSTRUCTOR;


  var PromiseConstructorWrapper = getBuiltIn('Promise');

  // `Promise.resolve` method
  // https://tc39.es/ecma262/#sec-promise.resolve
  _export({ target: 'Promise', stat: true, forced:  FORCED_PROMISE_CONSTRUCTOR$5 }, {
    resolve: function resolve(x) {
      return promiseResolve( this, x);
    }
  });

  function wrapTextByWord(text, opt) {
    // OPTIONS:
    var localOpt = opt || {};
    var attributes = localOpt.attributes;
    var annotations = localOpt.annotations;
    var maxWidth = localOpt.maxWidth == null ? 1e6 : localOpt.maxWidth;
    var overflowAllowed = !!localOpt.overflowAllowed;

    // Text wrapping rules:
    // ...overflow width is less than (maxWidth * value)...
    var MAX_OVERFLOW_WIDTH_RATIO = 0.4;
    // ...or overflow width is less than this value (px)...
    var MAX_OVERFLOW_WIDTH = 100;
    // ...whichever is wider.

    // MAIN ROUTINE:

    // Split to lines at user-defined newlines.
    var lines = text.split('\n');
    var numLines = lines.length; // number of user-defined lines
    var lineIndex = 0; // the index of the line among user-defined lines

    var tokenIndex; // the index of the token on the user-defined line
    var charIndex = 0; // the start char of the current token in original text

    var wrappedText = ''; // the text after wrapping
    var wrappedCharIndex = 0;
    var wrappedTextAnnotations = jointjs.util.merge([], annotations); // annotations after wrapping

    var lineTokens; // tokens on the current line

    var overflowTokens; // tokens in the overflow

    // For every user-defined newline, do this:
    lines.forEach(function (line) {
      // Refresh variables that are concerned with user-defined lines.
      tokenIndex = 0;

      // wrappedLineIndex = 0;
      // lineCharIndex = 0;
      lineTokens = [];
      overflowTokens = [];

      // Process the line token by token.
      var token = nextToken(line);
      while (token) {
        processToken(token);
        token = nextToken(line);
      }

      // If there was overflow, insert it now.
      // (i.e. at the end of the last wrapped line)
      if (overflowTokens.length) {
        insertOverflowTokens();
      }

      // Re-add newline character.
      // (if this is not the last user-defined line)
      if (lineIndex < numLines - 1) {
        insert('\n');
      }
      lineIndex += 1;
    });

    // Now that we figured out what the wrapped text would look like, check
    // whether we should keep the wrapping:
    // - If overflow is allowed,
    // - And there was only one user-defined line
    // - And there are two wrapped lines,
    // - And the second line is an orphan (compared to the first line),
    // Put the orphan back on first line (by returning the original text).
    var wrappedLines = wrappedText.split('\n');
    var totalLines = wrappedLines.length;
    if (overflowAllowed && numLines === 1) {
      if (wrappedLines.length === 2) {
        var line1 = wrappedLines[0];
        var line2 = wrappedLines[1];
        var wrappedTextAnnotationsTmp = jointjs.util.merge([], wrappedTextAnnotations);
        var line1Annotations = jointjs.V.findAnnotationsBetweenIndexes(wrappedTextAnnotationsTmp, 0, line1.length);
        var line2Annotations = jointjs.V.shiftAnnotations(jointjs.V.findAnnotationsBetweenIndexes(wrappedTextAnnotationsTmp, line1.length, line1.length + line2.length), line1.length, -line1.length - 1);
        var line1Width = this.measureText(line1, attributes, line1Annotations).width;
        var line2Width = this.measureText(line2, attributes, line2Annotations).width;
        if (line2Width < Math.min(line1Width * MAX_OVERFLOW_WIDTH_RATIO, MAX_OVERFLOW_WIDTH)) {
          return {
            numLines: totalLines,
            text: text,
            annotations: annotations
          };
        }
      }
    }
    return {
      numLines: totalLines,
      text: wrappedText,
      annotations: wrappedTextAnnotations
    };

    // HELPER FUNCTIONS:

    // Return next token on the `line` or `null` if there is none.
    // Each token has the following properties:
    // type ... the type of the token ('word' or 'whitespace').
    // text ... the text of the token
    // startIndex ... the index of the first character of the token in `text`.
    // endIndex ... the index after the last character of the token in `text`.
    function nextToken(line) {
      var token = {
        type: null,
        startIndex: tokenIndex,
        endIndex: tokenIndex,
        text: ''
      };
      while (tokenIndex < line.length) {
        var c = line[tokenIndex];
        if (isWhiteSpace(c)) {
          switch (token.type) {
            case null:
            case 'whitespace':
              token.type = 'whitespace';
              token.text += c;
              token.endIndex += 1;
              break;
            default:
              return token;
          }
        } else {
          switch (token.type) {
            case 'whitespace':
              return token;
            default:
              token.type = 'word';
              token.text += c;
              token.endIndex += 1;
              break;
          }
        }
        tokenIndex += 1;
      }
      return token.startIndex === token.endIndex ? null : token;
    }
    function isWhiteSpace(c) {
      var re = /\s/;
      return re.test(c);
    }

    // Process one token.
    function processToken(token) {
      var hasLineTokens = !!lineTokens.length;
      var hasOverflowTokens = !!overflowTokens.length;

      // Is this the first token?
      var isFirstToken = !hasLineTokens && !hasOverflowTokens;

      // Measure the line up to and including the current token.
      var textSoFar = '';
      if (hasLineTokens) textSoFar = lineTokens[lineTokens.length - 1].cumulativeText;
      if (hasOverflowTokens) textSoFar = overflowTokens[overflowTokens.length - 1].cumulativeText;
      var cumulativeText = textSoFar + token.text;
      var sIndex = charIndex - textSoFar.length;
      var eIndex = charIndex + token.text.length;
      var textAnnotations = jointjs.V.findAnnotationsBetweenIndexes(annotations, sIndex, eIndex);
      var lineStartIndex = wrappedCharIndex - textSoFar.length;
      var measurementAnnotations = jointjs.util.toArray(textAnnotations).reduce(function (res, annotation) {
        res.push({
          start: annotation.start - lineStartIndex,
          end: annotation.end - lineStartIndex,
          attrs: annotation.attrs
        });
        return res;
      }, []);
      var lineWidth = measureText(cumulativeText, attributes, measurementAnnotations).width;

      // Is the token whitespace?
      var isTokenWhitespace = token.type === 'whitespace';
      // Can token fit into available space on the line?
      var canFit = lineWidth <= maxWidth;
      if (!hasOverflowTokens && (canFit || isTokenWhitespace)) {
        // The token fits into the current line.
        // (Whitespaces are always allowed to overflow.)

        // Insert the token.
        insert(token.text);
        pushLineToken(token, cumulativeText);
        return;
      }

      // Else: the token does not fit into the current line.

      // Try to hyphenate the token.
      // (Only possible if the token is not already a hyphenation piece.)
      var isTokenPiece = token.type === 'piece';
      // Note: Hyphenation removed for now

      // Else: the token cannot be hyphenated.

      // Is the token too wide for the line?
      var isTokenTooWide = isFirstToken;
      // (If we got this far in the logic with the first token, we know
      // that its width is greater than `maxWidth (+ maxOverflowWidth)`.)
      if (isTokenTooWide) {
        // Just insert the token (will definitely overflow the line).
        insert(token.text);
        pushLineToken(token, cumulativeText);
        return;
      }

      // Else: we have to start a new line now.

      // Add a hyphen, if necessary.
      if (isTokenPiece && token.pieceIndex > 0) {
        // (Hyphens are allowed to overflow.)
        insert('-', true);
      }

      // Start a new line.
      // If all the tokens seen so far were only added into overflow
      // (i.e. nothing was added onto the line yet), then we do not need
      // to start a new line.
      if (hasLineTokens) {
        startNewLine();
      }

      // If there was overflow, insert those tokens into the line now.
      if (hasOverflowTokens) {
        insertOverflowTokens();
      }

      // Rerun the algorithm for the current token with updated line and
      // overflow information.
      processToken(token);
    }

    // Insert a piece of text to the resulting transformed wrapped text.
    // If `isNewText` is true, we are inserting a piece of text that was not
    // present in the original text. For example, if we add a newline
    // character, we must shift all the following annotations so that their
    // indices are properly updated.
    function insert(insertText, isNewText) {
      wrappedText += insertText;
      if (isNewText) {
        jointjs.V.shiftAnnotations(wrappedTextAnnotations, charIndex, insertText.length);
      }
      wrappedCharIndex += insertText.length;
    }
    function pushLineToken(token, cumulativeText) {
      lineTokens.push({
        token: token,
        cumulativeText: cumulativeText
      });
      charIndex += token.text.length;
    }

    // Start a new line.
    function startNewLine() {
      // Remove line's last whitespace token.
      var lastLineToken = lineTokens[lineTokens.length - 1];
      if (lastLineToken.type === 'whitespace') {
        remove(lastLineToken.text);
        // no need to remove token from `lineTokens`, it will be cleared soon anyway
      }

      // Add a newline character.
      // If there is already a newline character at the spot, collapse
      // the two.
      insert('\n', true);

      // Reset.
      lineTokens = [];
    }

    // Put overflow tokens on the new line.
    // (Here we assume that overflow space cannot be wider than `maxWidth`,
    // i.e. that `maxOverflowWidth <= maxWidth`,
    // i.e. `0 <= MAX_OVERFLOW_WIDTH_RATIO <= 1`.)
    function insertOverflowTokens() {
      var cumulativeText = '';
      overflowTokens.forEach(function (t) {
        cumulativeText += t.token.text;

        // Insert the token.
        insert(t.token.text);
        pushLineToken(t.token, cumulativeText);
        charIndex -= t.token.text.length;
      });

      // Reset.
      overflowTokens = [];
    }

    // Remove a piece of text from the resulting transformed wrapped text.
    // Always update annotations.
    // This happens when we collapse whitespace characters at the beginning
    // of lines.
    function remove(removedText) {
      jointjs.V.shiftAnnotations(wrappedTextAnnotations, charIndex, -removedText.length);
      wrappedCharIndex -= removedText.length;
    }
  }
  var _textEl;
  function measureText(text, fontAttrs, textAnnotations, opt) {
    var localFontAttrs = fontAttrs || {};
    var options = opt || {
      heightCompensation: false
    };
    if (!_textEl) {
      var svg = jointjs.V('svg');
      document.body.appendChild(svg.node);
      _textEl = jointjs.V('text');
      _textEl.attr('visibility', 'hidden');
      svg.append(_textEl);
    }
    _textEl.attr({
      'font-weight': localFontAttrs['font-weight'],
      'font-size': localFontAttrs['font-size'],
      'font-family': localFontAttrs['font-family'],
      'letter-spacing': localFontAttrs['letter-spacing'],
      'style': 'font-kerning: none'
    });
    _textEl.text(text, {
      lineHeight: jointjs.util.isEmpty(textAnnotations) ? localFontAttrs['line-height'] || '1em' : 'auto',
      replaceNewLine: 'â',
      annotations: textAnnotations
    });
    // TODO: with new version of jointJS the next line is unnecessary
    _textEl.node.removeAttribute('display');
    // Note that we don't need to calculate bbox with transformations.
    var bbox = _textEl.bbox(true);
    if (options.heightCompensation) {
      bbox.height -= bbox.y;
    }
    bbox.y = 0;
    bbox.x = 0;
    return bbox;
  }

  function getAnnotatedText(shape) {
    // ---------------- text defaults ------------------
    var contentArray = [];
    var firstFont = null;
    var firstFontSize = null;
    var annotations = [];
    var start;
    var end = 0;
    var text = shape.text;

    // ---------------- paragraph  -----------------------
    // by docs should be treated as more paragraph properties in one text possible
    // but not present in PoC vsdxs
    //TODO treat as more blocks
    var defaultParagraphCells = shape.sections.get('Paragraph')[0].rows[0].cells;
    var spLine = defaultParagraphCells.spLine,
      horzAlign = defaultParagraphCells.horzAlign;
    // override with all props found last wins (not perfect, but for now)
    text.forEach(function (textFragment) {
      if (textFragment.paragraphProperties) {
        var values = textFragment.paragraphProperties.values;
        // if (values.indFirst !== undefined) indFirst = values.indFirst;
        // if (values.indLeft !== undefined) indLeft = values.indLeft;
        // if (values.indRight !== undefined) indRight = values.indRight;
        if (values.spLine !== undefined) spLine = values.spLine;
        // if (values.spBefore !== undefined) spBefore = values.spBefore;
        // if (values.spAfter !== undefined) spAfter = values.spAfter;
        if (values.horzAlign !== undefined) horzAlign = values.horzAlign;
        // if (values.bullet !== undefined) bullet = values.bullet;
        // if (values.bulletStr !== undefined) bulletStr = values.bulletStr;
        // if (values.bulletFont !== undefined) bulletFont = values.bulletFont;
        // if (values.bulletFontSize !== undefined) bulletFontSize = values.bulletFontSize;
        // if (values.textPosAfterBullet !== undefined) textPosAfterBullet = values.textPosAfterBullet;
        // if (values.flags !== undefined) flags = values.flags;
      }
    });

    // ---------------- text fragments ------------------
    var defaultCharacterCells = shape.sections.get('Character')[0].rows[0].cells; // at least default always prepared

    // TODO: this picks line height based on largest font size which creates unpredictable
    // results as some text blocks contain a single larger character (i.e. icon) which makes
    // entire text with LH as if it's the size of that icon (i.e. BRND/P:1/ID:190)
    var lineHeight = getLineHeight(spLine, text, defaultCharacterCells);
    text.forEach(function (textFragment) {
      var content = textFragment.content; // string

      start = end;
      var length = content.length; // always > 0 (checked during parsing)
      end = start + length;
      var uppercase = defaultCharacterCells.uppercase,
        font = defaultCharacterCells.font,
        color = defaultCharacterCells.color,
        style = defaultCharacterCells.style,
        size = defaultCharacterCells.size,
        letterspace = defaultCharacterCells.letterspace;
      if (textFragment.characterProperties) {
        var values = textFragment.characterProperties.values;
        if (values.uppercase !== undefined) uppercase = values.uppercase;
        if (values.font !== undefined) font = values.font;
        if (values.color !== undefined) color = values.color;
        if (values.style !== undefined) style = values.style;
        // if (values.pos !== undefined) pos = values.pos;
        // if (values.fontScale !== undefined) fontScale = values.fontScale;
        if (values.size !== undefined) size = values.size;
        // if (values.dblUnderline !== undefined) dblUnderline = values.dblUnderline;
        // if (values.overline !== undefined) overline = values.overline;
        // if (values.strikethru !== undefined) strikethru = values.strikethru;
        // if (values.doubleStrikethrough !== undefined) doubleStrikethrough = values.doubleStrikethrough;
        if (values.letterspace !== undefined) letterspace = values.letterspace;
        // if (values.colorTrans !== undefined) colorTrans = values.colorTrans;
        // if (values.asianFont !== undefined) asianFont = values.asianFont;
        // if (values.complexScriptFont !== undefined) complexScriptFont = values.complexScriptFont;
        // if (values.complexScriptSize !== undefined) complexScriptSize = values.complexScriptSize;
        // if (values.langID !== undefined) langID = values.langID;
      }

      var annotationAttrs = {};
      if (uppercase === 1) {
        content = content.toUpperCase();
      }
      if (uppercase === 2) {
        content = firstLetterUppercase(content);
        annotationAttrs['text-transform'] = 'capitalize';
      }

      // TODO: can it be done here?
      if (letterspace && letterspace !== 0) {
        annotationAttrs['letter-spacing'] = letterspace;
      }
      if (font) {
        if (!firstFont) firstFont = font;

        // use even when not available (browser will handle that)
        annotationAttrs['font-family'] = font;
      }
      if (size !== undefined) {
        if (!firstFontSize) firstFontSize = size;
        annotationAttrs['font-size'] = size;
        // TODO: error in conversion
        if (annotationAttrs['font-size'] < 1) annotationAttrs['font-size'] = 12;
      }
      if (color !== undefined) {
        annotationAttrs['fill'] = color;
      }
      if (style !== undefined) {
        // https://docs.microsoft.com/en-us/openspecs/sharepoint_protocols/ms-vsdx/a87e85ee-cf76-4e0b-a09e-638c871c28e2
        if (style & 4) annotationAttrs['text-decoration'] = 'underline';
        if (style & 2) annotationAttrs['font-style'] = 'italic';
        if (style & 1) annotationAttrs['font-weight'] = 'bold';
      }
      contentArray.push(content);
      var annotation = {
        start: start,
        end: end,
        attrs: annotationAttrs
      };
      annotations.push(annotation);
    });
    var contentMerged = contentArray.join('').trimEnd();
    return {
      mergedText: contentMerged,
      annotations: annotations,
      lineHeight: lineHeight,
      firstFont: firstFont,
      firstFontSize: firstFontSize,
      horzAlign: horzAlign
    };
  }
  function enrichShapeTextAttributes(shape, _ref) {
    var markup = _ref.markup,
      attrs = _ref.attrs,
      prefix = _ref.prefix,
      isRootGroupText = _ref.isRootGroupText;
    var cells = shape.cells,
      width = shape.width,
      height = shape.height;
    var angle = cells.angle,
      _cells$locPinX = cells.locPinX,
      locPinX = _cells$locPinX === void 0 ? width / 2 : _cells$locPinX,
      _cells$locPinY = cells.locPinY,
      locPinY = _cells$locPinY === void 0 ? height / 2 : _cells$locPinY,
      _cells$txtAngle = cells.txtAngle,
      txtAngle = _cells$txtAngle === void 0 ? 0 : _cells$txtAngle,
      flipX = cells.flipX,
      flipY = cells.flipY,
      _cells$txtHeight = cells.txtHeight,
      txtHeight = _cells$txtHeight === void 0 ? height : _cells$txtHeight,
      _cells$txtWidth = cells.txtWidth,
      txtWidth = _cells$txtWidth === void 0 ? width : _cells$txtWidth,
      _cells$txtPinX = cells.txtPinX,
      txtPinX = _cells$txtPinX === void 0 ? width / 2 : _cells$txtPinX,
      _cells$txtPinY = cells.txtPinY,
      txtPinY = _cells$txtPinY === void 0 ? height / 2 : _cells$txtPinY,
      _cells$txtLocPinX = cells.txtLocPinX,
      txtLocPinX = _cells$txtLocPinX === void 0 ? txtWidth / 2 : _cells$txtLocPinX,
      _cells$txtLocPinY = cells.txtLocPinY,
      txtLocPinY = _cells$txtLocPinY === void 0 ? txtHeight / 2 : _cells$txtLocPinY,
      verticalAlign = cells.verticalAlign,
      _cells$leftMargin = cells.leftMargin,
      leftMargin = _cells$leftMargin === void 0 ? 0 : _cells$leftMargin,
      _cells$rightMargin = cells.rightMargin,
      rightMargin = _cells$rightMargin === void 0 ? 0 : _cells$rightMargin,
      _cells$topMargin = cells.topMargin,
      topMargin = _cells$topMargin === void 0 ? 0 : _cells$topMargin,
      _cells$bottomMargin = cells.bottomMargin,
      bottomMargin = _cells$bottomMargin === void 0 ? 0 : _cells$bottomMargin;

    // --------------- text group -------------------
    var labelSelector = "".concat(prefix, "text");
    var sx = flipX ? -1 : 1,
      sy = flipY ? -1 : 1,
      tx = flipX ? -txtWidth + locPinX - txtPinX + txtLocPinX : -locPinX + txtPinX - txtLocPinX,
      ty = flipY ? height - locPinY + txtPinY - txtLocPinY : height - txtHeight + locPinY - txtPinY + txtLocPinY,
      ra = angle,
      rx = flipX ? txtWidth - locPinX + txtPinX - txtLocPinX : locPinX - txtPinX + txtLocPinX,
      ry = flipY ? locPinY - txtPinY + txtLocPinY : txtHeight - locPinY + txtPinY - txtLocPinY,
      ra2 = sx * sy * txtAngle,
      rx2 = flipX ? txtLocPinX - txtWidth : txtLocPinX,
      ry2 = flipY ? txtLocPinY : txtHeight - txtLocPinY;
    if (isRootGroupText) {
      tx += locPinX;
      ty -= locPinY;
    }
    var translation = "translate(".concat(tx, ", ").concat(ty, ")");
    var rotation = "rotate(".concat(ra, ", ").concat(rx, ", ").concat(ry, ")");
    var textRotation = "rotate(".concat(ra2, ", ").concat(rx2, ", ").concat(ry2, ")");
    var transform = [translation, rotation, textRotation].join(' ');
    var children = [{
      tagName: 'text',
      selector: labelSelector,
      attributes: {
        'stroke': 'none',
        'fill': '#000000'
      }
    }];
    if (debug.level & debug.TEXT_FRAMES) {
      children.unshift({
        tagName: 'rect',
        attributes: {
          width: txtWidth,
          height: txtHeight,
          fill: 'transparent',
          stroke: '#ff0000',
          strokeWidth: 1
        }
      });
    }
    markup.push({
      tagName: 'g',
      text: true,
      attributes: {
        transform: transform
      },
      children: children
    });
    var _getAnnotatedText = getAnnotatedText(shape),
      mergedText = _getAnnotatedText.mergedText,
      annotations = _getAnnotatedText.annotations,
      lineHeight = _getAnnotatedText.lineHeight,
      firstFont = _getAnnotatedText.firstFont,
      firstFontSize = _getAnnotatedText.firstFontSize,
      horzAlign = _getAnnotatedText.horzAlign;
    var wrappedText = wrapTextByWord(mergedText, {
      annotations: annotations,
      hyphenationAllowed: false,
      maxWidth: txtWidth - leftMargin - rightMargin
    });
    var labelAttrs = attrs[labelSelector] = {
      text: wrappedText.text,
      lineHeight: lineHeight,
      fontFamily: firstFont || 'sans-serif',
      letterSpacing: 0,
      firstFontSize: firstFontSize,
      annotations: wrappedText.annotations
    };
    var fontShoulder = (lineHeight - firstFontSize) / 2;
    jointjs.util.assign(labelAttrs, verticalTextPosition({
      verticalAlign: verticalAlign,
      height: height,
      topMargin: topMargin,
      fontShoulder: fontShoulder,
      bottomMargin: bottomMargin,
      txtPinY: txtPinY,
      txtLocPinY: txtLocPinY,
      txtHeight: txtHeight
    }), horizontalTextPosition({
      horzAlign: horzAlign,
      width: width,
      leftMargin: leftMargin,
      rightMargin: rightMargin,
      txtPinX: txtPinX,
      txtLocPinX: txtLocPinX,
      txtWidth: txtWidth
    }));
  }
  function verticalTextPosition(_ref2) {
    var verticalAlign = _ref2.verticalAlign,
      height = _ref2.height,
      topMargin = _ref2.topMargin,
      fontShoulder = _ref2.fontShoulder,
      bottomMargin = _ref2.bottomMargin,
      _ref2$txtHeight = _ref2.txtHeight,
      txtHeight = _ref2$txtHeight === void 0 ? height : _ref2$txtHeight,
      _ref2$txtLocPinY = _ref2.txtLocPinY;
    // https://docs.microsoft.com/en-us/openspecs/sharepoint_protocols/ms-vsdx/732e98b3-21eb-4d11-82ef-68287a55c1be
    var y = (topMargin + txtHeight - bottomMargin) / 2;
    var textVerticalAnchor = 'middle';

    // verticalAlign: 0 = top, 1 = middle, 2 = bottom, 3+ = top
    switch (verticalAlign) {
      case 1:
        break;
      case 2:
        y = txtHeight - bottomMargin - fontShoulder;
        textVerticalAnchor = 'bottom';
        break;
      case 0:
      default:
        y = topMargin + fontShoulder;
        textVerticalAnchor = 'top';
        break;
    }
    return {
      y: y,
      textVerticalAnchor: textVerticalAnchor
    };
  }
  function horizontalTextPosition(_ref3) {
    var horzAlign = _ref3.horzAlign,
      width = _ref3.width,
      leftMargin = _ref3.leftMargin,
      rightMargin = _ref3.rightMargin,
      _ref3$txtWidth = _ref3.txtWidth,
      txtWidth = _ref3$txtWidth === void 0 ? width : _ref3$txtWidth;
    // https://docs.microsoft.com/en-us/openspecs/sharepoint_protocols/ms-vsdx/1c184dde-942b-45ec-93b7-08e0eeb1e3a7
    // 0 = left, 1 = center, 2 = right, 3 = justified, 4 = distributed(?)
    // justified is not handled at all yet
    var x = (leftMargin + txtWidth - rightMargin) / 2;
    var textAnchor = 'middle';
    switch (horzAlign) {
      case 0:
        x = leftMargin;
        textAnchor = 'start';
        break;
      case 2:
        x = txtWidth - rightMargin;
        textAnchor = 'end';
        break;
    }
    return {
      x: x,
      textAnchor: textAnchor
    };
  }
  function measureShapeText(shape, _ref4) {
    var maxWidth = _ref4.maxWidth;
    var _getAnnotatedText2 = getAnnotatedText(shape),
      mergedText = _getAnnotatedText2.mergedText,
      annotations = _getAnnotatedText2.annotations;
    var wrappedText = wrapTextByWord(mergedText, {
      annotations: annotations,
      maxWidth: maxWidth
    });
    return measureText(wrappedText.text, {}, annotations);
  }

  // CONFIG CONSTANTS
  var DEFAULT_MAX_WIDTH = 1000000;

  // FUNCTIONS
  function HSL(params) {
    var h = params[0] / 239 * 360;
    var s = params[1] / 240;
    var l = params[2] / 240;
    var c = (1 - Math.abs(2 * l - 1)) * s,
      x = c * (1 - Math.abs(h / 60 % 2 - 1)),
      m = l - c / 2,
      r = 0,
      g = 0,
      b = 0;
    if (0 <= h && h < 60) {
      r = c;
      g = x;
      b = 0;
    } else if (60 <= h && h < 120) {
      r = x;
      g = c;
      b = 0;
    } else if (120 <= h && h < 180) {
      r = 0;
      g = c;
      b = x;
    } else if (180 <= h && h < 240) {
      r = 0;
      g = x;
      b = c;
    } else if (240 <= h && h < 300) {
      r = x;
      g = 0;
      b = c;
    } else if (300 <= h && h < 360) {
      r = c;
      g = 0;
      b = x;
    }
    // Having obtained RGB, convert channels to hex
    r = Math.round((r + m) * 255).toString(16);
    g = Math.round((g + m) * 255).toString(16);
    b = Math.round((b + m) * 255).toString(16);

    // Prepend 0s, if necessary
    if (r.length === 1) r = '0' + r;
    if (g.length === 1) g = '0' + g;
    if (b.length === 1) b = '0' + b;
    return '#' + r + g + b;
  }

  // https://docs.microsoft.com/en-us/office/client-developer/visio/textwidth-function
  function TEXTWIDTH(shape, params) {
    var _params = _slicedToArray(params, 2),
      maxWidth = _params[1];
    maxWidth = !isNaN(maxWidth) ? inchesToPixels(maxWidth) : DEFAULT_MAX_WIDTH;
    var _shape$cells = shape.cells,
      _shape$cells$leftMarg = _shape$cells.leftMargin,
      leftMargin = _shape$cells$leftMarg === void 0 ? 0 : _shape$cells$leftMarg,
      _shape$cells$rightMar = _shape$cells.rightMargin,
      rightMargin = _shape$cells$rightMar === void 0 ? 0 : _shape$cells$rightMar;
    var bbox = measureShapeText(shape, {
      maxWidth: maxWidth
    });
    return pixelsToInches(bbox.width + leftMargin + rightMargin);
  }

  // https://docs.microsoft.com/en-us/office/client-developer/visio/textheight-function
  function TEXTHEIGHT(shape, params) {
    var _params2 = _slicedToArray(params, 2),
      maxWidth = _params2[1];
    maxWidth = !isNaN(maxWidth) ? inchesToPixels(maxWidth) : DEFAULT_MAX_WIDTH;
    var _shape$cells2 = shape.cells,
      _shape$cells2$topMarg = _shape$cells2.topMargin,
      topMargin = _shape$cells2$topMarg === void 0 ? 0 : _shape$cells2$topMarg,
      _shape$cells2$bottomM = _shape$cells2.bottomMargin,
      bottomMargin = _shape$cells2$bottomM === void 0 ? 0 : _shape$cells2$bottomM;
    var bbox = measureShapeText(shape, {
      maxWidth: maxWidth
    });
    return pixelsToInches(bbox.height + topMargin + bottomMargin);
  }
  function GUARD(params) {
    return params[0];
  }
  function PAGENUMBER(shape) {
    return shape.page.index + 1;
  }
  function PAGECOUNT(document) {
    var pages = document.pages.pages;
    return pages ? pages.length : 0;
  }

  // Returns the x,y coordinates of a point in the coordinate system of the shape's parent.
  // https://docs.microsoft.com/en-us/office/client-developer/visio/par-function
  // However, as this is already preparsed, the only param we get is the actual value.
  function PAR(params) {
    return params[0];
  }

  // Returns the point represented by the coordinates x and y as a single value.
  // https://docs.microsoft.com/en-us/office/client-developer/visio/pnt-function
  // Although Visio returns both coordinates as a single value, on this stage we already
  // decide which coordinate, X or Y, will be used based on the cell being evaluated.
  // it seems Visio does the same thing under the hood, but it's not clear at what stage.
  // It has been verified that user can use just the PNT function in a formula and the cell
  // would still know which coordinate to use as it's value, so it make sense to filter that
  // on the function stage.
  // TODO: verify if functions other then PAR might require both coordinates
  function PNT(cell, params) {
    var axis = cell.name[cell.name.length - 1];
    switch (axis) {
      case 'X':
        return params[0];
      case 'Y':
        return params[1];
      default:
        // TODO: handle cases when PNT is used as value for a non coordinate type cell
        throw Error('#VALUE');
    }
  }
  function MAX(params) {
    return params.reduce(function (a, b) {
      return Math.max(a, b);
    });
  }
  function ATAN2(params) {
    var _params3 = _slicedToArray(params, 2),
      y = _params3[0],
      x = _params3[1];
    return Math.atan2(y, x);
  }
  function SQRT(params) {
    return Math.sqrt(params[0]);
  }
  function IF(params) {
    return params[0].toString() === '1' ? params[1] : params[2];
  }
  function BITXOR(params) {
    var _params4 = _slicedToArray(params, 2),
      num1 = _params4[0],
      num2 = _params4[1];
    if (isNaN(num1) || isNaN(num2)) {
      throw Error('#VALUE');
    }
    num1 = parseInt(num1);
    num2 = parseInt(num2);
    if (num1 < 0 || num2 < 0) {
      throw Error('#NUM');
    }
    if (Math.floor(num1) !== num1 || Math.floor(num2) !== num2) return '#NUM!';
    if (num1 > 281474976710655 || num2 > 281474976710655) return '#NUM!';
    return ((num1 ^ num2) >>> 0).toString(2);
  }

  var FormulaParser = /*#__PURE__*/function (_Parser) {
    _inherits(FormulaParser, _Parser);
    var _super = _createSuper(FormulaParser);
    function FormulaParser(cell, shape) {
      var _this;
      _classCallCheck(this, FormulaParser);
      _this = _super.call(this);
      _this.registerFunctions(cell, shape);
      _this.registerEvents(shape);
      return _this;
    }

    // todo: it might be better to fork and extend formulaParser package (hot-formula-parser)
    _createClass(FormulaParser, [{
      key: "registerFunctions",
      value: function registerFunctions(cell, shape) {
        this.setFunction('HSL', HSL);
        this.setFunction('PAGENUMBER', PAGENUMBER.bind(this, shape));
        this.setFunction('PAGECOUNT', PAGECOUNT.bind(this, shape.archive.document));
        this.setFunction('GUARD', GUARD);
        this.setFunction('PAR', PAR);
        this.setFunction('PNT', PNT.bind(this, cell));
        this.setFunction('ATAN2', ATAN2);
        this.setFunction('SQRT', SQRT);
        this.setFunction('IF', IF);
        this.setFunction('BITXOR', BITXOR);
        this.setFunction('MAX', MAX);

        // todo: experimental functions
        // these require more work as they return a value that diverts from original pre-calculated value
        this.setFunction('TEXTWIDTH', TEXTWIDTH.bind(this, shape));
        this.setFunction('TEXTHEIGHT', TEXTHEIGHT.bind(this, shape));
      }
    }, {
      key: "registerEvents",
      value: function registerEvents(shape) {
        var _this2 = this;
        this.on('callFunction', function (name) {
          if (!_this2.getFunction(name)) ;
        });
        this.on('callVariable', resolveFormulaVariable.bind(this, shape));
      }
    }]);
    return FormulaParser;
  }(hotFormulaParser.Parser);
  var VisioReservedVariables = {
    THE_TEXT: 'TheText'
  };
  function resolveFormulaVariable(shape, variableName, done) {
    var val;
    switch (variableName) {
      case VisioReservedVariables.THE_TEXT:
        {
          var _getAnnotatedText = getAnnotatedText(shape),
            mergedText = _getAnnotatedText.mergedText;
          return done(mergedText);
        }
    }
    var camelCaseName = variableName.charAt(0).toLowerCase() + variableName.slice(1);
    var variableCell = shape.cells.get(camelCaseName);
    if (!variableCell) {
      variableCell = shape.cells.getParentCell(camelCaseName);
    }
    val = variableCell ? variableCell.value : null;
    if (val || val === 0) {
      done(val);
    } else {
      throw Error('#N/A');
    }
  }

  var defineProperty$8 = objectDefineProperty.f;

  var proxyAccessor = function (Target, Source, key) {
    key in Target || defineProperty$8(Target, key, {
      configurable: true,
      get: function () { return Source[key]; },
      set: function (it) { Source[key] = it; }
    });
  };

  var getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;









  var enforceInternalState = internalState.enforce;





  var MATCH$2 = wellKnownSymbol('match');
  var NativeRegExp = global_1.RegExp;
  var RegExpPrototype$3 = NativeRegExp.prototype;
  var SyntaxError = global_1.SyntaxError;
  var exec$3 = functionUncurryThis(RegExpPrototype$3.exec);
  var charAt$6 = functionUncurryThis(''.charAt);
  var replace$3 = functionUncurryThis(''.replace);
  var stringIndexOf$2 = functionUncurryThis(''.indexOf);
  var stringSlice$6 = functionUncurryThis(''.slice);
  // TODO: Use only proper RegExpIdentifierName
  var IS_NCG = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/;
  var re1 = /a/g;
  var re2 = /a/g;

  // "new" should create a new object, old webkit bug
  var CORRECT_NEW = new NativeRegExp(re1) !== re1;

  var MISSED_STICKY$1 = regexpStickyHelpers.MISSED_STICKY;
  var UNSUPPORTED_Y$3 = regexpStickyHelpers.UNSUPPORTED_Y;

  var BASE_FORCED = descriptors &&
    (!CORRECT_NEW || MISSED_STICKY$1 || regexpUnsupportedDotAll || regexpUnsupportedNcg || fails(function () {
      re2[MATCH$2] = false;
      // RegExp constructor can alter flags and IsRegExp works correct with @@match
      return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
    }));

  var handleDotAll = function (string) {
    var length = string.length;
    var index = 0;
    var result = '';
    var brackets = false;
    var chr;
    for (; index <= length; index++) {
      chr = charAt$6(string, index);
      if (chr === '\\') {
        result += chr + charAt$6(string, ++index);
        continue;
      }
      if (!brackets && chr === '.') {
        result += '[\\s\\S]';
      } else {
        if (chr === '[') {
          brackets = true;
        } else if (chr === ']') {
          brackets = false;
        } result += chr;
      }
    } return result;
  };

  var handleNCG = function (string) {
    var length = string.length;
    var index = 0;
    var result = '';
    var named = [];
    var names = {};
    var brackets = false;
    var ncg = false;
    var groupid = 0;
    var groupname = '';
    var chr;
    for (; index <= length; index++) {
      chr = charAt$6(string, index);
      if (chr === '\\') {
        chr = chr + charAt$6(string, ++index);
      } else if (chr === ']') {
        brackets = false;
      } else if (!brackets) switch (true) {
        case chr === '[':
          brackets = true;
          break;
        case chr === '(':
          if (exec$3(IS_NCG, stringSlice$6(string, index + 1))) {
            index += 2;
            ncg = true;
          }
          result += chr;
          groupid++;
          continue;
        case chr === '>' && ncg:
          if (groupname === '' || hasOwnProperty_1(names, groupname)) {
            throw new SyntaxError('Invalid capture group name');
          }
          names[groupname] = true;
          named[named.length] = [groupname, groupid];
          ncg = false;
          groupname = '';
          continue;
      }
      if (ncg) groupname += chr;
      else result += chr;
    } return [result, named];
  };

  // `RegExp` constructor
  // https://tc39.es/ecma262/#sec-regexp-constructor
  if (isForced_1('RegExp', BASE_FORCED)) {
    var RegExpWrapper = function RegExp(pattern, flags) {
      var thisIsRegExp = objectIsPrototypeOf(RegExpPrototype$3, this);
      var patternIsRegExp = isRegexp(pattern);
      var flagsAreUndefined = flags === undefined;
      var groups = [];
      var rawPattern = pattern;
      var rawFlags, dotAll, sticky, handled, result, state;

      if (!thisIsRegExp && patternIsRegExp && flagsAreUndefined && pattern.constructor === RegExpWrapper) {
        return pattern;
      }

      if (patternIsRegExp || objectIsPrototypeOf(RegExpPrototype$3, pattern)) {
        pattern = pattern.source;
        if (flagsAreUndefined) flags = regexpGetFlags(rawPattern);
      }

      pattern = pattern === undefined ? '' : toString_1(pattern);
      flags = flags === undefined ? '' : toString_1(flags);
      rawPattern = pattern;

      if (regexpUnsupportedDotAll && 'dotAll' in re1) {
        dotAll = !!flags && stringIndexOf$2(flags, 's') > -1;
        if (dotAll) flags = replace$3(flags, /s/g, '');
      }

      rawFlags = flags;

      if (MISSED_STICKY$1 && 'sticky' in re1) {
        sticky = !!flags && stringIndexOf$2(flags, 'y') > -1;
        if (sticky && UNSUPPORTED_Y$3) flags = replace$3(flags, /y/g, '');
      }

      if (regexpUnsupportedNcg) {
        handled = handleNCG(pattern);
        pattern = handled[0];
        groups = handled[1];
      }

      result = inheritIfRequired(NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype$3, RegExpWrapper);

      if (dotAll || sticky || groups.length) {
        state = enforceInternalState(result);
        if (dotAll) {
          state.dotAll = true;
          state.raw = RegExpWrapper(handleDotAll(pattern), rawFlags);
        }
        if (sticky) state.sticky = true;
        if (groups.length) state.groups = groups;
      }

      if (pattern !== rawPattern) try {
        // fails in old engines, but we have no alternatives for unsupported regex syntax
        createNonEnumerableProperty(result, 'source', rawPattern === '' ? '(?:)' : rawPattern);
      } catch (error) { /* empty */ }

      return result;
    };

    for (var keys$2 = getOwnPropertyNames$1(NativeRegExp), index = 0; keys$2.length > index;) {
      proxyAccessor(RegExpWrapper, NativeRegExp, keys$2[index++]);
    }

    RegExpPrototype$3.constructor = RegExpWrapper;
    RegExpWrapper.prototype = RegExpPrototype$3;
    defineBuiltIn(global_1, 'RegExp', RegExpWrapper, { constructor: true });
  }

  // https://tc39.es/ecma262/#sec-get-regexp-@@species
  setSpecies('RegExp');

  // @@match logic
  fixRegexpWellKnownSymbolLogic('match', function (MATCH, nativeMatch, maybeCallNative) {
    return [
      // `String.prototype.match` method
      // https://tc39.es/ecma262/#sec-string.prototype.match
      function match(regexp) {
        var O = requireObjectCoercible(this);
        var matcher = isNullOrUndefined(regexp) ? undefined : getMethod(regexp, MATCH);
        return matcher ? functionCall(matcher, regexp, O) : new RegExp(regexp)[MATCH](toString_1(O));
      },
      // `RegExp.prototype[@@match]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
      function (string) {
        var rx = anObject(this);
        var S = toString_1(string);
        var res = maybeCallNative(nativeMatch, rx, S);

        if (res.done) return res.value;

        if (!rx.global) return regexpExecAbstract(rx, S);

        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
        var A = [];
        var n = 0;
        var result;
        while ((result = regexpExecAbstract(rx, S)) !== null) {
          var matchStr = toString_1(result[0]);
          A[n] = matchStr;
          if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
          n++;
        }
        return n === 0 ? null : A;
      }
    ];
  });

  // `Math.sign` method implementation
  // https://tc39.es/ecma262/#sec-math.sign
  // eslint-disable-next-line es/no-math-sign -- safe
  var mathSign = Math.sign || function sign(x) {
    var n = +x;
    // eslint-disable-next-line no-self-compare -- NaN check
    return n == 0 || n != n ? n : n < 0 ? -1 : 1;
  };

  // `Math.sign` method
  // https://tc39.es/ecma262/#sec-math.sign
  _export({ target: 'Math', stat: true }, {
    sign: mathSign
  });

  function locToParent(point, parent) {
    var _parent$cells = parent.cells,
      _parent$cells$pinX = _parent$cells.pinX,
      pinX = _parent$cells$pinX === void 0 ? 0 : _parent$cells$pinX,
      _parent$cells$pinY = _parent$cells.pinY,
      pinY = _parent$cells$pinY === void 0 ? 0 : _parent$cells$pinY,
      _parent$cells$locPinX = _parent$cells.locPinX,
      locPinX = _parent$cells$locPinX === void 0 ? 0 : _parent$cells$locPinX,
      _parent$cells$locPinY = _parent$cells.locPinY,
      locPinY = _parent$cells$locPinY === void 0 ? 0 : _parent$cells$locPinY,
      _parent$cells$angle = _parent$cells.angle,
      angle = _parent$cells$angle === void 0 ? 0 : _parent$cells$angle;
    var ox = pixelsToInches(pinX - locPinX),
      oy = pixelsToInches(pinY - locPinY);
    var x = point.x,
      y = point.y;
    x += ox;
    y += oy;

    // todo: calculate coordinates of a X\Y flipped parent

    return rotatePointAroundOrigin(ox, oy, x, y, angle);
  }
  function rotatePointAroundOrigin(ox, oy, px, py, angle) {
    var radians = Math.PI / 180 * angle,
      cos = Math.cos(radians),
      sin = Math.sin(radians),
      x = cos * (px - ox) + sin * (py - oy) + ox,
      y = cos * (py - oy) - sin * (px - ox) + oy;
    return {
      x: x,
      y: y
    };
  }

  // Visio formula can be either:
  // 1. undefined - there is no formula declared or inherited for this cell, use pre-calculated value
  // 2. "Inh" - formula is inherited from a matching cell in master or style
  // 3. "No Formula" - inherited formula has been overridden locally for the cell, use pre-calculated value
  // 4. a local formula
  function extractFormula(cell, shape) {
    var formula = cell.formula;
    switch (formula) {
      case 'Inh':
        formula = extractInheritedFormula(cell, shape);
        break;
      case 'No Formula':
        formula = undefined;
        break;
    }
    return formula;
  }

  // https://docs.microsoft.com/en-us/office/client-developer/visio/about-formulas
  // https://docs.microsoft.com/en-us/office/vba/api/visio.shape.mastershape
  function extractInheritedFormula(cell, shape) {
    if (shape.masterShape) {
      var masterShapeCell = shape.masterShape.cells.get(cell.name);
      if (masterShapeCell && masterShapeCell.formula) return masterShapeCell.formula;
    }
    var document = shape.archive.document;
    var pageSheetCell = document.pageSheet.cells.get(cell.name);
    if (pageSheetCell && pageSheetCell.formula) return pageSheetCell.formula;

    // if it failed at this point there might be no formula to inherit
    return null;
  }

  // ENUMS

  // TODO: ref markers will tell us if formula values should be referenced and from where
  // for now we hardcoded Sheet as it's the 90%+ cases in the given projects
  // const ReferenceMarkersEnum = {
  //     PAGE: 'ThePage',
  //     SHEET: 'Sheet'
  // }

  // these are anomaly functions that change the context of the evaluation within the function parameters
  var ContextFunctionsEnum = {
    PAR: 'PAR'
    // LOCTOPAR: 'LOCTOPAR'
  };

  // SECTIONS MAP
  // maps formula section names to their respective keys (aliases) in data object and holds defaults
  var visioSections = {
    Actions: {
      alias: 'Actions',
      "default": 'Menu'
    },
    Char: {
      alias: 'Character'
    },
    Connections: {
      alias: 'Connection'
    },
    Controls: {
      alias: 'Control',
      "default": 'X'
    },
    Fields: {
      alias: 'Field'
    },
    FillGradientStops: {
      alias: 'FillGradient'
    },
    Geometry: {
      alias: 'Geometry',
      indexedName: true
    },
    Hyperlink: {
      alias: 'Hyperlink',
      "default": 'Description'
    },
    Layers: {
      alias: 'Layer'
    },
    LineGradientStops: {
      alias: 'LineGradient'
    },
    Para: {
      alias: 'Paragraph'
    },
    Prop: {
      alias: 'Property',
      "default": 'Value'
    },
    Reviewer: {
      alias: 'Reviewer'
    },
    Scratch: {
      alias: 'Scratch'
    },
    SmartTags: {
      alias: 'ActionTag',
      "default": 'X'
    },
    Tabs: {
      alias: 'Tabs'
    },
    User: {
      alias: 'User',
      "default": 'Value'
    }
  };

  // PATTERNS
  var BasePatterns = {
    singleCharOperator: /([-+^*/&<>=])/,
    multiCharOperator: /(<>|<=|>=)/,
    parentheses: /([()])/,
    singleParentheses: /^[()]$/,
    unitValue: /([-])?([0-9]+)([A-Z]*)/,
    potentialFunc: /^[A-Z]{2,}$/g
  };
  var Patterns = {
    operatorSplit: new RegExp("(?:".concat(BasePatterns.multiCharOperator.source, "|").concat(BasePatterns.singleCharOperator.source, "|").concat(BasePatterns.parentheses.source, ")"), 'gm'),
    skipEvaluation: new RegExp("^".concat(BasePatterns.singleCharOperator.source, "|").concat(BasePatterns.multiCharOperator.source, "|").concat(BasePatterns.parentheses.source, "$")),
    referencedVariable: new RegExp('([\\w]+)\\.([\\d]+)(?:[!])', 'gm')
  };

  // CORE
  function preparseFormula(formula, shape, opt) {
    var localOpt = opt || {};

    // split formula by operators and parentheses, then remove empty results
    var formulaParts = formula.split(Patterns.operatorSplit).filter(function (part) {
      return part;
    });

    // main iteration loop identifies function boundaries and evaluates those as formula parts
    var index = 0,
      evaluatedFormula = [];
    while (index < formulaParts.length) {
      var fPart = formulaParts[index];

      // skip anything that does not require evaluation like operators or parentheses
      if (fPart.match(Patterns.skipEvaluation)) {
        evaluatedFormula.push(fPart);
        index++;
        continue;
      }

      // typically all capital letters part means the part is a function name
      // TODO: check if function exists
      if (fPart.match(BasePatterns.potentialFunc)) {
        // get function parameters
        var functionBounds = getFunctionBounds(formulaParts, index);
        var functionString = functionBounds.join('');

        // check if it's a context changing function
        // do not override a higher level context change
        if (fPart === ContextFunctionsEnum[fPart]) {
          localOpt.ctxType = localOpt.ctxType || ContextFunctionsEnum[fPart];
        }
        var evaluatedPart = preparseFormula(functionString, shape, localOpt);

        // attach function name at the beginning of the evaluated content
        // functionBounds.unshift(fPart);

        // attach function with evaluated contents
        evaluatedFormula.push(fPart + evaluatedPart);

        // skip already evaluated function parts
        index += functionBounds.length + 1;
      } else {
        var _evaluatedPart = evaluateFormulaPart(fPart, shape, localOpt);
        evaluatedFormula.push(_evaluatedPart);
        index++;
      }
    }
    evaluatedFormula = evaluatedFormula.join('');
    return evaluatedFormula;

    // HELPERS

    // based on the current index, searches for the bounds of the function parameters
    function getFunctionBounds(formulaParts, index) {
      var startIndex = index + 1,
        currentIndex = startIndex,
        nesting = 0;
      var enteredBrackets;
      while (currentIndex < formulaParts.length) {
        if (formulaParts[currentIndex].match(BasePatterns.singleParentheses)) {
          nesting += formulaParts[currentIndex] === '(' ? 1 : -1;
          enteredBrackets = true;
        }
        currentIndex++;
        if (enteredBrackets && nesting === 0) break;
      }
      return formulaParts.slice(startIndex, currentIndex);
    }

    // checks if formula part under given index should be
    // evaluated in it's parent context
    // TODO: this should probably just return proper context
    // unused for now but could be a potential cleanup util function
    // function getEvaluationContext(index, formulaParts) {
    //     let currentIndex = index - 1, nesting = 0;
    //     while (currentIndex >= 0) {
    //         const fPart = formulaParts[currentIndex];
    //         if (fPart.match(BasePatterns.singleParentheses)) {
    //             nesting += fPart === '(' ? 1 : -1;
    //         }
    //         if (formulaParts[currentIndex] === 'PAR') {
    //             return {
    //             };
    //         }
    //         currentIndex--;
    //     }
    //     return false;
    // }

    // finds last reference ID in a formula part
    // it seems that if single function parameters reference multiple sheets,
    // it's the last one that should be used to find proper context
    // todo: need to confirm that as it doesn't sound right, even if initial tests proved it to be right
    function getReferenceIdFromFormula(fPart) {
      if (!fPart) {
        debug.log('[getReferenceIdFromFormula] No formula piece provided for id extraction.');
        return null;
      }
      var fParts = fPart.split(Patterns.referencedVariable);
      var index = fParts.length;
      while (index >= 0) {
        if (fParts[index] === 'Sheet') {
          var refId = fParts[index + 1];
          if (Number.isNaN(refId)) {
            debug.log('[getReferenceIdFromFormula] Invalid reference ID', {
              refId: refId
            });
            return null;
          }
          return parseInt(refId);
        }
        index--;
      }
      return null;
    }

    // evaluates a part of a formula into a specific value
    // works under assumption, that the formula part passed
    // is a bottom level part that can be evaluated and
    // it is not another function
    // todo: debug every case of early return of arguments[0]
    function evaluateFormulaPart(fPart, shape, opt) {
      var localOpt = opt || {};
      var ctxShape;
      if (localOpt.ctxType === ContextFunctionsEnum.PAR) {
        var ctxId = getReferenceIdFromFormula(fPart);
        ctxShape = getReferenceShape(shape, ctxId);
      }
      var refId, referenceShape;
      var parsed = fPart.replace(/(?:([a-zA-Z]+)\.([\d]+)!(?:([a-zA-Z]+)([\d]+)?)(?:\.(\w+))?(?:\.(\w+))?)|(?:(Actions|Char|Connections|Controls|Fields|FillGradientStops|Geometry(?=[\d]+)?|HyperLink|Layers|LineGradientStops|Para|Prop|Reviewer|Scratch|SmartTags|Tabs|User)(\d+)?(?:\.(\w+))?(?:\.(\w+))?)/gm, function () {
        // refId will exist if formula is referencing another shape (Sheet), page etc.
        refId = parseInt(arguments[2]);
        var pointer = refId >= 0 ? arguments[3] : arguments[7],
          geometryIndex = refId >= 0 ? arguments[4] : arguments[8],
          sectionIndex = refId >= 0 ? arguments[5] : arguments[9],
          cellName = refId >= 0 ? arguments[6] : arguments[10];
        if (isNaN(refId)) {
          // todo: unhandled reference id, typical case is Props.<Prop> reference - to be handled
          // console.warn('unhandled reference id', {shape, arguments, refId});
          return arguments[0];
        } else {
          referenceShape = getReferenceShape(shape, refId);
        }

        // in case reference shape was not found return original formula so it can fallback to pre-calculated value
        if (!referenceShape) return arguments[0];

        // if pointer is a known section name we treat it as a section
        // otherwise we can resolve it as a cell
        var cell;
        if (visioSections[pointer]) {
          var sectionConf = visioSections[pointer];
          var sectionData = referenceShape.sections.get(sectionConf.alias);
          if (!sectionData) return arguments[0];

          // Visio sections can be named or indexed which dictates how to read the formula
          var row, rowCellName;
          var structureType = VisioSectionStructureType[sectionConf.alias];
          if (structureType === VisioRowStructureType.Named) {
            // resolve section row by name
            row = sectionData[0].rows.find(function (namedRow) {
              return namedRow.name === sectionIndex;
            });

            // resolve cell name or fallback to default of none is given
            rowCellName = cellName || sectionConf["default"];
          } else {
            // resolve section row by indexes
            var rowIndexStr = sectionIndex.match(/\d+/g);
            var rowIndex = rowIndexStr ? parseInt(rowIndexStr[0]) - 1 : 0;
            var _index = geometryIndex >= 0 ? geometryIndex - 1 : 0;
            row = sectionData[_index].rows[rowIndex];

            // cell name is part of the sectionIndex group in the formula
            rowCellName = sectionIndex.match(/[a-zA-Z]+/)[0];
          }
          if (!row) return arguments[0];
          rowCellName = firstLetterLowercase(rowCellName);
          cell = row.cells.get(rowCellName);
          if (!cell) cell = row.cells.getParentCell(rowCellName);
        } else {
          var _cellName = firstLetterLowercase(pointer);
          cell = referenceShape.cells.get(_cellName);
          if (!cell) cell = referenceShape.cells.getParentCell(_cellName);
        }
        return cell ? cell.value : arguments[0];
      });
      if (ctxShape) {
        var pntArguments = parsed.replace(/[()]/gm, '').split(',').map(function (p) {
          var parser = new FormulaParser({}, shape);
          var res = parser.parse(p);
          return res.result;
        });
        var _pntArguments = _slicedToArray(pntArguments, 2),
          x = _pntArguments[0],
          y = _pntArguments[1];
        if (pntArguments.length > 2) {
          debug.log('Potentially invalid PNT arguments', {
            formula: formula,
            pntArguments: pntArguments
          });
        }
        var point = locToParent({
          x: x,
          y: y
        }, ctxShape);
        parsed = "".concat(point.x, ",").concat(point.y);
      }
      return parsed;
    }

    // finds a reference shape based on given ID and source shape
    function getReferenceShape(shape, refId) {
      if (!refId && refId !== 0) {
        debug.log('no reference id provided', {
          shape: shape,
          refId: refId
        });
      }

      // todo: investigate when master is missing, and for what reason
      // possible lead - foreign objects like images
      var referenceMaster = shape.masterShape ? shape.masterShape.master : null;
      var shapeIterator = shape.pageContent.shapes.values();
      var refShape = shapeIterator.next(),
        referenceShape;
      while (!refShape.done && referenceMaster) {
        if (refShape.value.masterId === referenceMaster.id && refShape.value.shapes.has(shape.id)) {
          referenceShape = refShape.value;
          break;
        }
        refShape = shapeIterator.next();
      }

      // TODO: investigate cases when referenceShape was not found
      // if (!referenceShape) debugger;

      return referenceShape;
    }

    // todo: potential helpers
    // function getContext(fPart, shape) {}
    // function formulaPartToCellValue(fPart, shape) {}
    // function getValueInContext(val, context, ctxType) {}
  }

  // to resolve a visio formula we split the process into two stages
  //
  // 1. pre-parsing - takes care of the pieces of formula that the hot-formula-parser
  // does not understand and will fail evaluating. This includes (for now)
  // values with units, context changing functions and references.
  //
  // 2. hot-formula-parser parsing - we let hot-formula-parser take care of calculating
  // formula that after pre-parsing consists mostly of numeric values and functions
  // known to the package.
  function resolveFormula(cell, shape) {
    if (!shape) return cell.value;

    // formula can be local, inherited or empty
    var formula = extractFormula(cell, shape);

    // if there was no formula inherited or it's overridden and cleared, return early the static value
    if (!formula || !shape) {
      return cell.value;
    }

    // as hot-formula-parser handles Excel syntax, the formula has to be prepared for evaluation
    var preparsedFormula = preparseFormula(formula, shape);

    // pre-parsed formula can now be evaluated by hot-formula-parser
    var parser = new FormulaParser(cell, shape);
    var evaluated = parser.parse(preparsedFormula);
    if (evaluated.error) {
      // in case there was some error, we simply return value Visio has pre-calculated
      // and use this error log to track and add missing/faulty functions
      // console.warn(`Could not evaluate formula`, {cell, shape, formula, preparsedFormula, evaluated});
      return cell.value;
    } else {
      var result = evaluated.result.toString();

      // TODO: just for testing, replace with proper solution
      if (valueAliases[result.toLowerCase()]) {
        result = valueAliases[result.toLowerCase()];
      }

      // TODO: DEBUG log
      // console.log('formula evaluated', {cell, original: cell.value, parsed: result, baseFormula: cell.formula, inherited: formula, preparsedFormula, shape});
      return result;
    }
  }

  // todo: need to catch the cases where this happens
  // primitives might need to be casted to Visio specific values
  var valueAliases = {
    'false': '0',
    'true': '1'
  };

  /**
   * {
   *       'fillStyle': [
   *           'fillForegnd',
   *           'fillBkgnd',
   *           'fillPattern',
   *           'fillForegndTrans',
   *           'fillBkgndTrans'
   *       ],
   *       'lineStyle': [
   *           'lineColor',
   *           'lineWeight',
   *           'lineColorTrans',
   *           'linePattern'
   *       ],
   *       'textStyle': [
   *           'leftMargin',
   *           'rightMargin',
   *           'topMargin',
   *           'bottomMargin',
   *           'defaultTabStop',
   *           'textBkgnd',
   *           'textBkgndTrans',
   *           'verticalAlign'
   *       ]
   * }
   *
   *
   * @property {VisioStructurePath} structurePath
   */
  var VisioCellsBase = /*#__PURE__*/function (_VisioObject) {
    _inherits(VisioCellsBase, _VisioObject);
    var _super = _createSuper(VisioCellsBase);
    /**
     * @param init
     */
    function VisioCellsBase() {
      var init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, VisioCellsBase);
      return _super.call(this, init, new Set([VisioAttribute.shape, VisioAttribute.masterShape]));
    }
    _createClass(VisioCellsBase, [{
      key: "setAttributes",
      value: function setAttributes(init) {
        var _this = this;
        this._attributesSet = new Set();

        //TODO miky is duplicity for specific setters
        // but necessary for "position0", "alignment0"...
        Object.keys(init).filter(function (attributeName) {
          return !['archive', 'structurePath'].includes(attributeName);
        }).forEach(function (attributeName) {
          return _this.attributeSet(attributeName);
        });
        _get(_getPrototypeOf(VisioCellsBase.prototype), "setAttributes", this).call(this, init);
      }
    }, {
      key: "attributeSet",
      value: function attributeSet(attributeName) {
        this._attributesSet.add(attributeName);
      }
    }, {
      key: "attributeUnset",
      value: function attributeUnset(attributeName) {
        this._attributesSet["delete"](attributeName);
      }

      /**
       * @returns {Set<VisioCellName>}
       */
    }, {
      key: "attributesSet",
      get: function get() {
        return this._attributesSet;
      }
    }, {
      key: "has",
      value: function has(attributeName) {
        return this.attributesSet.has(attributeName);
      }
    }, {
      key: "hasEvery",
      value: function hasEvery(attributeNamesArray) {
        var _this2 = this;
        return attributeNamesArray.every(function (attributeName) {
          return _this2[attributeName] !== undefined;
        });
      }

      /**
       * @returns {VisioRowType|null}
       */
    }, {
      key: "getRowType",
      value: function getRowType() {
        if (this._rowType) return this._rowType;
        var rowStructurePathFragment = this.structurePath.find(function (structurePathFragment) {
          return structurePathFragment.xsdType === VisioXsdType.Row_Type;
        });
        if (!rowStructurePathFragment) return null;
        return rowStructurePathFragment.type;
      }
    }, {
      key: "setRowType",
      value: function setRowType(rowType) {
        this._rowType = rowType;
      }

      /**
       * @param {Array.<VisioSectionType>} arrayOfSectionTypes
       * @returns {boolean}
       */
    }, {
      key: "isDescendantOfSectionType",
      value: function isDescendantOfSectionType(arrayOfSectionTypes) {
        return this.structurePath.some(function (structurePathFragment) {
          return structurePathFragment.xsdType === VisioXsdType.Section_Type && arrayOfSectionTypes.includes(structurePathFragment.type);
        });
      }
    }, {
      key: "getDefaultCellValue",
      value: function getDefaultCellValue(valueType) {
        // https://docs.microsoft.com/en-us/openspecs/sharepoint_protocols/ms-vsdx/47b8caad-1ea2-4119-84c7-4d9901100b03
        switch (valueType) {
          case VisioValueType.vFormatString:
          case VisioValueType.vLanguageString:
          case VisioValueType.PtgString:
            {
              return '';
            }
          case VisioValueType.PtgColorRGB:
          case VisioValueType.vColor:
            {
              return '#000000';
            }
          case VisioValueType.vFont:
            {
              return '0';
            }
          case VisioValueType.vLength:
          case VisioValueType.vAny:
          case VisioValueType.vAngle:
          case VisioValueType.PtgByte:
          case VisioValueType.PtgInt:
          case VisioValueType.PtgNum:
          case VisioValueType.PtgNumI:
          case VisioValueType.PtgShort:
          case VisioValueType.PtgUnsShort:
          case VisioValueType.PtgDate:
          case VisioValueType.PtgBool:
          case VisioValueType.vScalar:
            {
              return 0;
            }
        }
        debug.log("No default Cell value for ".concat(valueType, " type."));
        return undefined;
      }

      /**
       * One type of value - no need for decision
       *
       * @param {VisioCell} cell
       * @param {VisioValueType} valueType
       * @returns {number|string|boolean|undefined}
       */
    }, {
      key: "resolveCellValue",
      value: function resolveCellValue(cell, valueType) {
        if (!cell) {
          return undefined;
        }

        // TODO: confirm, looks like Visio always sends values in default base unit
        // doesn't matter what is passed as `units` value, i.e. Visio defines position
        // as 2.27 and unit is CM, however what we get in `value` is actually 0.8937008
        // which is 2.27 cm converted to inches
        // it can be based on project settings
        var value = cell.value,
          formula = cell.formula;
        var convertType = getConvertType(valueType, cell);
        if (formula && config.evaluateFormulas) {
          value = resolveFormula(cell, this.shape);
        }
        if (value === 'Themed') {
          var result = themedResolver.call(this, cell, valueType);
          if (result !== null) return result;
        }
        switch (convertType) {
          case VisioConvertType.number:
          case VisioConvertType["byte"]:
            value = asNumber(value);
            break;
          case VisioConvertType.percentage:
            value = asNumber(value) * 100;
            break;
          case VisioConvertType.booleanStrict:
            // boolean strict (only '0' '1' allowed)
            value = asBooleanStrict(value);
            break;
          case VisioConvertType.booleanTriState:
            // boolean strict (only '0' '1' allowed)
            value = asBooleanTristate(value);
            break;
          case VisioConvertType.internalUnitsToPixels:
            if (asNumber(value) === 0) value = 0;else value = stringToPixels(value, VisioUnitType.IN);
            break;
          case VisioConvertType.internalUnitsToDegrees:
            // seems like even when explicit conversion to degrees happens in Visio
            // the resulting XML still gives value in radians, just labeled that the resulting
            // angle should be degrees. This means we can completely omit looking at the `units`
            // attribute and always evaluate the xml values as radians.
            // Leaving all the code in in case we learn something new.
            value = toDegrees(value, {
              units: VisioUnitType.RAD
            });
            break;
          case VisioConvertType.color:
            //TODO miky remove red on PROD
            if (value.includes('#')) ; else if (value === 'Themed') {
              // TODO kumilingus: deal with `Themed` value here or higher
              value = 'red';
            } else {
              var numericValue = asNumber(value);
              var colorFromList = this.archive.document._colors.get(numericValue);
              // if (colorFromList === undefined) debugger;
              value = colorFromList;
            }
            break;
          case VisioConvertType.asIs:
            // noop
            break;
          default:
            debug.log('Unknown VisioConvertType', {
              cell: cell,
              convertType: convertType,
              valueType: valueType
            });
        }
        return value;
      }
    }, {
      key: "themedResolver",
      value: function themedResolver() {
        return null;
      }
    }, {
      key: "getOwnNames",
      value: function getOwnNames() {
        if (!this.hasOwnProperty('_attributesSet')) return [];
        return _toConsumableArray(this._attributesSet.values());
      }
    }, {
      key: "get",
      value: function get(cellName) {
        var cell = firstLetterLowercase(cellName);
        // non getter cell (alignment0, position0...)
        if (this.hasOwnProperty(cell)) {
          return this[cell];
        }
        return this["_".concat(cell)];
      }
    }, {
      key: "set",
      value: function set(cellName, attributes, sheetJXON) {
        if (!sheetJXON) return null;

        // ensure proper naming conventions for local and Visio use
        var name = cellName.charAt(0).toLowerCase() + cellName.slice(1);
        var vName = cellName.charAt(0).toUpperCase() + cellName.slice(1);
        if (VisioCellName[vName] === undefined) {
          debug.log("Cell named \"".concat(vName, "\" is not supported."));
        }
        if (_typeof(attributes) !== 'object' || attributes === null) {
          debug.log('Attributes are required to set a cell.');
        }

        // update attributeSet
        this.attributeSet(name);

        // ensure name attribute is present
        attributes = _objectSpread2(_objectSpread2({}, attributes), {}, {
          name: vName
        });

        // merge original attributes with provided
        var cell = _objectSpread2({}, this["_".concat(name)]);
        Object.keys(attributes).forEach(function (key) {
          if (attributes[key] === undefined) return;
          if (attributes[key] === null) {
            // remove nullified attributes
            delete cell[key];
          } else {
            cell[key] = attributes[key].toString();
          }
        });

        // update cell attribute in case SetCell has been called directly
        this["_".concat(name)] = cell;

        // update jxon
        if (sheetJXON && typeof vName === 'string') {
          var jxonCells = sheetJXON.Cell;
          // test vs lower-cased names as plugin and Visio naming conventions vary
          var index = jxonCells.findIndex(function (jxonCell) {
            return jxonCell.hasOwnProperty(VisioJxonCellKey.Name) && jxonCell[VisioJxonCellKey.Name].toLowerCase() === name.toLowerCase();
          });

          // start empty or use existing cell values
          var jxon = {};
          if (index > -1) {
            jxon = jxonCells[index];
          }

          // assign attributes passed by user, no validation
          Object.keys(cell).forEach(function (key) {
            if (LocalToVisioCellKey[key]) {
              if (attributes[key] === undefined) return;

              // remove null'd value from jxon or assign new value
              if (attributes[key] === null) {
                delete jxon[LocalToVisioCellKey[key]];
              } else {
                jxon[LocalToVisioCellKey[key]] = cell[key];
              }
            }
          });

          // add or replace modified cell
          if (index > -1) {
            jxonCells[index] = jxon;
          } else {
            jxonCells.push(jxon);
          }
        }
        return cell;
      }
    }, {
      key: "remove",
      value: function remove(name, sheetJXON) {
        // update attributeSet
        this.attributeUnset(name);

        // remove from struct
        delete this["_".concat(name)];

        // remove from jxon
        if (sheetJXON && Array.isArray(sheetJXON.Cell)) {
          var jxonCells = sheetJXON.Cell;
          // test vs lower-cased names as plugin and Visio naming conventions vary
          var index = jxonCells.findIndex(function (jxonCell) {
            return jxonCell.hasOwnProperty(VisioJxonCellKey.Name) && jxonCell[VisioJxonCellKey.Name].toLowerCase() === name.toLowerCase();
          });
          if (index > -1) {
            jxonCells.splice(index, 1);
          }
        }
      }
    }, {
      key: "shape",
      get: function get() {
        return this._shape;
      },
      set: function set(shape) {
        this._shape = shape;
      }

      // get masterShape() {
      //     return this.archive.document.masters
      //         .getMasterShapeByStructurePath(this.structurePath);
      // }
    }, {
      key: "jxon",
      get: function get() {
        return this._jxon;
      },
      set: function set(jxon) {
        this._jxon = jxon;
      }
    }, {
      key: "masterShape",
      get: function get() {
        return this._masterShape;
      },
      set: function set(masterShape) {
        this._masterShape = masterShape;
      }

      /**
       * More types of values - need to decide
       *
       * @param {VisioCell} cell
       * @param {Array.<VisioValueType>} valueType
       * @returns {number|string|boolean|undefined}
       */
    }, {
      key: "resolveCellValueByType",
      value: function resolveCellValueByType(cell, valueTypes) {
        // const specialLogic

        return cell.value;
      }

      /**
       * @param {string} attributeName
       * @returns {VisioCell|undefined}
       */
    }, {
      key: "getParentCell",
      value: function getParentCell(attributeName) {
        var parent = this.parent;
        if (parent && parent.cells) return parent.cells.get(attributeName);
        return undefined;
      }

      /**
       * attribute names:
       *    fillForegnd
       *    fillBkgnd
       *    fillPattern
       *    fillForegndTrans
       *    fillBkgndTrans
       *
       * @param {string} attributeName
       * @returns {number|string|boolean|undefined|null}
       */
    }, {
      key: "getStylesheetFillStyleCell",
      value: function getStylesheetFillStyleCell(attributeName) {
        return this.getStylesheetCell(attributeName, VisioAttribute.fillStyle);
      }

      /**
       * attribute names:
       *    lineColor
       *    lineColorTrans
       *    linePattern
       *    lineWeight
       *
       * @param {string} attributeName
       * @returns {number|string|boolean|undefined|null}
       */
    }, {
      key: "getStylesheetLineStyleCell",
      value: function getStylesheetLineStyleCell(attributeName) {
        return this.getStylesheetCell(attributeName, VisioAttribute.lineStyle);
      }

      /**
       * attribute names:
       *     bottomMargin
       *     defaultTabStop
       *     leftMargin
       *     rightMargin
       *     textBkgnd
       *     textBkgndTrans
       *     topMargin
       *     verticalAlign
       *
       * @param {string} attributeName
       * @returns {number|string|boolean|undefined|null}
       */
    }, {
      key: "getStylesheetTextStyleCell",
      value: function getStylesheetTextStyleCell(attributeName) {
        return this.getStylesheetCell(attributeName, VisioAttribute.textStyle);
      }

      /**
       * @param attributeName
       * @param {
       *     VisioAttribute.fillStyle|
       *     VisioAttribute.lineStyle|
       *     VisioAttribute.textStyle
       * } styleType
       */
    }, {
      key: "getStylesheetCell",
      value: function getStylesheetCell(attributeName, styleType) {
        var shape = this.shape;
        var masterShape = this.masterShape;
        if (!shape && !masterShape)
          // cells are used even outside shapes structures
          // where only non-stylesheet attributes make sense
          return undefined;
        var styleSheetIndex;
        if (shape) {
          styleSheetIndex = shape[styleType];
          if (styleSheetIndex === undefined) {
            var shapeMasterShape = this.shape.masterShape;
            if (shapeMasterShape) styleSheetIndex = shapeMasterShape[styleType];
          }
        } else {
          styleSheetIndex = masterShape[styleType];
        }
        if (styleSheetIndex === undefined) {
          debug.log('styleSheetIndex undefined');
          //this.archive.document.documentSettings.defaultStylesheet
          return undefined;
        }
        var styleSheets = this.archive.document.styleSheets;
        return getAttributeValueFromStylesheet(styleSheets, styleSheetIndex, styleType, attributeName);
      }
    }, {
      key: "getSetValues",
      value: function getSetValues() {
        var _this3 = this;
        var cellsObject = {};
        this.attributesSet.forEach(function (attributeName) {
          return cellsObject[attributeName] = _this3[attributeName];
        });
        return cellsObject;
      }
    }, {
      key: "getSetValuesMaster",
      value: function getSetValuesMaster() {
        var masterShape = this.shape.masterShape;
        if (!masterShape) return null;
        var path = sectionAndRowHappyCase(this.structurePath);
        if (!path.section || !path.row) return null;
        var rows = masterShape.sections.get(path.section.type)[path.section.index].rows;
        var row = rows.find(function (row) {
          return row.index === path.row.index;
        });
        if (!row) return null;
        var cells = row.cells;
        if (!cells) return null;
        if (cells === this) return 'exactly same';
        return cells.getSetValues();
      }
    }, {
      key: "directValues",
      get: function get() {
        return this.debugGatherValues(_toConsumableArray(this.attributesSet));
      }

      /**
       * @returns {VisioCells}
       */
    }, {
      key: "clone",
      value: function clone() {
        var _this4 = this;
        var structurePath = this.structurePath.slice();
        structurePath.unshift({
          jxonType: 'clone'
        });
        var clone = new this.constructor({
          archive: this.archive,
          structurePath: structurePath
        });
        this.attributesSet.forEach(function (attributeName) {
          var cell = _this4.get(attributeName);
          clone[attributeName] = _objectSpread2({}, cell);
          clone.attributeSet(attributeName);
        });
        if (this.shape) clone.shape = this.shape;
        if (this.masterShape) clone.masterShape = this.masterShape;
        return clone;
      }
    }, {
      key: "debug",
      get: function get() {
        var result = {
          owner: this.owner,
          parent: this.parent,
          directValues: this.debugGatherValues(_toConsumableArray(this.attributesSet))
        };
        if (this.shape) {
          result.ownerShape = this.shape;
        }
        if (this.parent) {
          result.extendedValues = this.debugGatherValues([].concat(_toConsumableArray(this.attributesSet), _toConsumableArray(this.parent.cells.attributesSet)));
        }
        if (this.masterShape) {
          result.ownerMasterShape = this.masterShape;
        }
        result.stylesheetFill = this.debugGatherValues(['fillForegnd', 'fillBkgnd', 'fillPattern', 'fillForegndTrans', 'fillBkgndTrans']);
        result.stylesheetLine = this.debugGatherValues(['lineColor', 'lineColorTrans', 'linePattern', 'lineWeight']);
        result.stylesheetText = this.debugGatherValues(['bottomMargin', 'defaultTabStop', 'leftMargin', 'rightMargin', 'textBkgnd', 'textBkgndTrans', 'topMargin', 'verticalAlign']);
        result.structurePath = this.structurePath;
        return result;
      }
    }, {
      key: "debugGatherValues",
      value: function debugGatherValues(attributeNamesArray) {
        var _this5 = this;
        return attributeNamesArray.reduce(function (values, attributeName) {
          values[attributeName] = _this5[attributeName];
          return values;
        }, {});
      }
    }]);
    return VisioCellsBase;
  }(VisioObject);

  // autogenerated (server convertDocs.mjs, page convertDocs.html)

  /**
   * @property _shape
   *
   * @property _a
   * @property _action
   * @property _active
   * @property _addMarkup
   * @property _address
   * @property _alignBottom
   * @property _alignCenter
   * @property _alignLeft
   * @property _alignment
   * @property _alignMiddle
   * @property _alignRight
   * @property _alignTop
   * @property _angle
   * @property _asianFont
   * @property _autoGen
   * @property _avenueSizeX
   * @property _avenueSizeY
   * @property _avoidPageBreaks
   * @property _b
   * @property _beginArrow
   * @property _beginArrowSize
   * @property _beginGroup
   * @property _beginX
   * @property _beginY
   * @property _begTrigger
   * @property _bevelBottomHeight
   * @property _bevelBottomType
   * @property _bevelBottomWidth
   * @property _bevelContourColor
   * @property _bevelContourSize
   * @property _bevelDepthColor
   * @property _bevelDepthSize
   * @property _bevelLightingAngle
   * @property _bevelLightingType
   * @property _bevelMaterialType
   * @property _bevelTopHeight
   * @property _bevelTopType
   * @property _bevelTopWidth
   * @property _blockSizeX
   * @property _blockSizeY
   * @property _blur
   * @property _bottomMargin
   * @property _brightness
   * @property _bullet
   * @property _bulletFont
   * @property _bulletFontSize
   * @property _bulletStr
   * @property _buttonFace
   * @property _c
   * @property _calendar
   * @property _canGlue
   * @property _uppercase
   * @property _centerX
   * @property _centerY
   * @property _checked
   * @property _clippingPath
   * @property _color
   * @property _colorSchemeIndex
   * @property _colorTrans
   * @property _comment
   * @property _complexScriptFont
   * @property _complexScriptSize
   * @property _compoundType
   * @property _conFixedCode
   * @property _conLineJumpCode
   * @property _conLineJumpDirX
   * @property _conLineJumpDirY
   * @property _conLineJumpStyle
   * @property _conLineRouteExt
   * @property _connectorSchemeIndex
   * @property _contrast
   * @property _copyright
   * @property _ctrlAsInput
   * @property _currentIndex
   * @property _d
   * @property _dataLinked
   * @property _dblUnderline
   * @property _default
   * @property _defaultTabStop
   * @property _denoise
   * @property _description
   * @property _dirX
   * @property _dirY
   * @property _disabled
   * @property _displayLevel
   * @property _displayMode
   * @property _distanceFromGround
   * @property _docLangID
   * @property _docLockDuplicatePage
   * @property _docLockReplace
   * @property _dontMoveChildren
   * @property _doubleStrikethrough
   * @property _drawingResizeType
   * @property _drawingScale
   * @property _drawingScaleType
   * @property _drawingSizeType
   * @property _dropOnPageScale
   * @property _dynamicsOff
   * @property _dynFeedback
   * @property _e
   * @property _effectSchemeIndex
   * @property _embellishmentIndex
   * @property _enableFillProps
   * @property _enableGrid
   * @property _enableLineProps
   * @property _enableTextProps
   * @property _endArrow
   * @property _endArrowSize
   * @property _endTrigger
   * @property _endX
   * @property _endY
   * @property _eventDblClick
   * @property _eventDrop
   * @property _eventMultiDrop
   * @property _eventXFMod
   * @property _extraInfo
   * @property _fillBkgnd
   * @property _fillBkgndTrans
   * @property _fillForegnd
   * @property _fillForegndTrans
   * @property _fillGradientAngle
   * @property _fillGradientDir
   * @property _fillGradientEnabled
   * @property _fillPattern
   * @property _flags
   * @property _flipX
   * @property _flipY
   * @property _flyoutChild
   * @property _font
   * @property _fontScale
   * @property _fontSchemeIndex
   * @property _format
   * @property _frame
   * @property _gamma
   * @property _glowColor
   * @property _glowColorTrans
   * @property _glowSize
   * @property _glue
   * @property _glueType
   * @property _gradientStopColor
   * @property _gradientStopColorTrans
   * @property _gradientStopPosition
   * @property _height
   * @property _helpTopic
   * @property _hideForApply
   * @property _hideText
   * @property _horzAlign
   * @property _imgHeight
   * @property _imgOffsetX
   * @property _imgOffsetY
   * @property _imgWidth
   * @property _indFirst
   * @property _indLeft
   * @property _indRight
   * @property _inhibitSnap
   * @property _initials
   * @property _invisible
   * @property _isDropSource
   * @property _isDropTarget
   * @property _isSnapTarget
   * @property _isTextEditTarget
   * @property _keepTextFlat
   * @property _label
   * @property _langID
   * @property _layerMember
   * @property _leftMargin
   * @property _letterspace
   * @property _lineAdjustFrom
   * @property _lineAdjustTo
   * @property _lineCap
   * @property _lineColor
   * @property _lineColorTrans
   * @property _lineGradientAngle
   * @property _lineGradientDir
   * @property _lineGradientEnabled
   * @property _lineJumpCode
   * @property _lineJumpFactorX
   * @property _lineJumpFactorY
   * @property _lineJumpStyle
   * @property _linePattern
   * @property _lineRouteExt
   * @property _lineToLineX
   * @property _lineToLineY
   * @property _lineToNodeX
   * @property _lineToNodeY
   * @property _lineWeight
   * @property _localizeMerge
   * @property _lock
   * @property _lockAspect
   * @property _lockBegin
   * @property _lockCalcWH
   * @property _lockCrop
   * @property _lockCustProp
   * @property _lockDelete
   * @property _lockEnd
   * @property _lockFormat
   * @property _lockFromGroupFormat
   * @property _lockGroup
   * @property _lockHeight
   * @property _lockMoveX
   * @property _lockMoveY
   * @property _lockPreview
   * @property _lockReplace
   * @property _lockRotate
   * @property _lockSelect
   * @property _lockTextEdit
   * @property _lockThemeColors
   * @property _lockThemeConnectors
   * @property _lockThemeEffects
   * @property _lockThemeFonts
   * @property _lockThemeIndex
   * @property _lockVariation
   * @property _lockVtxEdit
   * @property _lockWidth
   * @property _locPinX
   * @property _locPinY
   * @property _menu
   * @property _name
   * @property _nameUniv
   * @property _newWindow
   * @property _noAlignBox
   * @property _noCoauth
   * @property _noCtlHandles
   * @property _noFill
   * @property _noLine
   * @property _noLiveDynamics
   * @property _nonPrinting
   * @property _noObjHandles
   * @property _noProofing
   * @property _noQuickDrag
   * @property _noShow
   * @property _noSnap
   * @property _objectKind
   * @property _objType
   * @property _onPage
   * @property _outputFormat
   * @property _overline
   * @property _pageBottomMargin
   * @property _pageHeight
   * @property _pageLeftMargin
   * @property _pageLineJumpDirX
   * @property _pageLineJumpDirY
   * @property _pageLockDuplicate
   * @property _pageLockReplace
   * @property _pageRightMargin
   * @property _pageScale
   * @property _pageShapeSplit
   * @property _pagesX
   * @property _pagesY
   * @property _pageTopMargin
   * @property _pageWidth
   * @property _paperKind
   * @property _paperSource
   * @property _perspective
   * @property _pinX
   * @property _pinY
   * @property _placeDepth
   * @property _placeFlip
   * @property _placeStyle
   * @property _plowCode
   * @property _pos
   * @property _position
   * @property _previewQuality
   * @property _previewScope
   * @property _print
   * @property _printGrid
   * @property _printPageOrientation
   * @property _prompt
   * @property _quickStyleEffectsMatrix
   * @property _quickStyleFillColor
   * @property _quickStyleFillMatrix
   * @property _quickStyleFontColor
   * @property _quickStyleFontMatrix
   * @property _quickStyleLineColor
   * @property _quickStyleLineMatrix
   * @property _quickStyleShadowColor
   * @property _quickStyleType
   * @property _quickStyleVariation
   * @property _readOnly
   * @property _reflectionBlur
   * @property _reflectionDist
   * @property _reflectionSize
   * @property _reflectionTrans
   * @property _relationships
   * @property _replaceCopyCells
   * @property _replaceLockFormat
   * @property _replaceLockShapeData
   * @property _replaceLockText
   * @property _resizeMode
   * @property _resizePage
   * @property _reviewerID
   * @property _rightMargin
   * @property _rotateGradientWithShape
   * @property _rotationType
   * @property _rotationXAngle
   * @property _rotationYAngle
   * @property _rotationZAngle
   * @property _rounding
   * @property _routeStyle
   * @property _scaleX
   * @property _scaleY
   * @property _selectMode
   * @property _shapeFixedCode
   * @property _shapeKeywords
   * @property _shapePermeablePlace
   * @property _shapePermeableX
   * @property _shapePermeableY
   * @property _shapePlaceFlip
   * @property _shapePlaceStyle
   * @property _shapePlowCode
   * @property _shapeRouteStyle
   * @property _shapeShdwBlur
   * @property _shapeShdwObliqueAngle
   * @property _shapeShdwOffsetX
   * @property _shapeShdwOffsetY
   * @property _shapeShdwScaleFactor
   * @property _shapeShdwShow
   * @property _shapeShdwType
   * @property _shapeSplit
   * @property _shapeSplittable
   * @property _sharpen
   * @property _shdwForegnd
   * @property _shdwForegndTrans
   * @property _shdwObliqueAngle
   * @property _shdwOffsetX
   * @property _shdwOffsetY
   * @property _shdwPattern
   * @property _shdwScaleFactor
   * @property _shdwType
   * @property _size
   * @property _sketchAmount
   * @property _sketchEnabled
   * @property _sketchFillChange
   * @property _sketchLineChange
   * @property _sketchLineWeight
   * @property _sketchSeed
   * @property _snap
   * @property _softEdgesSize
   * @property _sortKey
   * @property _spAfter
   * @property _spBefore
   * @property _spLine
   * @property _status
   * @property _strikethru
   * @property _style
   * @property _subAddress
   * @property _tagName
   * @property _textBkgnd
   * @property _textBkgndTrans
   * @property _textDirection
   * @property _textPosAfterBullet
   * @property _theData
   * @property _themeIndex
   * @property _theText
   * @property _topMargin
   * @property _transparency
   * @property _txtAngle
   * @property _txtHeight
   * @property _txtLocPinX
   * @property _txtLocPinY
   * @property _txtPinX
   * @property _txtPinY
   * @property _txtWidth
   * @property _type
   * @property _uICat
   * @property _uICod
   * @property _uIFmt
   * @property _uIVisibility
   * @property _updateAlignBox
   * @property _useGroupGradient
   * @property _value
   * @property _variationColorIndex
   * @property _variationStyleIndex
   * @property _verify
   * @property _verticalAlign
   * @property _viewMarkup
   * @property _visible
   * @property _walkPreference
   * @property _width
   * @property _x
   * @property _xCon
   * @property _xDyn
   * @property _xGridDensity
   * @property _xGridOrigin
   * @property _xGridSpacing
   * @property _xJustify
   * @property _xRulerDensity
   * @property _xRulerOrigin
   * @property _y
   * @property _yCon
   * @property _yDyn
   * @property _yGridDensity
   * @property _yGridOrigin
   * @property _yGridSpacing
   * @property _yJustify
   * @property _yRulerDensity
   * @property _yRulerOrigin
   */
  var VisioCells = /*#__PURE__*/function (_VisioCellsBase) {
    _inherits(VisioCells, _VisioCellsBase);
    var _super = _createSuper(VisioCells);
    function VisioCells() {
      _classCallCheck(this, VisioCells);
      return _super.apply(this, arguments);
    }
    _createClass(VisioCells, [{
      key: "a",
      get:
      /**
       * 2.4.4.1 A
       * @see {http://localhost/MS-VSDX.pdf#page=159}
       *
       * If A has an ArcTo, Ellipse, EllipticalArcTo, or InfiniteLine Row_Type parent
       * element, it is a vLength that specifies geometry path information according to
       * the Row_Type.
       *
       * If A has a NURBSTo, RelCubBezTo, RelEllipticalArcTo, RelQuadBezTo, SplineStart,
       * or SplineKnot Row_Type parent element, it is a vScalar that specifies geometry
       * path information according to the Row_Type.
       *
       * If A has a PolylineTo parent element, it is a formula expression that MUST
       * contain a polyline function.
       *
       * If A is a descendant element of a Scratch Section_Type element, it is a vAny that
       * is used during formula evaluation only.
       */
      function get() {
        var visioType;
        switch (this.getRowType()) {
          case VisioRowType.ArcTo:
          case VisioRowType.Ellipse:
          case VisioRowType.EllipticalArcTo:
          case VisioRowType.InfiniteLine:
            visioType = VisioValueType.vLength;
            break;
          case VisioRowType.NURBSTo:
          case VisioRowType.RelCubBezTo:
          case VisioRowType.RelEllipticalArcTo:
          case VisioRowType.RelQuadBezTo:
          case VisioRowType.SplineStart:
          case VisioRowType.SplineKnot:
            visioType = VisioValueType.vScalar;
            break;
          case VisioRowType.PolylineTo:
            visioType = VisioValueType.vAny;
            break;
          default:
            debug.log('Incorrect cell type', {
              attributeName: 'a',
              cells: this
            });
        }
        var cell = this._a;
        if (cell === undefined) cell = this.getParentCell('a');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.2 Action
       * @see {http://localhost/MS-VSDX.pdf#page=159}
       * @param {VisioCell} action
       */,
      set:
      // autogenerated (server convertDocs.mjs, page convertDocs.html)

      /**
       * 2.4.4.1 A
       * @see {http://localhost/MS-VSDX.pdf#page=159}
       * @param {VisioCell} a
       */
      function set(a) {
        this.attributeSet('a');
        this._a = a;
      }
    }, {
      key: "action",
      get:
      /**
       * 2.4.4.2 Action
       * @see {http://localhost/MS-VSDX.pdf#page=159}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._action;
        if (cell === undefined) cell = this.getParentCell('action');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.3 Active
       * @see {http://localhost/MS-VSDX.pdf#page=160}
       * @param {VisioCell} active
       */,
      set: function set(action) {
        this.attributeSet('action');
        this._action = action;
      }
    }, {
      key: "active",
      get:
      /**
       * 2.4.4.3 Active
       * @see {http://localhost/MS-VSDX.pdf#page=160}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._active;
        if (cell === undefined) cell = this.getParentCell('active');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.4 AddMarkup
       * @see {http://localhost/MS-VSDX.pdf#page=160}
       * @param {VisioCell} addMarkup
       */,
      set: function set(active) {
        this.attributeSet('active');
        this._active = active;
      }
    }, {
      key: "addMarkup",
      get:
      /**
       * 2.4.4.4 AddMarkup
       * @see {http://localhost/MS-VSDX.pdf#page=160}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._addMarkup;
        if (cell === undefined) cell = this.getParentCell('addMarkup');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.5 Address
       * @see {http://localhost/MS-VSDX.pdf#page=160}
       * @param {VisioCell} address
       */,
      set: function set(addMarkup) {
        this.attributeSet('addMarkup');
        this._addMarkup = addMarkup;
      }
    }, {
      key: "address",
      get:
      /**
       * 2.4.4.5 Address
       * @see {http://localhost/MS-VSDX.pdf#page=160}
       */
      function get() {
        var visioType = VisioValueType.PtgString;
        var cell = this._address;
        if (cell === undefined) cell = this.getParentCell('address');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.6 AlignBottom
       * @see {http://localhost/MS-VSDX.pdf#page=160}
       * @param {VisioCell} alignBottom
       */,
      set: function set(address) {
        this.attributeSet('address');
        this._address = address;
      }
    }, {
      key: "alignBottom",
      get:
      /**
       * 2.4.4.6 AlignBottom
       * @see {http://localhost/MS-VSDX.pdf#page=160}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._alignBottom;
        if (cell === undefined) cell = this.getParentCell('alignBottom');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.7 AlignCenter
       * @see {http://localhost/MS-VSDX.pdf#page=160}
       * @param {VisioCell} alignCenter
       */,
      set: function set(alignBottom) {
        this.attributeSet('alignBottom');
        this._alignBottom = alignBottom;
      }
    }, {
      key: "alignCenter",
      get:
      /**
       * 2.4.4.7 AlignCenter
       * @see {http://localhost/MS-VSDX.pdf#page=160}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._alignCenter;
        if (cell === undefined) cell = this.getParentCell('alignCenter');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.8 AlignLeft
       * @see {http://localhost/MS-VSDX.pdf#page=160}
       * @param {VisioCell} alignLeft
       */,
      set: function set(alignCenter) {
        this.attributeSet('alignCenter');
        this._alignCenter = alignCenter;
      }
    }, {
      key: "alignLeft",
      get:
      /**
       * 2.4.4.8 AlignLeft
       * @see {http://localhost/MS-VSDX.pdf#page=160}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._alignLeft;
        if (cell === undefined) cell = this.getParentCell('alignLeft');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.9 Alignment
       * @see {http://localhost/MS-VSDX.pdf#page=160}
       * @param {VisioCell} alignment
       */,
      set: function set(alignLeft) {
        this.attributeSet('alignLeft');
        this._alignLeft = alignLeft;
      }
    }, {
      key: "alignment",
      get:
      /**
       * 2.4.4.9 Alignment
       * @see {http://localhost/MS-VSDX.pdf#page=160}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._alignment;
        if (cell === undefined) cell = this.getParentCell('alignment');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.10 AlignMiddle
       * @see {http://localhost/MS-VSDX.pdf#page=161}
       * @param {VisioCell} alignMiddle
       */,
      set: function set(alignment) {
        this.attributeSet('alignment');
        this._alignment = alignment;
      }
    }, {
      key: "alignMiddle",
      get:
      /**
       * 2.4.4.10 AlignMiddle
       * @see {http://localhost/MS-VSDX.pdf#page=161}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._alignMiddle;
        if (cell === undefined) cell = this.getParentCell('alignMiddle');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.11 AlignRight
       * @see {http://localhost/MS-VSDX.pdf#page=161}
       * @param {VisioCell} alignRight
       */,
      set: function set(alignMiddle) {
        this.attributeSet('alignMiddle');
        this._alignMiddle = alignMiddle;
      }
    }, {
      key: "alignRight",
      get:
      /**
       * 2.4.4.11 AlignRight
       * @see {http://localhost/MS-VSDX.pdf#page=161}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._alignRight;
        if (cell === undefined) cell = this.getParentCell('alignRight');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.12 AlignTop
       * @see {http://localhost/MS-VSDX.pdf#page=161}
       * @param {VisioCell} alignTop
       */,
      set: function set(alignRight) {
        this.attributeSet('alignRight');
        this._alignRight = alignRight;
      }
    }, {
      key: "alignTop",
      get:
      /**
       * 2.4.4.12 AlignTop
       * @see {http://localhost/MS-VSDX.pdf#page=161}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._alignTop;
        if (cell === undefined) cell = this.getParentCell('alignTop');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.13 Angle
       * @see {http://localhost/MS-VSDX.pdf#page=161}
       * @param {VisioCell} angle
       */,
      set: function set(alignTop) {
        this.attributeSet('alignTop');
        this._alignTop = alignTop;
      }
    }, {
      key: "angle",
      get:
      /**
       * 2.4.4.13 Angle
       * @see {http://localhost/MS-VSDX.pdf#page=161}
       *
       * The Angle cell is a vAngle or vScalar custom token grouping that specifies the
       * angle of rotation of a shape. The value is defined in relation to the coordinate
       * system of the shapeâs parent. It MUST have a ShapeSheet_Type parent element.
       *
       * If the structure is a vScalar, the value MUST be expressed as an
       * angleInternalUnitNumber custom internal unit number. Increasing numbers indicate
       * counterclockwise rotation.
       */
      function get() {
        var cell = this._angle;
        if (cell === undefined) cell = this.getParentCell('angle');
        var visioType = VisioValueType.vAngle;

        // VisioValueType.vAngle,
        if (cell && cell.units && cell.units !== VisioUnitType.DEG && cell.value !== '0') {
          debug.log('vAngle unclear');
        }
        if (cell === undefined) return this.getDefaultCellValue(visioType);
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.14 AsianFont
       * @see {http://localhost/MS-VSDX.pdf#page=161}
       * @param {VisioCell} asianFont
       */,
      set: function set(angle) {
        this.attributeSet('angle');
        this._angle = angle;
      }
    }, {
      key: "asianFont",
      get:
      /**
       * 2.4.4.14 AsianFont
       * @see {http://localhost/MS-VSDX.pdf#page=161}
       */
      function get() {
        var visioType = VisioValueType.vFont;
        var cell = this._asianFont;
        if (cell === undefined) cell = this.getParentCell('asianFont');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.15 AutoGen
       * @see {http://localhost/MS-VSDX.pdf#page=161}
       * @param {VisioCell} autoGen
       */,
      set: function set(asianFont) {
        this.attributeSet('asianFont');
        this._asianFont = asianFont;
      }
    }, {
      key: "autoGen",
      get:
      /**
       * 2.4.4.15 AutoGen
       * @see {http://localhost/MS-VSDX.pdf#page=161}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._autoGen;
        if (cell === undefined) cell = this.getParentCell('autoGen');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.16 AvenueSizeX
       * @see {http://localhost/MS-VSDX.pdf#page=161}
       * @param {VisioCell} avenueSizeX
       */,
      set: function set(autoGen) {
        this.attributeSet('autoGen');
        this._autoGen = autoGen;
      }
    }, {
      key: "avenueSizeX",
      get:
      /**
       * 2.4.4.16 AvenueSizeX
       * @see {http://localhost/MS-VSDX.pdf#page=161}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._avenueSizeX;
        if (cell === undefined) cell = this.getParentCell('avenueSizeX');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.17 AvenueSizeY
       * @see {http://localhost/MS-VSDX.pdf#page=161}
       * @param {VisioCell} avenueSizeY
       */,
      set: function set(avenueSizeX) {
        this.attributeSet('avenueSizeX');
        this._avenueSizeX = avenueSizeX;
      }
    }, {
      key: "avenueSizeY",
      get:
      /**
       * 2.4.4.17 AvenueSizeY
       * @see {http://localhost/MS-VSDX.pdf#page=161}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._avenueSizeY;
        if (cell === undefined) cell = this.getParentCell('avenueSizeY');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.18 AvoidPageBreaks
       * @see {http://localhost/MS-VSDX.pdf#page=161}
       * @param {VisioCell} avoidPageBreaks
       */,
      set: function set(avenueSizeY) {
        this.attributeSet('avenueSizeY');
        this._avenueSizeY = avenueSizeY;
      }
    }, {
      key: "avoidPageBreaks",
      get:
      /**
       * 2.4.4.18 AvoidPageBreaks
       * @see {http://localhost/MS-VSDX.pdf#page=161}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._avoidPageBreaks;
        if (cell === undefined) cell = this.getParentCell('avoidPageBreaks');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.19 B
       * @see {http://localhost/MS-VSDX.pdf#page=162}
       * @param {VisioCell} b
       */,
      set: function set(avoidPageBreaks) {
        this.attributeSet('avoidPageBreaks');
        this._avoidPageBreaks = avoidPageBreaks;
      }
    }, {
      key: "b",
      get:
      /**
       * 2.4.4.19 B
       * @see {http://localhost/MS-VSDX.pdf#page=162}
       */
      function get() {
        var visioType;
        if (this.isDescendantOfSectionType([VisioSectionType.Scratch])) visioType = VisioValueType.vAny;else switch (this.getRowType()) {
          case VisioRowType.Ellipse:
          case VisioRowType.EllipticalArcTo:
          case VisioRowType.InfiniteLine:
            visioType = VisioValueType.vLength;
            break;
          case VisioRowType.NURBSTo:
          case VisioRowType.RelCubBezTo:
          case VisioRowType.RelEllipticalArcTo:
          case VisioRowType.RelQuadBezTo:
          case VisioRowType.SplineStart:
            visioType = VisioValueType.vScalar;
            break;
          default:
            debug.log('Incorrect cell type', {
              attributeName: 'a',
              cells: this
            });
        }
        var cell = this._b;
        if (cell === undefined) cell = this.getParentCell('b');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.20 BeginArrow
       * @see {http://localhost/MS-VSDX.pdf#page=162}
       * @param {VisioCell} beginArrow
       */,
      set: function set(b) {
        this.attributeSet('b');
        this._b = b;
      }
    }, {
      key: "beginArrow",
      get:
      /**
       * 2.4.4.20 BeginArrow
       * @see {http://localhost/MS-VSDX.pdf#page=162}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._beginArrow;
        if (cell === undefined) cell = this.getParentCell('beginArrow');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.21 BeginArrowSize
       * @see {http://localhost/MS-VSDX.pdf#page=164}
       * @param {VisioCell} beginArrowSize
       */,
      set: function set(beginArrow) {
        this.attributeSet('beginArrow');
        this._beginArrow = beginArrow;
      }
    }, {
      key: "beginArrowSize",
      get:
      /**
       * 2.4.4.21 BeginArrowSize
       * @see {http://localhost/MS-VSDX.pdf#page=164}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._beginArrowSize;
        if (cell === undefined) cell = this.getParentCell('beginArrowSize');

        // default size
        if (cell === undefined) return 2;
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.22 BeginGroup
       * @see {http://localhost/MS-VSDX.pdf#page=165}
       * @param {VisioCell} beginGroup
       */,
      set: function set(beginArrowSize) {
        this.attributeSet('beginArrowSize');
        this._beginArrowSize = beginArrowSize;
      }
    }, {
      key: "beginGroup",
      get:
      /**
       * 2.4.4.22 BeginGroup
       * @see {http://localhost/MS-VSDX.pdf#page=165}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._beginGroup;
        if (cell === undefined) cell = this.getParentCell('beginGroup');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.23 BeginX
       * @see {http://localhost/MS-VSDX.pdf#page=165}
       * @param {VisioCell} beginX
       */,
      set: function set(beginGroup) {
        this.attributeSet('beginGroup');
        this._beginGroup = beginGroup;
      }
    }, {
      key: "beginX",
      get:
      /**
       * 2.4.4.23 BeginX
       * @see {http://localhost/MS-VSDX.pdf#page=165}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._beginX;
        if (cell === undefined) cell = this.getParentCell('beginX');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.24 BeginY
       * @see {http://localhost/MS-VSDX.pdf#page=165}
       * @param {VisioCell} beginY
       */,
      set: function set(beginX) {
        this.attributeSet('beginX');
        this._beginX = beginX;
      }
    }, {
      key: "beginY",
      get:
      /**
       * 2.4.4.24 BeginY
       * @see {http://localhost/MS-VSDX.pdf#page=165}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._beginY;
        if (cell === undefined) cell = this.getParentCell('beginY');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.25 BegTrigger
       * @see {http://localhost/MS-VSDX.pdf#page=165}
       * @param {VisioCell} begTrigger
       */,
      set: function set(beginY) {
        this.attributeSet('beginY');
        this._beginY = beginY;
      }
    }, {
      key: "begTrigger",
      get:
      /**
       * 2.4.4.25 BegTrigger
       * @see {http://localhost/MS-VSDX.pdf#page=165}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._begTrigger;
        if (cell === undefined) cell = this.getParentCell('begTrigger');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.26 BevelBottomHeight
       * @see {http://localhost/MS-VSDX.pdf#page=165}
       * @param {VisioCell} bevelBottomHeight
       */,
      set: function set(begTrigger) {
        this.attributeSet('begTrigger');
        this._begTrigger = begTrigger;
      }
    }, {
      key: "bevelBottomHeight",
      get:
      /**
       * 2.4.4.26 BevelBottomHeight
       * @see {http://localhost/MS-VSDX.pdf#page=165}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._bevelBottomHeight;
        if (cell === undefined) cell = this.getParentCell('bevelBottomHeight');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.27 BevelBottomType
       * @see {http://localhost/MS-VSDX.pdf#page=165}
       * @param {VisioCell} bevelBottomType
       */,
      set: function set(bevelBottomHeight) {
        this.attributeSet('bevelBottomHeight');
        this._bevelBottomHeight = bevelBottomHeight;
      }
    }, {
      key: "bevelBottomType",
      get:
      /**
       * 2.4.4.27 BevelBottomType
       * @see {http://localhost/MS-VSDX.pdf#page=165}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._bevelBottomType;
        if (cell === undefined) cell = this.getParentCell('bevelBottomType');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.28 BevelBottomWidth
       * @see {http://localhost/MS-VSDX.pdf#page=166}
       * @param {VisioCell} bevelBottomWidth
       */,
      set: function set(bevelBottomType) {
        this.attributeSet('bevelBottomType');
        this._bevelBottomType = bevelBottomType;
      }
    }, {
      key: "bevelBottomWidth",
      get:
      /**
       * 2.4.4.28 BevelBottomWidth
       * @see {http://localhost/MS-VSDX.pdf#page=166}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._bevelBottomWidth;
        if (cell === undefined) cell = this.getParentCell('bevelBottomWidth');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.29 BevelContourColor
       * @see {http://localhost/MS-VSDX.pdf#page=166}
       * @param {VisioCell} bevelContourColor
       */,
      set: function set(bevelBottomWidth) {
        this.attributeSet('bevelBottomWidth');
        this._bevelBottomWidth = bevelBottomWidth;
      }
    }, {
      key: "bevelContourColor",
      get:
      /**
       * 2.4.4.29 BevelContourColor
       * @see {http://localhost/MS-VSDX.pdf#page=166}
       */
      function get() {
        var visioType = VisioValueType.PtgColorRGB;
        var cell = this._bevelContourColor;
        if (cell === undefined) cell = this.getParentCell('bevelContourColor');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.30 BevelContourSize
       * @see {http://localhost/MS-VSDX.pdf#page=166}
       * @param {VisioCell} bevelContourSize
       */,
      set: function set(bevelContourColor) {
        this.attributeSet('bevelContourColor');
        this._bevelContourColor = bevelContourColor;
      }
    }, {
      key: "bevelContourSize",
      get:
      /**
       * 2.4.4.30 BevelContourSize
       * @see {http://localhost/MS-VSDX.pdf#page=166}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._bevelContourSize;
        if (cell === undefined) cell = this.getParentCell('bevelContourSize');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.31 BevelDepthColor
       * @see {http://localhost/MS-VSDX.pdf#page=166}
       * @param {VisioCell} bevelDepthColor
       */,
      set: function set(bevelContourSize) {
        this.attributeSet('bevelContourSize');
        this._bevelContourSize = bevelContourSize;
      }
    }, {
      key: "bevelDepthColor",
      get:
      /**
       * 2.4.4.31 BevelDepthColor
       * @see {http://localhost/MS-VSDX.pdf#page=166}
       */
      function get() {
        var visioType = VisioValueType.PtgColorRGB;
        var cell = this._bevelDepthColor;
        if (cell === undefined) cell = this.getParentCell('bevelDepthColor');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.32 BevelDepthSize
       * @see {http://localhost/MS-VSDX.pdf#page=166}
       * @param {VisioCell} bevelDepthSize
       */,
      set: function set(bevelDepthColor) {
        this.attributeSet('bevelDepthColor');
        this._bevelDepthColor = bevelDepthColor;
      }
    }, {
      key: "bevelDepthSize",
      get:
      /**
       * 2.4.4.32 BevelDepthSize
       * @see {http://localhost/MS-VSDX.pdf#page=166}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._bevelDepthSize;
        if (cell === undefined) cell = this.getParentCell('bevelDepthSize');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.33 BevelLightingAngle
       * @see {http://localhost/MS-VSDX.pdf#page=166}
       * @param {VisioCell} bevelLightingAngle
       */,
      set: function set(bevelDepthSize) {
        this.attributeSet('bevelDepthSize');
        this._bevelDepthSize = bevelDepthSize;
      }
    }, {
      key: "bevelLightingAngle",
      get:
      /**
       * 2.4.4.33 BevelLightingAngle
       * @see {http://localhost/MS-VSDX.pdf#page=166}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._bevelLightingAngle;
        if (cell === undefined) cell = this.getParentCell('bevelLightingAngle');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.34 BevelLightingType
       * @see {http://localhost/MS-VSDX.pdf#page=167}
       * @param {VisioCell} bevelLightingType
       */,
      set: function set(bevelLightingAngle) {
        this.attributeSet('bevelLightingAngle');
        this._bevelLightingAngle = bevelLightingAngle;
      }
    }, {
      key: "bevelLightingType",
      get:
      /**
       * 2.4.4.34 BevelLightingType
       * @see {http://localhost/MS-VSDX.pdf#page=167}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._bevelLightingType;
        if (cell === undefined) cell = this.getParentCell('bevelLightingType');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.35 BevelMaterialType
       * @see {http://localhost/MS-VSDX.pdf#page=167}
       * @param {VisioCell} bevelMaterialType
       */,
      set: function set(bevelLightingType) {
        this.attributeSet('bevelLightingType');
        this._bevelLightingType = bevelLightingType;
      }
    }, {
      key: "bevelMaterialType",
      get:
      /**
       * 2.4.4.35 BevelMaterialType
       * @see {http://localhost/MS-VSDX.pdf#page=167}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._bevelMaterialType;
        if (cell === undefined) cell = this.getParentCell('bevelMaterialType');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.36 BevelTopHeight
       * @see {http://localhost/MS-VSDX.pdf#page=168}
       * @param {VisioCell} bevelTopHeight
       */,
      set: function set(bevelMaterialType) {
        this.attributeSet('bevelMaterialType');
        this._bevelMaterialType = bevelMaterialType;
      }
    }, {
      key: "bevelTopHeight",
      get:
      /**
       * 2.4.4.36 BevelTopHeight
       * @see {http://localhost/MS-VSDX.pdf#page=168}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._bevelTopHeight;
        if (cell === undefined) cell = this.getParentCell('bevelTopHeight');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.37 BevelTopType
       * @see {http://localhost/MS-VSDX.pdf#page=168}
       * @param {VisioCell} bevelTopType
       */,
      set: function set(bevelTopHeight) {
        this.attributeSet('bevelTopHeight');
        this._bevelTopHeight = bevelTopHeight;
      }
    }, {
      key: "bevelTopType",
      get:
      /**
       * 2.4.4.37 BevelTopType
       * @see {http://localhost/MS-VSDX.pdf#page=168}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._bevelTopType;
        if (cell === undefined) cell = this.getParentCell('bevelTopType');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.38 BevelTopWidth
       * @see {http://localhost/MS-VSDX.pdf#page=169}
       * @param {VisioCell} bevelTopWidth
       */,
      set: function set(bevelTopType) {
        this.attributeSet('bevelTopType');
        this._bevelTopType = bevelTopType;
      }
    }, {
      key: "bevelTopWidth",
      get:
      /**
       * 2.4.4.38 BevelTopWidth
       * @see {http://localhost/MS-VSDX.pdf#page=169}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._bevelTopWidth;
        if (cell === undefined) cell = this.getParentCell('bevelTopWidth');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.39 BlockSizeX
       * @see {http://localhost/MS-VSDX.pdf#page=169}
       * @param {VisioCell} blockSizeX
       */,
      set: function set(bevelTopWidth) {
        this.attributeSet('bevelTopWidth');
        this._bevelTopWidth = bevelTopWidth;
      }
    }, {
      key: "blockSizeX",
      get:
      /**
       * 2.4.4.39 BlockSizeX
       * @see {http://localhost/MS-VSDX.pdf#page=169}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._blockSizeX;
        if (cell === undefined) cell = this.getParentCell('blockSizeX');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.40 BlockSizeY
       * @see {http://localhost/MS-VSDX.pdf#page=169}
       * @param {VisioCell} blockSizeY
       */,
      set: function set(blockSizeX) {
        this.attributeSet('blockSizeX');
        this._blockSizeX = blockSizeX;
      }
    }, {
      key: "blockSizeY",
      get:
      /**
       * 2.4.4.40 BlockSizeY
       * @see {http://localhost/MS-VSDX.pdf#page=169}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._blockSizeY;
        if (cell === undefined) cell = this.getParentCell('blockSizeY');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.41 Blur
       * @see {http://localhost/MS-VSDX.pdf#page=169}
       * @param {VisioCell} blur
       */,
      set: function set(blockSizeY) {
        this.attributeSet('blockSizeY');
        this._blockSizeY = blockSizeY;
      }
    }, {
      key: "blur",
      get:
      /**
       * 2.4.4.41 Blur
       * @see {http://localhost/MS-VSDX.pdf#page=169}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._blur;
        if (cell === undefined) cell = this.getParentCell('blur');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.42 BottomMargin
       * @see {http://localhost/MS-VSDX.pdf#page=169}
       * @param {VisioCell} bottomMargin
       */,
      set: function set(blur) {
        this.attributeSet('blur');
        this._blur = blur;
      }
    }, {
      key: "bottomMargin",
      get:
      /**
       * 2.4.4.42 BottomMargin
       * @see {http://localhost/MS-VSDX.pdf#page=169}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._bottomMargin;
        if (cell === undefined) cell = this.getParentCell('bottomMargin');
        if (cell === undefined) cell = this.getStylesheetTextStyleCell('bottomMargin');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.43 Brightness
       * @see {http://localhost/MS-VSDX.pdf#page=169}
       * @param {VisioCell} brightness
       */,
      set: function set(bottomMargin) {
        this.attributeSet('bottomMargin');
        this._bottomMargin = bottomMargin;
      }
    }, {
      key: "brightness",
      get:
      /**
       * 2.4.4.43 Brightness
       * @see {http://localhost/MS-VSDX.pdf#page=169}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._brightness;
        if (cell === undefined) cell = this.getParentCell('brightness');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.44 Bullet
       * @see {http://localhost/MS-VSDX.pdf#page=170}
       * @param {VisioCell} bullet
       */,
      set: function set(brightness) {
        this.attributeSet('brightness');
        this._brightness = brightness;
      }
    }, {
      key: "bullet",
      get:
      /**
       * 2.4.4.44 Bullet
       * @see {http://localhost/MS-VSDX.pdf#page=170}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._bullet;
        if (cell === undefined) cell = this.getParentCell('bullet');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.45 BulletFont
       * @see {http://localhost/MS-VSDX.pdf#page=170}
       * @param {VisioCell} bulletFont
       */,
      set: function set(bullet) {
        this.attributeSet('bullet');
        this._bullet = bullet;
      }
    }, {
      key: "bulletFont",
      get:
      /**
       * 2.4.4.45 BulletFont
       * @see {http://localhost/MS-VSDX.pdf#page=170}
       */
      function get() {
        var visioType = VisioValueType.vFont;
        var cell = this._bulletFont;
        if (cell === undefined) cell = this.getParentCell('bulletFont');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.46 BulletFontSize
       * @see {http://localhost/MS-VSDX.pdf#page=170}
       * @param {VisioCell} bulletFontSize
       */,
      set: function set(bulletFont) {
        this.attributeSet('bulletFont');
        this._bulletFont = bulletFont;
      }
    }, {
      key: "bulletFontSize",
      get:
      /**
       * 2.4.4.46 BulletFontSize
       * @see {http://localhost/MS-VSDX.pdf#page=170}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._bulletFontSize;
        if (cell === undefined) cell = this.getParentCell('bulletFontSize');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.47 BulletStr
       * @see {http://localhost/MS-VSDX.pdf#page=170}
       * @param {VisioCell} bulletStr
       */,
      set: function set(bulletFontSize) {
        this.attributeSet('bulletFontSize');
        this._bulletFontSize = bulletFontSize;
      }
    }, {
      key: "bulletStr",
      get:
      /**
       * 2.4.4.47 BulletStr
       * @see {http://localhost/MS-VSDX.pdf#page=170}
       */
      function get() {
        var visioType = VisioValueType.PtgString;
        var cell = this._bulletStr;
        if (cell === undefined) cell = this.getParentCell('bulletStr');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.48 ButtonFace
       * @see {http://localhost/MS-VSDX.pdf#page=171}
       * @param {VisioCell} buttonFace
       */,
      set: function set(bulletStr) {
        this.attributeSet('bulletStr');
        this._bulletStr = bulletStr;
      }
    }, {
      key: "buttonFace",
      get:
      /**
       * 2.4.4.48 ButtonFace
       * @see {http://localhost/MS-VSDX.pdf#page=171}
       */
      function get() {
        var visioType = VisioValueType.PtgString;
        var cell = this._buttonFace;
        if (cell === undefined) cell = this.getParentCell('buttonFace');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.49 C
       * @see {http://localhost/MS-VSDX.pdf#page=171}
       * @param {VisioCell} c
       */,
      set: function set(buttonFace) {
        this.attributeSet('buttonFace');
        this._buttonFace = buttonFace;
      }
    }, {
      key: "c",
      get:
      /**
       * 2.4.4.49 C
       * @see {http://localhost/MS-VSDX.pdf#page=171}
       */
      function get() {
        var visioType;
        if (this.isDescendantOfSectionType([VisioSectionType.Scratch])) visioType = VisioValueType.vAny;else switch (this.getRowType()) {
          case VisioRowType.Ellipse:
            visioType = VisioValueType.vLength;
            break;
          case VisioRowType.EllipticalArcTo:
          case VisioRowType.RelEllipticalArcTo:
            visioType = VisioValueType.vAngle;
            break;
          case VisioRowType.NURBSTo:
          case VisioRowType.RelCubBezTo:
          case VisioRowType.SplineStart:
            visioType = VisioValueType.vScalar;
            break;
          default:
            debug.log('Incorrect cell type', {
              attributeName: 'c',
              cells: this
            });
        }
        var cell = this._c;
        if (cell === undefined) cell = this.getParentCell('c');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.50 Calendar
       * @see {http://localhost/MS-VSDX.pdf#page=171}
       * @param {VisioCell} calendar
       */,
      set: function set(c) {
        this.attributeSet('c');
        this._c = c;
      }
    }, {
      key: "calendar",
      get:
      /**
       * 2.4.4.50 Calendar
       * @see {http://localhost/MS-VSDX.pdf#page=171}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._calendar;
        if (cell === undefined) cell = this.getParentCell('calendar');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.51 CanGlue
       * @see {http://localhost/MS-VSDX.pdf#page=171}
       * @param {VisioCell} canGlue
       */,
      set: function set(calendar) {
        this.attributeSet('calendar');
        this._calendar = calendar;
      }
    }, {
      key: "canGlue",
      get:
      /**
       * 2.4.4.51 CanGlue
       * @see {http://localhost/MS-VSDX.pdf#page=171}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._canGlue;
        if (cell === undefined) cell = this.getParentCell('canGlue');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.52 Case
       * @see {http://localhost/MS-VSDX.pdf#page=171}
       * @param {VisioCell} uppercase
       */,
      set: function set(canGlue) {
        this.attributeSet('canGlue');
        this._canGlue = canGlue;
      }
    }, {
      key: "uppercase",
      get:
      /**
       * 2.4.4.52 Case
       * @see {http://localhost/MS-VSDX.pdf#page=171}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._uppercase;
        if (cell === undefined) cell = this.getParentCell('uppercase');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.53 CenterX
       * @see {http://localhost/MS-VSDX.pdf#page=172}
       * @param {VisioCell} centerX
       */,
      set: function set(uppercase) {
        this.attributeSet('uppercase');
        this._uppercase = uppercase;
      }
    }, {
      key: "centerX",
      get:
      /**
       * 2.4.4.53 CenterX
       * @see {http://localhost/MS-VSDX.pdf#page=172}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._centerX;
        if (cell === undefined) cell = this.getParentCell('centerX');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.54 CenterY
       * @see {http://localhost/MS-VSDX.pdf#page=172}
       * @param {VisioCell} centerY
       */,
      set: function set(centerX) {
        this.attributeSet('centerX');
        this._centerX = centerX;
      }
    }, {
      key: "centerY",
      get:
      /**
       * 2.4.4.54 CenterY
       * @see {http://localhost/MS-VSDX.pdf#page=172}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._centerY;
        if (cell === undefined) cell = this.getParentCell('centerY');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.55 Checked
       * @see {http://localhost/MS-VSDX.pdf#page=172}
       * @param {VisioCell} checked
       */,
      set: function set(centerY) {
        this.attributeSet('centerY');
        this._centerY = centerY;
      }
    }, {
      key: "checked",
      get:
      /**
       * 2.4.4.55 Checked
       * @see {http://localhost/MS-VSDX.pdf#page=172}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._checked;
        if (cell === undefined) cell = this.getParentCell('checked');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.56 ClippingPath
       * @see {http://localhost/MS-VSDX.pdf#page=172}
       * @param {VisioCell} clippingPath
       */,
      set: function set(checked) {
        this.attributeSet('checked');
        this._checked = checked;
      }
    }, {
      key: "clippingPath",
      get:
      /**
       * 2.4.4.56 ClippingPath
       * @see {http://localhost/MS-VSDX.pdf#page=172}
       */
      function get() {
        var visioType = VisioValueType.PtgString;
        var cell = this._clippingPath;
        if (cell === undefined) cell = this.getParentCell('clippingPath');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.57 Color
       * @see {http://localhost/MS-VSDX.pdf#page=172}
       * @param {VisioCell} color
       */,
      set: function set(clippingPath) {
        this.attributeSet('clippingPath');
        this._clippingPath = clippingPath;
      }
    }, {
      key: "color",
      get:
      /**
       * 2.4.4.57 Color
       * @see {http://localhost/MS-VSDX.pdf#page=172}
       */
      function get() {
        var visioType = VisioValueType.PtgColorRGB;
        var cell = this._color;
        if (cell === undefined) cell = this.getParentCell('color');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.58 ColorSchemeIndex
       * @see {http://localhost/MS-VSDX.pdf#page=173}
       * @param {VisioCell} colorSchemeIndex
       */,
      set: function set(color) {
        this.attributeSet('color');
        this._color = color;
      }
    }, {
      key: "colorSchemeIndex",
      get:
      /**
       * 2.4.4.58 ColorSchemeIndex
       * @see {http://localhost/MS-VSDX.pdf#page=173}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._colorSchemeIndex;
        if (cell === undefined) cell = this.getParentCell('colorSchemeIndex');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.59 ColorTrans
       * @see {http://localhost/MS-VSDX.pdf#page=173}
       * @param {VisioCell} colorTrans
       */,
      set: function set(colorSchemeIndex) {
        this.attributeSet('colorSchemeIndex');
        this._colorSchemeIndex = colorSchemeIndex;
      }
    }, {
      key: "colorTrans",
      get:
      /**
       * 2.4.4.59 ColorTrans
       * @see {http://localhost/MS-VSDX.pdf#page=173}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._colorTrans;
        if (cell === undefined) cell = this.getParentCell('colorTrans');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.60 Comment
       * @see {http://localhost/MS-VSDX.pdf#page=174}
       * @param {VisioCell} comment
       */,
      set: function set(colorTrans) {
        this.attributeSet('colorTrans');
        this._colorTrans = colorTrans;
      }
    }, {
      key: "comment",
      get:
      /**
       * 2.4.4.60 Comment
       * @see {http://localhost/MS-VSDX.pdf#page=174}
       */
      function get() {
        var visioType = VisioValueType.PtgString;
        var cell = this._comment;
        if (cell === undefined) cell = this.getParentCell('comment');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.61 ComplexScriptFont
       * @see {http://localhost/MS-VSDX.pdf#page=174}
       * @param {VisioCell} complexScriptFont
       */,
      set: function set(comment) {
        this.attributeSet('comment');
        this._comment = comment;
      }
    }, {
      key: "complexScriptFont",
      get:
      /**
       * 2.4.4.61 ComplexScriptFont
       * @see {http://localhost/MS-VSDX.pdf#page=174}
       */
      function get() {
        var visioType = VisioValueType.vFont;
        var cell = this._complexScriptFont;
        if (cell === undefined) cell = this.getParentCell('complexScriptFont');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.62 ComplexScriptSize
       * @see {http://localhost/MS-VSDX.pdf#page=174}
       * @param {VisioCell} complexScriptSize
       */,
      set: function set(complexScriptFont) {
        this.attributeSet('complexScriptFont');
        this._complexScriptFont = complexScriptFont;
      }
    }, {
      key: "complexScriptSize",
      get:
      /**
       * 2.4.4.62 ComplexScriptSize
       * @see {http://localhost/MS-VSDX.pdf#page=174}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._complexScriptSize;
        if (cell === undefined) cell = this.getParentCell('complexScriptSize');
        if (cell === undefined) return undefined;
        var valueAsNumber = asNumber(cell.value);
        if (valueAsNumber === 0) return this.size;
        if (valueAsNumber < 0) return -valueAsNumber * this.size;
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.63 CompoundType
       * @see {http://localhost/MS-VSDX.pdf#page=174}
       * @param {VisioCell} compoundType
       */,
      set: function set(complexScriptSize) {
        this.attributeSet('complexScriptSize');
        this._complexScriptSize = complexScriptSize;
      }
    }, {
      key: "compoundType",
      get:
      /**
       * 2.4.4.63 CompoundType
       * @see {http://localhost/MS-VSDX.pdf#page=174}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._compoundType;
        if (cell === undefined) cell = this.getParentCell('compoundType');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.64 ConFixedCode
       * @see {http://localhost/MS-VSDX.pdf#page=175}
       * @param {VisioCell} conFixedCode
       */,
      set: function set(compoundType) {
        this.attributeSet('compoundType');
        this._compoundType = compoundType;
      }
    }, {
      key: "conFixedCode",
      get:
      /**
       * 2.4.4.64 ConFixedCode
       * @see {http://localhost/MS-VSDX.pdf#page=175}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._conFixedCode;
        if (cell === undefined) cell = this.getParentCell('conFixedCode');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.65 ConLineJumpCode
       * @see {http://localhost/MS-VSDX.pdf#page=175}
       * @param {VisioCell} conLineJumpCode
       */,
      set: function set(conFixedCode) {
        this.attributeSet('conFixedCode');
        this._conFixedCode = conFixedCode;
      }
    }, {
      key: "conLineJumpCode",
      get:
      /**
       * 2.4.4.65 ConLineJumpCode
       * @see {http://localhost/MS-VSDX.pdf#page=175}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._conLineJumpCode;
        if (cell === undefined) cell = this.getParentCell('conLineJumpCode');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.66 ConLineJumpDirX
       * @see {http://localhost/MS-VSDX.pdf#page=175}
       * @param {VisioCell} conLineJumpDirX
       */,
      set: function set(conLineJumpCode) {
        this.attributeSet('conLineJumpCode');
        this._conLineJumpCode = conLineJumpCode;
      }
    }, {
      key: "conLineJumpDirX",
      get:
      /**
       * 2.4.4.66 ConLineJumpDirX
       * @see {http://localhost/MS-VSDX.pdf#page=175}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._conLineJumpDirX;
        if (cell === undefined) cell = this.getParentCell('conLineJumpDirX');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.67 ConLineJumpDirY
       * @see {http://localhost/MS-VSDX.pdf#page=175}
       * @param {VisioCell} conLineJumpDirY
       */,
      set: function set(conLineJumpDirX) {
        this.attributeSet('conLineJumpDirX');
        this._conLineJumpDirX = conLineJumpDirX;
      }
    }, {
      key: "conLineJumpDirY",
      get:
      /**
       * 2.4.4.67 ConLineJumpDirY
       * @see {http://localhost/MS-VSDX.pdf#page=175}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._conLineJumpDirY;
        if (cell === undefined) cell = this.getParentCell('conLineJumpDirY');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.68 ConLineJumpStyle
       * @see {http://localhost/MS-VSDX.pdf#page=175}
       * @param {VisioCell} conLineJumpStyle
       */,
      set: function set(conLineJumpDirY) {
        this.attributeSet('conLineJumpDirY');
        this._conLineJumpDirY = conLineJumpDirY;
      }
    }, {
      key: "conLineJumpStyle",
      get:
      /**
       * 2.4.4.68 ConLineJumpStyle
       * @see {http://localhost/MS-VSDX.pdf#page=175}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._conLineJumpStyle;
        if (cell === undefined) cell = this.getParentCell('conLineJumpStyle');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.69 ConLineRouteExt
       * @see {http://localhost/MS-VSDX.pdf#page=175}
       * @param {VisioCell} conLineRouteExt
       */,
      set: function set(conLineJumpStyle) {
        this.attributeSet('conLineJumpStyle');
        this._conLineJumpStyle = conLineJumpStyle;
      }
    }, {
      key: "conLineRouteExt",
      get:
      /**
       * 2.4.4.69 ConLineRouteExt
       * @see {http://localhost/MS-VSDX.pdf#page=175}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._conLineRouteExt;
        if (cell === undefined) cell = this.getParentCell('conLineRouteExt');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.70 ConnectorSchemeIndex
       * @see {http://localhost/MS-VSDX.pdf#page=175}
       * @param {VisioCell} connectorSchemeIndex
       */,
      set: function set(conLineRouteExt) {
        this.attributeSet('conLineRouteExt');
        this._conLineRouteExt = conLineRouteExt;
      }
    }, {
      key: "connectorSchemeIndex",
      get:
      /**
       * 2.4.4.70 ConnectorSchemeIndex
       * @see {http://localhost/MS-VSDX.pdf#page=175}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._connectorSchemeIndex;
        if (cell === undefined) cell = this.getParentCell('connectorSchemeIndex');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.71 Contrast
       * @see {http://localhost/MS-VSDX.pdf#page=175}
       * @param {VisioCell} contrast
       */,
      set: function set(connectorSchemeIndex) {
        this.attributeSet('connectorSchemeIndex');
        this._connectorSchemeIndex = connectorSchemeIndex;
      }
    }, {
      key: "contrast",
      get:
      /**
       * 2.4.4.71 Contrast
       * @see {http://localhost/MS-VSDX.pdf#page=175}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._contrast;
        if (cell === undefined) cell = this.getParentCell('contrast');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.72 Copyright
       * @see {http://localhost/MS-VSDX.pdf#page=176}
       * @param {VisioCell} copyright
       */,
      set: function set(contrast) {
        this.attributeSet('contrast');
        this._contrast = contrast;
      }
    }, {
      key: "copyright",
      get:
      /**
       * 2.4.4.72 Copyright
       * @see {http://localhost/MS-VSDX.pdf#page=176}
       */
      function get() {
        var visioType = VisioValueType.PtgString;
        var cell = this._copyright;
        if (cell === undefined) cell = this.getParentCell('copyright');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.73 CtrlAsInput
       * @see {http://localhost/MS-VSDX.pdf#page=176}
       * @param {VisioCell} ctrlAsInput
       */,
      set: function set(copyright) {
        this.attributeSet('copyright');
        this._copyright = copyright;
      }
    }, {
      key: "ctrlAsInput",
      get:
      /**
       * 2.4.4.73 CtrlAsInput
       * @see {http://localhost/MS-VSDX.pdf#page=176}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._ctrlAsInput;
        if (cell === undefined) cell = this.getParentCell('ctrlAsInput');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.74 CurrentIndex
       * @see {http://localhost/MS-VSDX.pdf#page=176}
       * @param {VisioCell} currentIndex
       */,
      set: function set(ctrlAsInput) {
        this.attributeSet('ctrlAsInput');
        this._ctrlAsInput = ctrlAsInput;
      }
    }, {
      key: "currentIndex",
      get:
      /**
       * 2.4.4.74 CurrentIndex
       * @see {http://localhost/MS-VSDX.pdf#page=176}
       */
      function get() {
        var visioType = VisioValueType.PtgShort;
        var cell = this._currentIndex;
        if (cell === undefined) cell = this.getParentCell('currentIndex');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.75 D
       * @see {http://localhost/MS-VSDX.pdf#page=176}
       * @param {VisioCell} d
       */,
      set: function set(currentIndex) {
        this.attributeSet('currentIndex');
        this._currentIndex = currentIndex;
      }
    }, {
      key: "d",
      get:
      /**
       * 2.4.4.75 D
       * @see {http://localhost/MS-VSDX.pdf#page=176}
       */
      function get() {
        var visioType;
        if (this.isDescendantOfSectionType([VisioSectionType.Scratch])) visioType = VisioValueType.vAny;else switch (this.getRowType()) {
          case VisioRowType.Ellipse:
            visioType = VisioValueType.vLength;
            break;
          case VisioRowType.EllipticalArcTo:
          case VisioRowType.RelCubBezTo:
          case VisioRowType.RelEllipticalArcTo:
          case VisioRowType.NURBSTo:
          case VisioRowType.SplineStart:
            visioType = VisioValueType.vScalar;
            break;
          default:
            debug.log('Incorrect cell type', {
              attributeName: 'd',
              cells: this
            });
        }
        var cell = this._d;
        if (cell === undefined) cell = this.getParentCell('d');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.76 DataLinked
       * @see {http://localhost/MS-VSDX.pdf#page=176}
       * @param {VisioCell} dataLinked
       */,
      set: function set(d) {
        this.attributeSet('d');
        this._d = d;
      }
    }, {
      key: "dataLinked",
      get:
      /**
       * 2.4.4.76 DataLinked
       * @see {http://localhost/MS-VSDX.pdf#page=176}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._dataLinked;
        if (cell === undefined) cell = this.getParentCell('dataLinked');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.77 DblUnderline
       * @see {http://localhost/MS-VSDX.pdf#page=176}
       * @param {VisioCell} dblUnderline
       */,
      set: function set(dataLinked) {
        this.attributeSet('dataLinked');
        this._dataLinked = dataLinked;
      }
    }, {
      key: "dblUnderline",
      get:
      /**
       * 2.4.4.77 DblUnderline
       * @see {http://localhost/MS-VSDX.pdf#page=176}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._dblUnderline;
        if (cell === undefined) cell = this.getParentCell('dblUnderline');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.78 Default
       * @see {http://localhost/MS-VSDX.pdf#page=176}
       * @param {VisioCell} __default
       */,
      set: function set(dblUnderline) {
        this.attributeSet('dblUnderline');
        this._dblUnderline = dblUnderline;
      }
    }, {
      key: "__default",
      get:
      /**
       * 2.4.4.78 Default
       * @see {http://localhost/MS-VSDX.pdf#page=176}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this.___default;
        if (cell === undefined) cell = this.getParentCell('__default');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.79 DefaultTabStop
       * @see {http://localhost/MS-VSDX.pdf#page=177}
       * @param {VisioCell} defaultTabStop
       */,
      set: function set(__default) {
        this.attributeSet('__default');
        this.___default = __default;
      }
    }, {
      key: "defaultTabStop",
      get:
      /**
       * 2.4.4.79 DefaultTabStop
       * @see {http://localhost/MS-VSDX.pdf#page=177}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._defaultTabStop;
        if (cell === undefined) cell = this.getParentCell('defaultTabStop');
        if (cell === undefined) cell = this.getStylesheetTextStyleCell('defaultTabStop');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.80 Denoise
       * @see {http://localhost/MS-VSDX.pdf#page=177}
       * @param {VisioCell} denoise
       */,
      set: function set(defaultTabStop) {
        this.attributeSet('defaultTabStop');
        this._defaultTabStop = defaultTabStop;
      }
    }, {
      key: "denoise",
      get:
      /**
       * 2.4.4.80 Denoise
       * @see {http://localhost/MS-VSDX.pdf#page=177}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._denoise;
        if (cell === undefined) cell = this.getParentCell('denoise');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.81 Description
       * @see {http://localhost/MS-VSDX.pdf#page=177}
       * @param {VisioCell} description
       */,
      set: function set(denoise) {
        this.attributeSet('denoise');
        this._denoise = denoise;
      }
    }, {
      key: "description",
      get:
      /**
       * 2.4.4.81 Description
       * @see {http://localhost/MS-VSDX.pdf#page=177}
       */
      function get() {
        var visioType = VisioValueType.PtgString;
        var cell = this._description;
        if (cell === undefined) cell = this.getParentCell('description');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.82 DirX
       * @see {http://localhost/MS-VSDX.pdf#page=177}
       * @param {VisioCell} dirX
       */,
      set: function set(description) {
        this.attributeSet('description');
        this._description = description;
      }
    }, {
      key: "dirX",
      get:
      /**
       * 2.4.4.82 DirX
       * @see {http://localhost/MS-VSDX.pdf#page=177}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._dirX;
        if (cell === undefined) cell = this.getParentCell('dirX');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.83 DirY
       * @see {http://localhost/MS-VSDX.pdf#page=177}
       * @param {VisioCell} dirY
       */,
      set: function set(dirX) {
        this.attributeSet('dirX');
        this._dirX = dirX;
      }
    }, {
      key: "dirY",
      get:
      /**
       * 2.4.4.83 DirY
       * @see {http://localhost/MS-VSDX.pdf#page=177}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._dirY;
        if (cell === undefined) cell = this.getParentCell('dirY');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.84 Disabled
       * @see {http://localhost/MS-VSDX.pdf#page=177}
       * @param {VisioCell} disabled
       */,
      set: function set(dirY) {
        this.attributeSet('dirY');
        this._dirY = dirY;
      }
    }, {
      key: "disabled",
      get:
      /**
       * 2.4.4.84 Disabled
       * @see {http://localhost/MS-VSDX.pdf#page=177}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._disabled;
        if (cell === undefined) cell = this.getParentCell('disabled');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.85 DisplayLevel
       * @see {http://localhost/MS-VSDX.pdf#page=177}
       * @param {VisioCell} displayLevel
       */,
      set: function set(disabled) {
        this.attributeSet('disabled');
        this._disabled = disabled;
      }
    }, {
      key: "displayLevel",
      get:
      /**
       * 2.4.4.85 DisplayLevel
       * @see {http://localhost/MS-VSDX.pdf#page=177}
       */
      function get() {
        var visioType = VisioValueType.PtgInt;
        var cell = this._displayLevel;
        if (cell === undefined) cell = this.getParentCell('displayLevel');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.86 DisplayMode
       * @see {http://localhost/MS-VSDX.pdf#page=177}
       * @param {VisioCell} displayMode
       */,
      set: function set(displayLevel) {
        this.attributeSet('displayLevel');
        this._displayLevel = displayLevel;
      }
    }, {
      key: "displayMode",
      get:
      /**
       * 2.4.4.86 DisplayMode
       * @see {http://localhost/MS-VSDX.pdf#page=177}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._displayMode;
        if (cell === undefined) cell = this.getParentCell('displayMode');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.87 DistanceFromGround
       * @see {http://localhost/MS-VSDX.pdf#page=178}
       * @param {VisioCell} distanceFromGround
       */,
      set: function set(displayMode) {
        this.attributeSet('displayMode');
        this._displayMode = displayMode;
      }
    }, {
      key: "distanceFromGround",
      get:
      /**
       * 2.4.4.87 DistanceFromGround
       * @see {http://localhost/MS-VSDX.pdf#page=178}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._distanceFromGround;
        if (cell === undefined) cell = this.getParentCell('distanceFromGround');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.88 DocLangID
       * @see {http://localhost/MS-VSDX.pdf#page=178}
       * @param {VisioCell} docLangID
       */,
      set: function set(distanceFromGround) {
        this.attributeSet('distanceFromGround');
        this._distanceFromGround = distanceFromGround;
      }
    }, {
      key: "docLangID",
      get:
      /**
       * 2.4.4.88 DocLangID
       * @see {http://localhost/MS-VSDX.pdf#page=178}
       */
      function get() {
        var visioType = VisioValueType.vLanguageString;
        var cell = this._docLangID;
        if (cell === undefined) cell = this.getParentCell('docLangID');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.89 DocLockDuplicatePage
       * @see {http://localhost/MS-VSDX.pdf#page=178}
       * @param {VisioCell} docLockDuplicatePage
       */,
      set: function set(docLangID) {
        this.attributeSet('docLangID');
        this._docLangID = docLangID;
      }
    }, {
      key: "docLockDuplicatePage",
      get:
      /**
       * 2.4.4.89 DocLockDuplicatePage
       * @see {http://localhost/MS-VSDX.pdf#page=178}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._docLockDuplicatePage;
        if (cell === undefined) cell = this.getParentCell('docLockDuplicatePage');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.90 DocLockReplace
       * @see {http://localhost/MS-VSDX.pdf#page=178}
       * @param {VisioCell} docLockReplace
       */,
      set: function set(docLockDuplicatePage) {
        this.attributeSet('docLockDuplicatePage');
        this._docLockDuplicatePage = docLockDuplicatePage;
      }
    }, {
      key: "docLockReplace",
      get:
      /**
       * 2.4.4.90 DocLockReplace
       * @see {http://localhost/MS-VSDX.pdf#page=178}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._docLockReplace;
        if (cell === undefined) cell = this.getParentCell('docLockReplace');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.91 DontMoveChildren
       * @see {http://localhost/MS-VSDX.pdf#page=178}
       * @param {VisioCell} dontMoveChildren
       */,
      set: function set(docLockReplace) {
        this.attributeSet('docLockReplace');
        this._docLockReplace = docLockReplace;
      }
    }, {
      key: "dontMoveChildren",
      get:
      /**
       * 2.4.4.91 DontMoveChildren
       * @see {http://localhost/MS-VSDX.pdf#page=178}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._dontMoveChildren;
        if (cell === undefined) cell = this.getParentCell('dontMoveChildren');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.92 DoubleStrikethrough
       * @see {http://localhost/MS-VSDX.pdf#page=178}
       * @param {VisioCell} doubleStrikethrough
       */,
      set: function set(dontMoveChildren) {
        this.attributeSet('dontMoveChildren');
        this._dontMoveChildren = dontMoveChildren;
      }
    }, {
      key: "doubleStrikethrough",
      get:
      /**
       * 2.4.4.92 DoubleStrikethrough
       * @see {http://localhost/MS-VSDX.pdf#page=178}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._doubleStrikethrough;
        if (cell === undefined) cell = this.getParentCell('doubleStrikethrough');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.93 DrawingResizeType
       * @see {http://localhost/MS-VSDX.pdf#page=179}
       * @param {VisioCell} drawingResizeType
       */,
      set: function set(doubleStrikethrough) {
        this.attributeSet('doubleStrikethrough');
        this._doubleStrikethrough = doubleStrikethrough;
      }
    }, {
      key: "drawingResizeType",
      get:
      /**
       * 2.4.4.93 DrawingResizeType
       * @see {http://localhost/MS-VSDX.pdf#page=179}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._drawingResizeType;
        if (cell === undefined) cell = this.getParentCell('drawingResizeType');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.94 DrawingScale
       * @see {http://localhost/MS-VSDX.pdf#page=179}
       * @param {VisioCell} drawingScale
       */,
      set: function set(drawingResizeType) {
        this.attributeSet('drawingResizeType');
        this._drawingResizeType = drawingResizeType;
      }
    }, {
      key: "drawingScale",
      get:
      /**
       * 2.4.4.94 DrawingScale
       * @see {http://localhost/MS-VSDX.pdf#page=179}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._drawingScale;
        if (cell === undefined) cell = this.getParentCell('drawingScale');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.95 DrawingScaleType
       * @see {http://localhost/MS-VSDX.pdf#page=179}
       * @param {VisioCell} drawingScaleType
       */,
      set: function set(drawingScale) {
        this.attributeSet('drawingScale');
        this._drawingScale = drawingScale;
      }
    }, {
      key: "drawingScaleType",
      get:
      /**
       * 2.4.4.95 DrawingScaleType
       * @see {http://localhost/MS-VSDX.pdf#page=179}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._drawingScaleType;
        if (cell === undefined) cell = this.getParentCell('drawingScaleType');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.96 DrawingSizeType
       * @see {http://localhost/MS-VSDX.pdf#page=179}
       * @param {VisioCell} drawingSizeType
       */,
      set: function set(drawingScaleType) {
        this.attributeSet('drawingScaleType');
        this._drawingScaleType = drawingScaleType;
      }
    }, {
      key: "drawingSizeType",
      get:
      /**
       * 2.4.4.96 DrawingSizeType
       * @see {http://localhost/MS-VSDX.pdf#page=179}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._drawingSizeType;
        if (cell === undefined) cell = this.getParentCell('drawingSizeType');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.97 DropOnPageScale
       * @see {http://localhost/MS-VSDX.pdf#page=180}
       * @param {VisioCell} dropOnPageScale
       */,
      set: function set(drawingSizeType) {
        this.attributeSet('drawingSizeType');
        this._drawingSizeType = drawingSizeType;
      }
    }, {
      key: "dropOnPageScale",
      get:
      /**
       * 2.4.4.97 DropOnPageScale
       * @see {http://localhost/MS-VSDX.pdf#page=180}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._dropOnPageScale;
        if (cell === undefined) cell = this.getParentCell('dropOnPageScale');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.98 DynamicsOff
       * @see {http://localhost/MS-VSDX.pdf#page=180}
       * @param {VisioCell} dynamicsOff
       */,
      set: function set(dropOnPageScale) {
        this.attributeSet('dropOnPageScale');
        this._dropOnPageScale = dropOnPageScale;
      }
    }, {
      key: "dynamicsOff",
      get:
      /**
       * 2.4.4.98 DynamicsOff
       * @see {http://localhost/MS-VSDX.pdf#page=180}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._dynamicsOff;
        if (cell === undefined) cell = this.getParentCell('dynamicsOff');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.99 DynFeedback
       * @see {http://localhost/MS-VSDX.pdf#page=180}
       * @param {VisioCell} dynFeedback
       */,
      set: function set(dynamicsOff) {
        this.attributeSet('dynamicsOff');
        this._dynamicsOff = dynamicsOff;
      }
    }, {
      key: "dynFeedback",
      get:
      /**
       * 2.4.4.99 DynFeedback
       * @see {http://localhost/MS-VSDX.pdf#page=180}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._dynFeedback;
        if (cell === undefined) cell = this.getParentCell('dynFeedback');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.100 E
       * @see {http://localhost/MS-VSDX.pdf#page=180}
       * @param {VisioCell} e
       */,
      set: function set(dynFeedback) {
        this.attributeSet('dynFeedback');
        this._dynFeedback = dynFeedback;
      }
    }, {
      key: "e",
      get:
      /**
       * 2.4.4.100 E
       * @see {http://localhost/MS-VSDX.pdf#page=180}
       */
      function get() {
        var visioType = VisioValueType.formulaExpression;
        var cell = this._e;
        if (cell === undefined) cell = this.getParentCell('e');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.101 EffectSchemeIndex
       * @see {http://localhost/MS-VSDX.pdf#page=180}
       * @param {VisioCell} effectSchemeIndex
       */,
      set: function set(e) {
        this.attributeSet('e');
        this._e = e;
      }
    }, {
      key: "effectSchemeIndex",
      get:
      /**
       * 2.4.4.101 EffectSchemeIndex
       * @see {http://localhost/MS-VSDX.pdf#page=180}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._effectSchemeIndex;
        if (cell === undefined) cell = this.getParentCell('effectSchemeIndex');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.102 EmbellishmentIndex
       * @see {http://localhost/MS-VSDX.pdf#page=180}
       * @param {VisioCell} embellishmentIndex
       */,
      set: function set(effectSchemeIndex) {
        this.attributeSet('effectSchemeIndex');
        this._effectSchemeIndex = effectSchemeIndex;
      }
    }, {
      key: "embellishmentIndex",
      get:
      /**
       * 2.4.4.102 EmbellishmentIndex
       * @see {http://localhost/MS-VSDX.pdf#page=180}
       */
      function get() {
        var visioType = VisioValueType.PtgInt;
        var cell = this._embellishmentIndex;
        if (cell === undefined) cell = this.getParentCell('embellishmentIndex');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.103 EnableFillProps
       * @see {http://localhost/MS-VSDX.pdf#page=180}
       * @param {VisioCell} enableFillProps
       */,
      set: function set(embellishmentIndex) {
        this.attributeSet('embellishmentIndex');
        this._embellishmentIndex = embellishmentIndex;
      }
    }, {
      key: "enableFillProps",
      get:
      /**
       * 2.4.4.103 EnableFillProps
       * @see {http://localhost/MS-VSDX.pdf#page=180}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._enableFillProps;
        if (cell === undefined) cell = this.getParentCell('enableFillProps');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.104 EnableGrid
       * @see {http://localhost/MS-VSDX.pdf#page=181}
       * @param {VisioCell} enableGrid
       */,
      set: function set(enableFillProps) {
        this.attributeSet('enableFillProps');
        this._enableFillProps = enableFillProps;
      }
    }, {
      key: "enableGrid",
      get:
      /**
       * 2.4.4.104 EnableGrid
       * @see {http://localhost/MS-VSDX.pdf#page=181}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._enableGrid;
        if (cell === undefined) cell = this.getParentCell('enableGrid');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.105 EnableLineProps
       * @see {http://localhost/MS-VSDX.pdf#page=181}
       * @param {VisioCell} enableLineProps
       */,
      set: function set(enableGrid) {
        this.attributeSet('enableGrid');
        this._enableGrid = enableGrid;
      }
    }, {
      key: "enableLineProps",
      get:
      /**
       * 2.4.4.105 EnableLineProps
       * @see {http://localhost/MS-VSDX.pdf#page=181}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._enableLineProps;
        if (cell === undefined) cell = this.getParentCell('enableLineProps');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.106 EnableTextProps
       * @see {http://localhost/MS-VSDX.pdf#page=181}
       * @param {VisioCell} enableTextProps
       */,
      set: function set(enableLineProps) {
        this.attributeSet('enableLineProps');
        this._enableLineProps = enableLineProps;
      }
    }, {
      key: "enableTextProps",
      get:
      /**
       * 2.4.4.106 EnableTextProps
       * @see {http://localhost/MS-VSDX.pdf#page=181}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._enableTextProps;
        if (cell === undefined) cell = this.getParentCell('enableTextProps');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.107 EndArrow
       * @see {http://localhost/MS-VSDX.pdf#page=181}
       * @param {VisioCell} endArrow
       */,
      set: function set(enableTextProps) {
        this.attributeSet('enableTextProps');
        this._enableTextProps = enableTextProps;
      }
    }, {
      key: "endArrow",
      get:
      /**
       * 2.4.4.107 EndArrow
       * @see {http://localhost/MS-VSDX.pdf#page=181}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._endArrow;
        if (cell === undefined) cell = this.getParentCell('endArrow');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.108 EndArrowSize
       * @see {http://localhost/MS-VSDX.pdf#page=181}
       * @param {VisioCell} endArrowSize
       */,
      set: function set(endArrow) {
        this.attributeSet('endArrow');
        this._endArrow = endArrow;
      }
    }, {
      key: "endArrowSize",
      get:
      /**
       * 2.4.4.108 EndArrowSize
       * @see {http://localhost/MS-VSDX.pdf#page=181}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._endArrowSize;
        if (cell === undefined) cell = this.getParentCell('endArrowSize');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.109 EndTrigger
       * @see {http://localhost/MS-VSDX.pdf#page=182}
       * @param {VisioCell} endTrigger
       */,
      set: function set(endArrowSize) {
        this.attributeSet('endArrowSize');
        this._endArrowSize = endArrowSize;
      }
    }, {
      key: "endTrigger",
      get:
      /**
       * 2.4.4.109 EndTrigger
       * @see {http://localhost/MS-VSDX.pdf#page=182}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._endTrigger;
        if (cell === undefined) cell = this.getParentCell('endTrigger');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.110 EndX
       * @see {http://localhost/MS-VSDX.pdf#page=182}
       * @param {VisioCell} endX
       */,
      set: function set(endTrigger) {
        this.attributeSet('endTrigger');
        this._endTrigger = endTrigger;
      }
    }, {
      key: "endX",
      get:
      /**
       * 2.4.4.110 EndX
       * @see {http://localhost/MS-VSDX.pdf#page=182}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._endX;
        if (cell === undefined) cell = this.getParentCell('endX');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.111 EndY
       * @see {http://localhost/MS-VSDX.pdf#page=182}
       * @param {VisioCell} endY
       */,
      set: function set(endX) {
        this.attributeSet('endX');
        this._endX = endX;
      }
    }, {
      key: "endY",
      get:
      /**
       * 2.4.4.111 EndY
       * @see {http://localhost/MS-VSDX.pdf#page=182}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._endY;
        if (cell === undefined) cell = this.getParentCell('endY');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.112 EventDblClick
       * @see {http://localhost/MS-VSDX.pdf#page=182}
       * @param {VisioCell} eventDblClick
       */,
      set: function set(endY) {
        this.attributeSet('endY');
        this._endY = endY;
      }
    }, {
      key: "eventDblClick",
      get:
      /**
       * 2.4.4.112 EventDblClick
       * @see {http://localhost/MS-VSDX.pdf#page=182}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._eventDblClick;
        if (cell === undefined) cell = this.getParentCell('eventDblClick');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.113 EventDrop
       * @see {http://localhost/MS-VSDX.pdf#page=182}
       * @param {VisioCell} eventDrop
       */,
      set: function set(eventDblClick) {
        this.attributeSet('eventDblClick');
        this._eventDblClick = eventDblClick;
      }
    }, {
      key: "eventDrop",
      get:
      /**
       * 2.4.4.113 EventDrop
       * @see {http://localhost/MS-VSDX.pdf#page=182}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._eventDrop;
        if (cell === undefined) cell = this.getParentCell('eventDrop');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.114 EventMultiDrop
       * @see {http://localhost/MS-VSDX.pdf#page=182}
       * @param {VisioCell} eventMultiDrop
       */,
      set: function set(eventDrop) {
        this.attributeSet('eventDrop');
        this._eventDrop = eventDrop;
      }
    }, {
      key: "eventMultiDrop",
      get:
      /**
       * 2.4.4.114 EventMultiDrop
       * @see {http://localhost/MS-VSDX.pdf#page=182}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._eventMultiDrop;
        if (cell === undefined) cell = this.getParentCell('eventMultiDrop');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.115 EventXFMod
       * @see {http://localhost/MS-VSDX.pdf#page=182}
       * @param {VisioCell} eventXFMod
       */,
      set: function set(eventMultiDrop) {
        this.attributeSet('eventMultiDrop');
        this._eventMultiDrop = eventMultiDrop;
      }
    }, {
      key: "eventXFMod",
      get:
      /**
       * 2.4.4.115 EventXFMod
       * @see {http://localhost/MS-VSDX.pdf#page=182}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._eventXFMod;
        if (cell === undefined) cell = this.getParentCell('eventXFMod');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.116 ExtraInfo
       * @see {http://localhost/MS-VSDX.pdf#page=182}
       * @param {VisioCell} extraInfo
       */,
      set: function set(eventXFMod) {
        this.attributeSet('eventXFMod');
        this._eventXFMod = eventXFMod;
      }
    }, {
      key: "extraInfo",
      get:
      /**
       * 2.4.4.116 ExtraInfo
       * @see {http://localhost/MS-VSDX.pdf#page=182}
       */
      function get() {
        var visioType = VisioValueType.PtgString;
        var cell = this._extraInfo;
        if (cell === undefined) cell = this.getParentCell('extraInfo');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.117 FillBkgnd
       * @see {http://localhost/MS-VSDX.pdf#page=183}
       * @param {VisioCell} fillBkgnd
       */,
      set: function set(extraInfo) {
        this.attributeSet('extraInfo');
        this._extraInfo = extraInfo;
      }
    }, {
      key: "fillBkgnd",
      get:
      /**
       * 2.4.4.117 FillBkgnd
       * @see {http://localhost/MS-VSDX.pdf#page=183}
       */
      function get() {
        var visioType = VisioValueType.vColor;
        var cell = this._fillBkgnd;
        if (cell === undefined) cell = this.getParentCell('fillBkgnd');
        if (cell === undefined) cell = this.getStylesheetFillStyleCell('fillBkgnd');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.118 FillBkgndTrans
       * @see {http://localhost/MS-VSDX.pdf#page=183}
       * @param {VisioCell} fillBkgndTrans
       */,
      set: function set(fillBkgnd) {
        this.attributeSet('fillBkgnd');
        this._fillBkgnd = fillBkgnd;
      }
    }, {
      key: "fillBkgndTrans",
      get:
      /**
       * 2.4.4.118 FillBkgndTrans
       * @see {http://localhost/MS-VSDX.pdf#page=183}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._fillBkgndTrans;
        if (cell === undefined) cell = this.getParentCell('fillBkgndTrans');
        if (cell === undefined) cell = this.getStylesheetFillStyleCell('fillBkgndTrans');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.119 FillForegnd
       * @see {http://localhost/MS-VSDX.pdf#page=183}
       * @param {VisioCell} fillForegnd
       */,
      set: function set(fillBkgndTrans) {
        this.attributeSet('fillBkgndTrans');
        this._fillBkgndTrans = fillBkgndTrans;
      }
    }, {
      key: "fillForegnd",
      get:
      /**
       * 2.4.4.119 FillForegnd
       * @see {http://localhost/MS-VSDX.pdf#page=183}
       */
      function get() {
        var visioType = VisioValueType.vColor;
        var cell = this._fillForegnd;
        if (cell === undefined) cell = this.getParentCell('fillForegnd');
        if (cell === undefined) cell = this.getStylesheetFillStyleCell('fillForegnd');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.120 FillForegndTrans
       * @see {http://localhost/MS-VSDX.pdf#page=183}
       * @param {VisioCell} fillForegndTrans
       */,
      set: function set(fillForegnd) {
        this.attributeSet('fillForegnd');
        this._fillForegnd = fillForegnd;
      }
    }, {
      key: "fillForegndTrans",
      get:
      /**
       * 2.4.4.120 FillForegndTrans
       * @see {http://localhost/MS-VSDX.pdf#page=183}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._fillForegndTrans;
        if (cell === undefined) cell = this.getParentCell('fillForegndTrans');
        if (cell === undefined) cell = this.getStylesheetFillStyleCell('fillForegndTrans');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.121 FillGradientAngle
       * @see {http://localhost/MS-VSDX.pdf#page=183}
       * @param {VisioCell} fillGradientAngle
       */,
      set: function set(fillForegndTrans) {
        this.attributeSet('fillForegndTrans');
        this._fillForegndTrans = fillForegndTrans;
      }
    }, {
      key: "fillGradientAngle",
      get:
      /**
       * 2.4.4.121 FillGradientAngle
       * @see {http://localhost/MS-VSDX.pdf#page=183}
       */
      function get() {
        var visioType = VisioValueType.vAngle;
        var cell = this._fillGradientAngle;
        if (cell === undefined) cell = this.getParentCell('fillGradientAngle');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.122 FillGradientDir
       * @see {http://localhost/MS-VSDX.pdf#page=183}
       * @param {VisioCell} fillGradientDir
       */,
      set: function set(fillGradientAngle) {
        this.attributeSet('fillGradientAngle');
        this._fillGradientAngle = fillGradientAngle;
      }
    }, {
      key: "fillGradientDir",
      get:
      /**
       * 2.4.4.122 FillGradientDir
       * @see {http://localhost/MS-VSDX.pdf#page=183}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._fillGradientDir;
        if (cell === undefined) cell = this.getParentCell('fillGradientDir');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.123 FillGradientEnabled
       * @see {http://localhost/MS-VSDX.pdf#page=184}
       * @param {VisioCell} fillGradientEnabled
       */,
      set: function set(fillGradientDir) {
        this.attributeSet('fillGradientDir');
        this._fillGradientDir = fillGradientDir;
      }
    }, {
      key: "fillGradientEnabled",
      get:
      /**
       * 2.4.4.123 FillGradientEnabled
       * @see {http://localhost/MS-VSDX.pdf#page=184}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._fillGradientEnabled;
        if (cell === undefined) cell = this.getParentCell('fillGradientEnabled');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.124 FillPattern
       * @see {http://localhost/MS-VSDX.pdf#page=184}
       * @param {VisioCell} fillPattern
       */,
      set: function set(fillGradientEnabled) {
        this.attributeSet('fillGradientEnabled');
        this._fillGradientEnabled = fillGradientEnabled;
      }
    }, {
      key: "fillPattern",
      get:
      /**
       * 2.4.4.124 FillPattern
       * @see {http://localhost/MS-VSDX.pdf#page=184}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._fillPattern;
        if (cell === undefined) cell = this.getParentCell('fillPattern');
        if (cell === undefined) cell = this.getStylesheetFillStyleCell('fillPattern');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.125 Flags
       * @see {http://localhost/MS-VSDX.pdf#page=187}
       * @param {VisioCell} flags
       */,
      set: function set(fillPattern) {
        this.attributeSet('fillPattern');
        this._fillPattern = fillPattern;
      }
    }, {
      key: "flags",
      get:
      /**
       * 2.4.4.125 Flags
       * @see {http://localhost/MS-VSDX.pdf#page=187}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._flags;
        if (cell === undefined) cell = this.getParentCell('flags');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.126 FlipX
       * @see {http://localhost/MS-VSDX.pdf#page=187}
       * @param {VisioCell} flipX
       */,
      set: function set(flags) {
        this.attributeSet('flags');
        this._flags = flags;
      }
    }, {
      key: "flipX",
      get:
      /**
       * 2.4.4.126 FlipX
       * @see {http://localhost/MS-VSDX.pdf#page=187}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._flipX;
        if (cell === undefined) cell = this.getParentCell('flipX');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.127 FlipY
       * @see {http://localhost/MS-VSDX.pdf#page=187}
       * @param {VisioCell} flipY
       */,
      set: function set(flipX) {
        this.attributeSet('flipX');
        this._flipX = flipX;
      }
    }, {
      key: "flipY",
      get:
      /**
       * 2.4.4.127 FlipY
       * @see {http://localhost/MS-VSDX.pdf#page=187}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._flipY;
        if (cell === undefined) cell = this.getParentCell('flipY');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.128 FlyoutChild
       * @see {http://localhost/MS-VSDX.pdf#page=187}
       * @param {VisioCell} flyoutChild
       */,
      set: function set(flipY) {
        this.attributeSet('flipY');
        this._flipY = flipY;
      }
    }, {
      key: "flyoutChild",
      get:
      /**
       * 2.4.4.128 FlyoutChild
       * @see {http://localhost/MS-VSDX.pdf#page=187}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._flyoutChild;
        if (cell === undefined) cell = this.getParentCell('flyoutChild');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.129 Font
       * @see {http://localhost/MS-VSDX.pdf#page=187}
       * @param {VisioCell} font
       */,
      set: function set(flyoutChild) {
        this.attributeSet('flyoutChild');
        this._flyoutChild = flyoutChild;
      }
    }, {
      key: "font",
      get:
      /**
       * 2.4.4.129 Font
       * @see {http://localhost/MS-VSDX.pdf#page=187}
       */
      function get() {
        var visioType = VisioValueType.vFont;
        var cell = this._font;
        if (cell === undefined) cell = this.getParentCell('font');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.130 FontScale
       * @see {http://localhost/MS-VSDX.pdf#page=187}
       * @param {VisioCell} fontScale
       */,
      set: function set(font) {
        this.attributeSet('font');
        this._font = font;
      }
    }, {
      key: "fontScale",
      get:
      /**
       * 2.4.4.130 FontScale
       * @see {http://localhost/MS-VSDX.pdf#page=187}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._fontScale;
        if (cell === undefined) cell = this.getParentCell('fontScale');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.131 FontSchemeIndex
       * @see {http://localhost/MS-VSDX.pdf#page=188}
       * @param {VisioCell} fontSchemeIndex
       */,
      set: function set(fontScale) {
        this.attributeSet('fontScale');
        this._fontScale = fontScale;
      }
    }, {
      key: "fontSchemeIndex",
      get:
      /**
       * 2.4.4.131 FontSchemeIndex
       * @see {http://localhost/MS-VSDX.pdf#page=188}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._fontSchemeIndex;
        if (cell === undefined) cell = this.getParentCell('fontSchemeIndex');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.132 Format
       * @see {http://localhost/MS-VSDX.pdf#page=188}
       * @param {VisioCell} format
       */,
      set: function set(fontSchemeIndex) {
        this.attributeSet('fontSchemeIndex');
        this._fontSchemeIndex = fontSchemeIndex;
      }
    }, {
      key: "format",
      get:
      /**
       * 2.4.4.132 Format
       * @see {http://localhost/MS-VSDX.pdf#page=188}
       */
      function get() {
        var visioType = VisioValueType.vFormatString;
        var cell = this._format;
        if (cell === undefined) cell = this.getParentCell('format');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.133 Frame
       * @see {http://localhost/MS-VSDX.pdf#page=188}
       * @param {VisioCell} frame
       */,
      set: function set(format) {
        this.attributeSet('format');
        this._format = format;
      }
    }, {
      key: "frame",
      get:
      /**
       * 2.4.4.133 Frame
       * @see {http://localhost/MS-VSDX.pdf#page=188}
       */
      function get() {
        var visioType = VisioValueType.PtgString;
        var cell = this._frame;
        if (cell === undefined) cell = this.getParentCell('frame');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.134 Gamma
       * @see {http://localhost/MS-VSDX.pdf#page=188}
       * @param {VisioCell} gamma
       */,
      set: function set(frame) {
        this.attributeSet('frame');
        this._frame = frame;
      }
    }, {
      key: "gamma",
      get:
      /**
       * 2.4.4.134 Gamma
       * @see {http://localhost/MS-VSDX.pdf#page=188}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._gamma;
        if (cell === undefined) cell = this.getParentCell('gamma');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.135 GlowColor
       * @see {http://localhost/MS-VSDX.pdf#page=188}
       * @param {VisioCell} glowColor
       */,
      set: function set(gamma) {
        this.attributeSet('gamma');
        this._gamma = gamma;
      }
    }, {
      key: "glowColor",
      get:
      /**
       * 2.4.4.135 GlowColor
       * @see {http://localhost/MS-VSDX.pdf#page=188}
       */
      function get() {
        var visioType = VisioValueType.vColor;
        var cell = this._glowColor;
        if (cell === undefined) cell = this.getParentCell('glowColor');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.136 GlowColorTrans
       * @see {http://localhost/MS-VSDX.pdf#page=188}
       * @param {VisioCell} glowColorTrans
       */,
      set: function set(glowColor) {
        this.attributeSet('glowColor');
        this._glowColor = glowColor;
      }
    }, {
      key: "glowColorTrans",
      get:
      /**
       * 2.4.4.136 GlowColorTrans
       * @see {http://localhost/MS-VSDX.pdf#page=188}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._glowColorTrans;
        if (cell === undefined) cell = this.getParentCell('glowColorTrans');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.137 GlowSize
       * @see {http://localhost/MS-VSDX.pdf#page=188}
       * @param {VisioCell} glowSize
       */,
      set: function set(glowColorTrans) {
        this.attributeSet('glowColorTrans');
        this._glowColorTrans = glowColorTrans;
      }
    }, {
      key: "glowSize",
      get:
      /**
       * 2.4.4.137 GlowSize
       * @see {http://localhost/MS-VSDX.pdf#page=188}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._glowSize;
        if (cell === undefined) cell = this.getParentCell('glowSize');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.138 Glue
       * @see {http://localhost/MS-VSDX.pdf#page=189}
       * @param {VisioCell} glue
       */,
      set: function set(glowSize) {
        this.attributeSet('glowSize');
        this._glowSize = glowSize;
      }
    }, {
      key: "glue",
      get:
      /**
       * 2.4.4.138 Glue
       * @see {http://localhost/MS-VSDX.pdf#page=189}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._glue;
        if (cell === undefined) cell = this.getParentCell('glue');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.139 GlueType
       * @see {http://localhost/MS-VSDX.pdf#page=189}
       * @param {VisioCell} glueType
       */,
      set: function set(glue) {
        this.attributeSet('glue');
        this._glue = glue;
      }
    }, {
      key: "glueType",
      get:
      /**
       * 2.4.4.139 GlueType
       * @see {http://localhost/MS-VSDX.pdf#page=189}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._glueType;
        if (cell === undefined) cell = this.getParentCell('glueType');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.140 GradientStopColor
       * @see {http://localhost/MS-VSDX.pdf#page=189}
       * @param {VisioCell} gradientStopColor
       */,
      set: function set(glueType) {
        this.attributeSet('glueType');
        this._glueType = glueType;
      }
    }, {
      key: "gradientStopColor",
      get:
      /**
       * 2.4.4.140 GradientStopColor
       * @see {http://localhost/MS-VSDX.pdf#page=189}
       */
      function get() {
        var visioType = VisioValueType.vColor;
        var cell = this._gradientStopColor;
        if (cell === undefined) cell = this.getParentCell('gradientStopColor');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.141 GradientStopColorTrans
       * @see {http://localhost/MS-VSDX.pdf#page=189}
       * @param {VisioCell} gradientStopColorTrans
       */,
      set: function set(gradientStopColor) {
        this.attributeSet('gradientStopColor');
        this._gradientStopColor = gradientStopColor;
      }
    }, {
      key: "gradientStopColorTrans",
      get:
      /**
       * 2.4.4.141 GradientStopColorTrans
       * @see {http://localhost/MS-VSDX.pdf#page=189}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._gradientStopColorTrans;
        if (cell === undefined) cell = this.getParentCell('gradientStopColorTrans');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.142 GradientStopPosition
       * @see {http://localhost/MS-VSDX.pdf#page=189}
       * @param {VisioCell} gradientStopPosition
       */,
      set: function set(gradientStopColorTrans) {
        this.attributeSet('gradientStopColorTrans');
        this._gradientStopColorTrans = gradientStopColorTrans;
      }
    }, {
      key: "gradientStopPosition",
      get:
      /**
       * 2.4.4.142 GradientStopPosition
       * @see {http://localhost/MS-VSDX.pdf#page=189}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._gradientStopPosition;
        if (cell === undefined) cell = this.getParentCell('gradientStopPosition');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.143 Height
       * @see {http://localhost/MS-VSDX.pdf#page=189}
       * @param {VisioCell} height
       */,
      set: function set(gradientStopPosition) {
        this.attributeSet('gradientStopPosition');
        this._gradientStopPosition = gradientStopPosition;
      }
    }, {
      key: "height",
      get:
      /**
       * 2.4.4.143 Height
       * @see {http://localhost/MS-VSDX.pdf#page=189}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._height;
        if (cell === undefined) cell = this.getParentCell('height');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.144 HelpTopic
       * @see {http://localhost/MS-VSDX.pdf#page=189}
       * @param {VisioCell} helpTopic
       */,
      set: function set(height) {
        this.attributeSet('height');
        this._height = height;
      }
    }, {
      key: "helpTopic",
      get:
      /**
       * 2.4.4.144 HelpTopic
       * @see {http://localhost/MS-VSDX.pdf#page=189}
       */
      function get() {
        var visioType = VisioValueType.PtgString;
        var cell = this._helpTopic;
        if (cell === undefined) cell = this.getParentCell('helpTopic');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.145 HideForApply
       * @see {http://localhost/MS-VSDX.pdf#page=190}
       * @param {VisioCell} hideForApply
       */,
      set: function set(helpTopic) {
        this.attributeSet('helpTopic');
        this._helpTopic = helpTopic;
      }
    }, {
      key: "hideForApply",
      get:
      /**
       * 2.4.4.145 HideForApply
       * @see {http://localhost/MS-VSDX.pdf#page=190}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._hideForApply;
        if (cell === undefined) cell = this.getParentCell('hideForApply');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.146 HideText
       * @see {http://localhost/MS-VSDX.pdf#page=190}
       * @param {VisioCell} hideText
       */,
      set: function set(hideForApply) {
        this.attributeSet('hideForApply');
        this._hideForApply = hideForApply;
      }
    }, {
      key: "hideText",
      get:
      /**
       * 2.4.4.146 HideText
       * @see {http://localhost/MS-VSDX.pdf#page=190}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._hideText;
        if (cell === undefined) cell = this.getParentCell('hideText');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.147 HorzAlign
       * @see {http://localhost/MS-VSDX.pdf#page=190}
       * @param {VisioCell} horzAlign
       */,
      set: function set(hideText) {
        this.attributeSet('hideText');
        this._hideText = hideText;
      }
    }, {
      key: "horzAlign",
      get:
      /**
       * 2.4.4.147 HorzAlign
       * @see {http://localhost/MS-VSDX.pdf#page=190}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._horzAlign;
        if (cell === undefined) cell = this.getParentCell('horzAlign');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.148 ImgHeight
       * @see {http://localhost/MS-VSDX.pdf#page=190}
       * @param {VisioCell} imgHeight
       */,
      set: function set(horzAlign) {
        this.attributeSet('horzAlign');
        this._horzAlign = horzAlign;
      }
    }, {
      key: "imgHeight",
      get:
      /**
       * 2.4.4.148 ImgHeight
       * @see {http://localhost/MS-VSDX.pdf#page=190}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._imgHeight;
        if (cell === undefined) cell = this.getParentCell('imgHeight');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.149 ImgOffsetX
       * @see {http://localhost/MS-VSDX.pdf#page=190}
       * @param {VisioCell} imgOffsetX
       */,
      set: function set(imgHeight) {
        this.attributeSet('imgHeight');
        this._imgHeight = imgHeight;
      }
    }, {
      key: "imgOffsetX",
      get:
      /**
       * 2.4.4.149 ImgOffsetX
       * @see {http://localhost/MS-VSDX.pdf#page=190}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._imgOffsetX;
        if (cell === undefined) cell = this.getParentCell('imgOffsetX');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.150 ImgOffsetY
       * @see {http://localhost/MS-VSDX.pdf#page=190}
       * @param {VisioCell} imgOffsetY
       */,
      set: function set(imgOffsetX) {
        this.attributeSet('imgOffsetX');
        this._imgOffsetX = imgOffsetX;
      }
    }, {
      key: "imgOffsetY",
      get:
      /**
       * 2.4.4.150 ImgOffsetY
       * @see {http://localhost/MS-VSDX.pdf#page=190}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._imgOffsetY;
        if (cell === undefined) cell = this.getParentCell('imgOffsetY');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.151 ImgWidth
       * @see {http://localhost/MS-VSDX.pdf#page=190}
       * @param {VisioCell} imgWidth
       */,
      set: function set(imgOffsetY) {
        this.attributeSet('imgOffsetY');
        this._imgOffsetY = imgOffsetY;
      }
    }, {
      key: "imgWidth",
      get:
      /**
       * 2.4.4.151 ImgWidth
       * @see {http://localhost/MS-VSDX.pdf#page=190}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._imgWidth;
        if (cell === undefined) cell = this.getParentCell('imgWidth');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.152 IndFirst
       * @see {http://localhost/MS-VSDX.pdf#page=191}
       * @param {VisioCell} indFirst
       */,
      set: function set(imgWidth) {
        this.attributeSet('imgWidth');
        this._imgWidth = imgWidth;
      }
    }, {
      key: "indFirst",
      get:
      /**
       * 2.4.4.152 IndFirst
       * @see {http://localhost/MS-VSDX.pdf#page=191}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._indFirst;
        if (cell === undefined) cell = this.getParentCell('indFirst');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.153 IndLeft
       * @see {http://localhost/MS-VSDX.pdf#page=191}
       * @param {VisioCell} indLeft
       */,
      set: function set(indFirst) {
        this.attributeSet('indFirst');
        this._indFirst = indFirst;
      }
    }, {
      key: "indLeft",
      get:
      /**
       * 2.4.4.153 IndLeft
       * @see {http://localhost/MS-VSDX.pdf#page=191}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._indLeft;
        if (cell === undefined) cell = this.getParentCell('indLeft');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.154 IndRight
       * @see {http://localhost/MS-VSDX.pdf#page=191}
       * @param {VisioCell} indRight
       */,
      set: function set(indLeft) {
        this.attributeSet('indLeft');
        this._indLeft = indLeft;
      }
    }, {
      key: "indRight",
      get:
      /**
       * 2.4.4.154 IndRight
       * @see {http://localhost/MS-VSDX.pdf#page=191}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._indRight;
        if (cell === undefined) cell = this.getParentCell('indRight');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.155 InhibitSnap
       * @see {http://localhost/MS-VSDX.pdf#page=191}
       * @param {VisioCell} inhibitSnap
       */,
      set: function set(indRight) {
        this.attributeSet('indRight');
        this._indRight = indRight;
      }
    }, {
      key: "inhibitSnap",
      get:
      /**
       * 2.4.4.155 InhibitSnap
       * @see {http://localhost/MS-VSDX.pdf#page=191}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._inhibitSnap;
        if (cell === undefined) cell = this.getParentCell('inhibitSnap');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.156 Initials
       * @see {http://localhost/MS-VSDX.pdf#page=191}
       * @param {VisioCell} initials
       */,
      set: function set(inhibitSnap) {
        this.attributeSet('inhibitSnap');
        this._inhibitSnap = inhibitSnap;
      }
    }, {
      key: "initials",
      get:
      /**
       * 2.4.4.156 Initials
       * @see {http://localhost/MS-VSDX.pdf#page=191}
       */
      function get() {
        var visioType = VisioValueType.PtgString;
        var cell = this._initials;
        if (cell === undefined) cell = this.getParentCell('initials');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.157 Invisible
       * @see {http://localhost/MS-VSDX.pdf#page=191}
       * @param {VisioCell} invisible
       */,
      set: function set(initials) {
        this.attributeSet('initials');
        this._initials = initials;
      }
    }, {
      key: "invisible",
      get:
      /**
       * 2.4.4.157 Invisible
       * @see {http://localhost/MS-VSDX.pdf#page=191}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._invisible;
        if (cell === undefined) cell = this.getParentCell('invisible');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.158 IsDropSource
       * @see {http://localhost/MS-VSDX.pdf#page=191}
       * @param {VisioCell} isDropSource
       */,
      set: function set(invisible) {
        this.attributeSet('invisible');
        this._invisible = invisible;
      }
    }, {
      key: "isDropSource",
      get:
      /**
       * 2.4.4.158 IsDropSource
       * @see {http://localhost/MS-VSDX.pdf#page=191}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._isDropSource;
        if (cell === undefined) cell = this.getParentCell('isDropSource');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.159 IsDropTarget
       * @see {http://localhost/MS-VSDX.pdf#page=192}
       * @param {VisioCell} isDropTarget
       */,
      set: function set(isDropSource) {
        this.attributeSet('isDropSource');
        this._isDropSource = isDropSource;
      }
    }, {
      key: "isDropTarget",
      get:
      /**
       * 2.4.4.159 IsDropTarget
       * @see {http://localhost/MS-VSDX.pdf#page=192}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._isDropTarget;
        if (cell === undefined) cell = this.getParentCell('isDropTarget');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.160 IsSnapTarget
       * @see {http://localhost/MS-VSDX.pdf#page=192}
       * @param {VisioCell} isSnapTarget
       */,
      set: function set(isDropTarget) {
        this.attributeSet('isDropTarget');
        this._isDropTarget = isDropTarget;
      }
    }, {
      key: "isSnapTarget",
      get:
      /**
       * 2.4.4.160 IsSnapTarget
       * @see {http://localhost/MS-VSDX.pdf#page=192}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._isSnapTarget;
        if (cell === undefined) cell = this.getParentCell('isSnapTarget');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.161 IsTextEditTarget
       * @see {http://localhost/MS-VSDX.pdf#page=192}
       * @param {VisioCell} isTextEditTarget
       */,
      set: function set(isSnapTarget) {
        this.attributeSet('isSnapTarget');
        this._isSnapTarget = isSnapTarget;
      }
    }, {
      key: "isTextEditTarget",
      get:
      /**
       * 2.4.4.161 IsTextEditTarget
       * @see {http://localhost/MS-VSDX.pdf#page=192}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._isTextEditTarget;
        if (cell === undefined) cell = this.getParentCell('isTextEditTarget');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.162 KeepTextFlat
       * @see {http://localhost/MS-VSDX.pdf#page=192}
       * @param {VisioCell} keepTextFlat
       */,
      set: function set(isTextEditTarget) {
        this.attributeSet('isTextEditTarget');
        this._isTextEditTarget = isTextEditTarget;
      }
    }, {
      key: "keepTextFlat",
      get:
      /**
       * 2.4.4.162 KeepTextFlat
       * @see {http://localhost/MS-VSDX.pdf#page=192}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._keepTextFlat;
        if (cell === undefined) cell = this.getParentCell('keepTextFlat');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.163 Label
       * @see {http://localhost/MS-VSDX.pdf#page=192}
       * @param {VisioCell} label
       */,
      set: function set(keepTextFlat) {
        this.attributeSet('keepTextFlat');
        this._keepTextFlat = keepTextFlat;
      }
    }, {
      key: "label",
      get:
      /**
       * 2.4.4.163 Label
       * @see {http://localhost/MS-VSDX.pdf#page=192}
       */
      function get() {
        var visioType = VisioValueType.PtgString;
        var cell = this._label;
        if (cell === undefined) cell = this.getParentCell('label');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.164 LangID
       * @see {http://localhost/MS-VSDX.pdf#page=192}
       * @param {VisioCell} langID
       */,
      set: function set(label) {
        this.attributeSet('label');
        this._label = label;
      }
    }, {
      key: "langID",
      get:
      /**
       * 2.4.4.164 LangID
       * @see {http://localhost/MS-VSDX.pdf#page=192}
       */
      function get() {
        var visioType = VisioValueType.vLanguageString;
        var cell = this._langID;
        if (cell === undefined) cell = this.getParentCell('langID');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.165 LayerMember
       * @see {http://localhost/MS-VSDX.pdf#page=192}
       * @param {VisioCell} layerMember
       */,
      set: function set(langID) {
        this.attributeSet('langID');
        this._langID = langID;
      }
    }, {
      key: "layerMember",
      get:
      /**
       * 2.4.4.165 LayerMember
       * @see {http://localhost/MS-VSDX.pdf#page=192}
       */
      function get() {
        var visioType = VisioValueType.PtgString;
        var cell = this._layerMember;
        if (cell === undefined) cell = this.getParentCell('layerMember');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.166 LeftMargin
       * @see {http://localhost/MS-VSDX.pdf#page=192}
       * @param {VisioCell} leftMargin
       */,
      set: function set(layerMember) {
        this.attributeSet('layerMember');
        this._layerMember = layerMember;
      }
    }, {
      key: "leftMargin",
      get:
      /**
       * 2.4.4.166 LeftMargin
       * @see {http://localhost/MS-VSDX.pdf#page=192}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._leftMargin;
        if (cell === undefined) cell = this.getParentCell('leftMargin');
        if (cell === undefined) cell = this.getStylesheetTextStyleCell('leftMargin');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.167 Letterspace
       * @see {http://localhost/MS-VSDX.pdf#page=193}
       * @param {VisioCell} letterspace
       */,
      set: function set(leftMargin) {
        this.attributeSet('leftMargin');
        this._leftMargin = leftMargin;
      }
    }, {
      key: "letterspace",
      get:
      /**
       * 2.4.4.167 Letterspace
       * @see {http://localhost/MS-VSDX.pdf#page=193}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._letterspace;
        if (cell === undefined) cell = this.getParentCell('letterspace');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.168 LineAdjustFrom
       * @see {http://localhost/MS-VSDX.pdf#page=193}
       * @param {VisioCell} lineAdjustFrom
       */,
      set: function set(letterspace) {
        this.attributeSet('letterspace');
        this._letterspace = letterspace;
      }
    }, {
      key: "lineAdjustFrom",
      get:
      /**
       * 2.4.4.168 LineAdjustFrom
       * @see {http://localhost/MS-VSDX.pdf#page=193}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._lineAdjustFrom;
        if (cell === undefined) cell = this.getParentCell('lineAdjustFrom');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.169 LineAdjustTo
       * @see {http://localhost/MS-VSDX.pdf#page=193}
       * @param {VisioCell} lineAdjustTo
       */,
      set: function set(lineAdjustFrom) {
        this.attributeSet('lineAdjustFrom');
        this._lineAdjustFrom = lineAdjustFrom;
      }
    }, {
      key: "lineAdjustTo",
      get:
      /**
       * 2.4.4.169 LineAdjustTo
       * @see {http://localhost/MS-VSDX.pdf#page=193}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._lineAdjustTo;
        if (cell === undefined) cell = this.getParentCell('lineAdjustTo');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.170 LineCap
       * @see {http://localhost/MS-VSDX.pdf#page=193}
       * @param {VisioCell} lineCap
       */,
      set: function set(lineAdjustTo) {
        this.attributeSet('lineAdjustTo');
        this._lineAdjustTo = lineAdjustTo;
      }
    }, {
      key: "lineCap",
      get:
      /**
       * 2.4.4.170 LineCap
       * @see {http://localhost/MS-VSDX.pdf#page=193}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._lineCap;
        if (cell === undefined) cell = this.getParentCell('lineCap');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.171 LineColor
       * @see {http://localhost/MS-VSDX.pdf#page=193}
       * @param {VisioCell} lineColor
       */,
      set: function set(lineCap) {
        this.attributeSet('lineCap');
        this._lineCap = lineCap;
      }
    }, {
      key: "lineColor",
      get:
      /**
       * 2.4.4.171 LineColor
       * @see {http://localhost/MS-VSDX.pdf#page=193}
       */
      function get() {
        var visioType = VisioValueType.vColor;
        var cell = this._lineColor;

        // if (this.shape && this.shape.id === 51) {
        //     cell.value = '#ff0000';
        // }

        if (cell === undefined) cell = this.getParentCell('lineColor');
        if (cell === undefined) cell = this.getStylesheetLineStyleCell('lineColor');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.172 LineColorTrans
       * @see {http://localhost/MS-VSDX.pdf#page=193}
       * @param {VisioCell} lineColorTrans
       */,
      set: function set(lineColor) {
        this.attributeSet('lineColor');
        this._lineColor = lineColor;
      }
    }, {
      key: "lineColorTrans",
      get:
      /**
       * 2.4.4.172 LineColorTrans
       * @see {http://localhost/MS-VSDX.pdf#page=193}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._lineColorTrans;
        if (cell === undefined) cell = this.getParentCell('lineColorTrans');
        if (cell === undefined) cell = this.getStylesheetLineStyleCell('lineColorTrans');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.173 LineGradientAngle
       * @see {http://localhost/MS-VSDX.pdf#page=193}
       * @param {VisioCell} lineGradientAngle
       */,
      set: function set(lineColorTrans) {
        this.attributeSet('lineColorTrans');
        this._lineColorTrans = lineColorTrans;
      }
    }, {
      key: "lineGradientAngle",
      get:
      /**
       * 2.4.4.173 LineGradientAngle
       * @see {http://localhost/MS-VSDX.pdf#page=193}
       */
      function get() {
        var visioType = VisioValueType.vAngle;
        var cell = this._lineGradientAngle;
        if (cell === undefined) cell = this.getParentCell('lineGradientAngle');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.174 LineGradientDir
       * @see {http://localhost/MS-VSDX.pdf#page=194}
       * @param {VisioCell} lineGradientDir
       */,
      set: function set(lineGradientAngle) {
        this.attributeSet('lineGradientAngle');
        this._lineGradientAngle = lineGradientAngle;
      }
    }, {
      key: "lineGradientDir",
      get:
      /**
       * 2.4.4.174 LineGradientDir
       * @see {http://localhost/MS-VSDX.pdf#page=194}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._lineGradientDir;
        if (cell === undefined) cell = this.getParentCell('lineGradientDir');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.175 LineGradientEnabled
       * @see {http://localhost/MS-VSDX.pdf#page=194}
       * @param {VisioCell} lineGradientEnabled
       */,
      set: function set(lineGradientDir) {
        this.attributeSet('lineGradientDir');
        this._lineGradientDir = lineGradientDir;
      }
    }, {
      key: "lineGradientEnabled",
      get:
      /**
       * 2.4.4.175 LineGradientEnabled
       * @see {http://localhost/MS-VSDX.pdf#page=194}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._lineGradientEnabled;
        if (cell === undefined) cell = this.getParentCell('lineGradientEnabled');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.176 LineJumpCode
       * @see {http://localhost/MS-VSDX.pdf#page=194}
       * @param {VisioCell} lineJumpCode
       */,
      set: function set(lineGradientEnabled) {
        this.attributeSet('lineGradientEnabled');
        this._lineGradientEnabled = lineGradientEnabled;
      }
    }, {
      key: "lineJumpCode",
      get:
      /**
       * 2.4.4.176 LineJumpCode
       * @see {http://localhost/MS-VSDX.pdf#page=194}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._lineJumpCode;
        if (cell === undefined) cell = this.getParentCell('lineJumpCode');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.177 LineJumpFactorX
       * @see {http://localhost/MS-VSDX.pdf#page=194}
       * @param {VisioCell} lineJumpFactorX
       */,
      set: function set(lineJumpCode) {
        this.attributeSet('lineJumpCode');
        this._lineJumpCode = lineJumpCode;
      }
    }, {
      key: "lineJumpFactorX",
      get:
      /**
       * 2.4.4.177 LineJumpFactorX
       * @see {http://localhost/MS-VSDX.pdf#page=194}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._lineJumpFactorX;
        if (cell === undefined) cell = this.getParentCell('lineJumpFactorX');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.178 LineJumpFactorY
       * @see {http://localhost/MS-VSDX.pdf#page=195}
       * @param {VisioCell} lineJumpFactorY
       */,
      set: function set(lineJumpFactorX) {
        this.attributeSet('lineJumpFactorX');
        this._lineJumpFactorX = lineJumpFactorX;
      }
    }, {
      key: "lineJumpFactorY",
      get:
      /**
       * 2.4.4.178 LineJumpFactorY
       * @see {http://localhost/MS-VSDX.pdf#page=195}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._lineJumpFactorY;
        if (cell === undefined) cell = this.getParentCell('lineJumpFactorY');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.179 LineJumpStyle
       * @see {http://localhost/MS-VSDX.pdf#page=195}
       * @param {VisioCell} lineJumpStyle
       */,
      set: function set(lineJumpFactorY) {
        this.attributeSet('lineJumpFactorY');
        this._lineJumpFactorY = lineJumpFactorY;
      }
    }, {
      key: "lineJumpStyle",
      get:
      /**
       * 2.4.4.179 LineJumpStyle
       * @see {http://localhost/MS-VSDX.pdf#page=195}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._lineJumpStyle;
        if (cell === undefined) cell = this.getParentCell('lineJumpStyle');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.180 LinePattern
       * @see {http://localhost/MS-VSDX.pdf#page=195}
       * @param {VisioCell} linePattern
       */,
      set: function set(lineJumpStyle) {
        this.attributeSet('lineJumpStyle');
        this._lineJumpStyle = lineJumpStyle;
      }
    }, {
      key: "linePattern",
      get:
      /**
       * 2.4.4.180 LinePattern
       * @see {http://localhost/MS-VSDX.pdf#page=195}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._linePattern;
        if (cell === undefined) cell = this.getParentCell('linePattern');
        if (cell === undefined) cell = this.getStylesheetLineStyleCell('linePattern');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.181 LineRouteExt
       * @see {http://localhost/MS-VSDX.pdf#page=196}
       * @param {VisioCell} lineRouteExt
       */,
      set: function set(linePattern) {
        this.attributeSet('linePattern');
        this._linePattern = linePattern;
      }
    }, {
      key: "lineRouteExt",
      get:
      /**
       * 2.4.4.181 LineRouteExt
       * @see {http://localhost/MS-VSDX.pdf#page=196}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._lineRouteExt;
        if (cell === undefined) cell = this.getParentCell('lineRouteExt');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.182 LineToLineX
       * @see {http://localhost/MS-VSDX.pdf#page=196}
       * @param {VisioCell} lineToLineX
       */,
      set: function set(lineRouteExt) {
        this.attributeSet('lineRouteExt');
        this._lineRouteExt = lineRouteExt;
      }
    }, {
      key: "lineToLineX",
      get:
      /**
       * 2.4.4.182 LineToLineX
       * @see {http://localhost/MS-VSDX.pdf#page=196}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._lineToLineX;
        if (cell === undefined) cell = this.getParentCell('lineToLineX');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.183 LineToLineY
       * @see {http://localhost/MS-VSDX.pdf#page=196}
       * @param {VisioCell} lineToLineY
       */,
      set: function set(lineToLineX) {
        this.attributeSet('lineToLineX');
        this._lineToLineX = lineToLineX;
      }
    }, {
      key: "lineToLineY",
      get:
      /**
       * 2.4.4.183 LineToLineY
       * @see {http://localhost/MS-VSDX.pdf#page=196}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._lineToLineY;
        if (cell === undefined) cell = this.getParentCell('lineToLineY');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.184 LineToNodeX
       * @see {http://localhost/MS-VSDX.pdf#page=196}
       * @param {VisioCell} lineToNodeX
       */,
      set: function set(lineToLineY) {
        this.attributeSet('lineToLineY');
        this._lineToLineY = lineToLineY;
      }
    }, {
      key: "lineToNodeX",
      get:
      /**
       * 2.4.4.184 LineToNodeX
       * @see {http://localhost/MS-VSDX.pdf#page=196}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._lineToNodeX;
        if (cell === undefined) cell = this.getParentCell('lineToNodeX');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.185 LineToNodeY
       * @see {http://localhost/MS-VSDX.pdf#page=197}
       * @param {VisioCell} lineToNodeY
       */,
      set: function set(lineToNodeX) {
        this.attributeSet('lineToNodeX');
        this._lineToNodeX = lineToNodeX;
      }
    }, {
      key: "lineToNodeY",
      get:
      /**
       * 2.4.4.185 LineToNodeY
       * @see {http://localhost/MS-VSDX.pdf#page=197}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._lineToNodeY;
        if (cell === undefined) cell = this.getParentCell('lineToNodeY');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.186 LineWeight
       * @see {http://localhost/MS-VSDX.pdf#page=197}
       * @param {VisioCell} lineWeight
       */,
      set: function set(lineToNodeY) {
        this.attributeSet('lineToNodeY');
        this._lineToNodeY = lineToNodeY;
      }
    }, {
      key: "lineWeight",
      get:
      /**
       * 2.4.4.186 LineWeight
       * @see {http://localhost/MS-VSDX.pdf#page=197}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._lineWeight;
        if (cell === undefined) cell = this.getParentCell('lineWeight');
        if (cell === undefined) cell = this.getStylesheetLineStyleCell('lineWeight');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.187 LocalizeMerge
       * @see {http://localhost/MS-VSDX.pdf#page=197}
       * @param {VisioCell} localizeMerge
       */,
      set: function set(lineWeight) {
        this.attributeSet('lineWeight');
        this._lineWeight = lineWeight;
      }
    }, {
      key: "localizeMerge",
      get:
      /**
       * 2.4.4.187 LocalizeMerge
       * @see {http://localhost/MS-VSDX.pdf#page=197}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._localizeMerge;
        if (cell === undefined) cell = this.getParentCell('localizeMerge');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.188 Lock
       * @see {http://localhost/MS-VSDX.pdf#page=197}
       * @param {VisioCell} lock
       */,
      set: function set(localizeMerge) {
        this.attributeSet('localizeMerge');
        this._localizeMerge = localizeMerge;
      }
    }, {
      key: "lock",
      get:
      /**
       * 2.4.4.188 Lock
       * @see {http://localhost/MS-VSDX.pdf#page=197}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._lock;
        if (cell === undefined) cell = this.getParentCell('lock');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.189 LockAspect
       * @see {http://localhost/MS-VSDX.pdf#page=197}
       * @param {VisioCell} lockAspect
       */,
      set: function set(lock) {
        this.attributeSet('lock');
        this._lock = lock;
      }
    }, {
      key: "lockAspect",
      get:
      /**
       * 2.4.4.189 LockAspect
       * @see {http://localhost/MS-VSDX.pdf#page=197}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._lockAspect;
        if (cell === undefined) cell = this.getParentCell('lockAspect');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.190 LockBegin
       * @see {http://localhost/MS-VSDX.pdf#page=197}
       * @param {VisioCell} lockBegin
       */,
      set: function set(lockAspect) {
        this.attributeSet('lockAspect');
        this._lockAspect = lockAspect;
      }
    }, {
      key: "lockBegin",
      get:
      /**
       * 2.4.4.190 LockBegin
       * @see {http://localhost/MS-VSDX.pdf#page=197}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._lockBegin;
        if (cell === undefined) cell = this.getParentCell('lockBegin');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.191 LockCalcWH
       * @see {http://localhost/MS-VSDX.pdf#page=197}
       * @param {VisioCell} lockCalcWH
       */,
      set: function set(lockBegin) {
        this.attributeSet('lockBegin');
        this._lockBegin = lockBegin;
      }
    }, {
      key: "lockCalcWH",
      get:
      /**
       * 2.4.4.191 LockCalcWH
       * @see {http://localhost/MS-VSDX.pdf#page=197}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._lockCalcWH;
        if (cell === undefined) cell = this.getParentCell('lockCalcWH');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.192 LockCrop
       * @see {http://localhost/MS-VSDX.pdf#page=197}
       * @param {VisioCell} lockCrop
       */,
      set: function set(lockCalcWH) {
        this.attributeSet('lockCalcWH');
        this._lockCalcWH = lockCalcWH;
      }
    }, {
      key: "lockCrop",
      get:
      /**
       * 2.4.4.192 LockCrop
       * @see {http://localhost/MS-VSDX.pdf#page=197}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._lockCrop;
        if (cell === undefined) cell = this.getParentCell('lockCrop');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.193 LockCustProp
       * @see {http://localhost/MS-VSDX.pdf#page=197}
       * @param {VisioCell} lockCustProp
       */,
      set: function set(lockCrop) {
        this.attributeSet('lockCrop');
        this._lockCrop = lockCrop;
      }
    }, {
      key: "lockCustProp",
      get:
      /**
       * 2.4.4.193 LockCustProp
       * @see {http://localhost/MS-VSDX.pdf#page=197}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._lockCustProp;
        if (cell === undefined) cell = this.getParentCell('lockCustProp');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.194 LockDelete
       * @see {http://localhost/MS-VSDX.pdf#page=197}
       * @param {VisioCell} lockDelete
       */,
      set: function set(lockCustProp) {
        this.attributeSet('lockCustProp');
        this._lockCustProp = lockCustProp;
      }
    }, {
      key: "lockDelete",
      get:
      /**
       * 2.4.4.194 LockDelete
       * @see {http://localhost/MS-VSDX.pdf#page=197}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._lockDelete;
        if (cell === undefined) cell = this.getParentCell('lockDelete');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.195 LockEnd
       * @see {http://localhost/MS-VSDX.pdf#page=198}
       * @param {VisioCell} lockEnd
       */,
      set: function set(lockDelete) {
        this.attributeSet('lockDelete');
        this._lockDelete = lockDelete;
      }
    }, {
      key: "lockEnd",
      get:
      /**
       * 2.4.4.195 LockEnd
       * @see {http://localhost/MS-VSDX.pdf#page=198}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._lockEnd;
        if (cell === undefined) cell = this.getParentCell('lockEnd');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.196 LockFormat
       * @see {http://localhost/MS-VSDX.pdf#page=198}
       * @param {VisioCell} lockFormat
       */,
      set: function set(lockEnd) {
        this.attributeSet('lockEnd');
        this._lockEnd = lockEnd;
      }
    }, {
      key: "lockFormat",
      get:
      /**
       * 2.4.4.196 LockFormat
       * @see {http://localhost/MS-VSDX.pdf#page=198}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._lockFormat;
        if (cell === undefined) cell = this.getParentCell('lockFormat');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.197 LockFromGroupFormat
       * @see {http://localhost/MS-VSDX.pdf#page=198}
       * @param {VisioCell} lockFromGroupFormat
       */,
      set: function set(lockFormat) {
        this.attributeSet('lockFormat');
        this._lockFormat = lockFormat;
      }
    }, {
      key: "lockFromGroupFormat",
      get:
      /**
       * 2.4.4.197 LockFromGroupFormat
       * @see {http://localhost/MS-VSDX.pdf#page=198}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._lockFromGroupFormat;
        if (cell === undefined) cell = this.getParentCell('lockFromGroupFormat');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.198 LockGroup
       * @see {http://localhost/MS-VSDX.pdf#page=198}
       * @param {VisioCell} lockGroup
       */,
      set: function set(lockFromGroupFormat) {
        this.attributeSet('lockFromGroupFormat');
        this._lockFromGroupFormat = lockFromGroupFormat;
      }
    }, {
      key: "lockGroup",
      get:
      /**
       * 2.4.4.198 LockGroup
       * @see {http://localhost/MS-VSDX.pdf#page=198}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._lockGroup;
        if (cell === undefined) cell = this.getParentCell('lockGroup');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.199 LockHeight
       * @see {http://localhost/MS-VSDX.pdf#page=198}
       * @param {VisioCell} lockHeight
       */,
      set: function set(lockGroup) {
        this.attributeSet('lockGroup');
        this._lockGroup = lockGroup;
      }
    }, {
      key: "lockHeight",
      get:
      /**
       * 2.4.4.199 LockHeight
       * @see {http://localhost/MS-VSDX.pdf#page=198}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._lockHeight;
        if (cell === undefined) cell = this.getParentCell('lockHeight');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.200 LockMoveX
       * @see {http://localhost/MS-VSDX.pdf#page=198}
       * @param {VisioCell} lockMoveX
       */,
      set: function set(lockHeight) {
        this.attributeSet('lockHeight');
        this._lockHeight = lockHeight;
      }
    }, {
      key: "lockMoveX",
      get:
      /**
       * 2.4.4.200 LockMoveX
       * @see {http://localhost/MS-VSDX.pdf#page=198}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._lockMoveX;
        if (cell === undefined) cell = this.getParentCell('lockMoveX');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.201 LockMoveY
       * @see {http://localhost/MS-VSDX.pdf#page=198}
       * @param {VisioCell} lockMoveY
       */,
      set: function set(lockMoveX) {
        this.attributeSet('lockMoveX');
        this._lockMoveX = lockMoveX;
      }
    }, {
      key: "lockMoveY",
      get:
      /**
       * 2.4.4.201 LockMoveY
       * @see {http://localhost/MS-VSDX.pdf#page=198}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._lockMoveY;
        if (cell === undefined) cell = this.getParentCell('lockMoveY');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.202 LockPreview
       * @see {http://localhost/MS-VSDX.pdf#page=198}
       * @param {VisioCell} lockPreview
       */,
      set: function set(lockMoveY) {
        this.attributeSet('lockMoveY');
        this._lockMoveY = lockMoveY;
      }
    }, {
      key: "lockPreview",
      get:
      /**
       * 2.4.4.202 LockPreview
       * @see {http://localhost/MS-VSDX.pdf#page=198}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._lockPreview;
        if (cell === undefined) cell = this.getParentCell('lockPreview');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.203 LockReplace
       * @see {http://localhost/MS-VSDX.pdf#page=198}
       * @param {VisioCell} lockReplace
       */,
      set: function set(lockPreview) {
        this.attributeSet('lockPreview');
        this._lockPreview = lockPreview;
      }
    }, {
      key: "lockReplace",
      get:
      /**
       * 2.4.4.203 LockReplace
       * @see {http://localhost/MS-VSDX.pdf#page=198}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._lockReplace;
        if (cell === undefined) cell = this.getParentCell('lockReplace');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.204 LockRotate
       * @see {http://localhost/MS-VSDX.pdf#page=198}
       * @param {VisioCell} lockRotate
       */,
      set: function set(lockReplace) {
        this.attributeSet('lockReplace');
        this._lockReplace = lockReplace;
      }
    }, {
      key: "lockRotate",
      get:
      /**
       * 2.4.4.204 LockRotate
       * @see {http://localhost/MS-VSDX.pdf#page=198}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._lockRotate;
        if (cell === undefined) cell = this.getParentCell('lockRotate');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.205 LockSelect
       * @see {http://localhost/MS-VSDX.pdf#page=199}
       * @param {VisioCell} lockSelect
       */,
      set: function set(lockRotate) {
        this.attributeSet('lockRotate');
        this._lockRotate = lockRotate;
      }
    }, {
      key: "lockSelect",
      get:
      /**
       * 2.4.4.205 LockSelect
       * @see {http://localhost/MS-VSDX.pdf#page=199}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._lockSelect;
        if (cell === undefined) cell = this.getParentCell('lockSelect');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.206 LockTextEdit
       * @see {http://localhost/MS-VSDX.pdf#page=199}
       * @param {VisioCell} lockTextEdit
       */,
      set: function set(lockSelect) {
        this.attributeSet('lockSelect');
        this._lockSelect = lockSelect;
      }
    }, {
      key: "lockTextEdit",
      get:
      /**
       * 2.4.4.206 LockTextEdit
       * @see {http://localhost/MS-VSDX.pdf#page=199}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._lockTextEdit;
        if (cell === undefined) cell = this.getParentCell('lockTextEdit');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.207 LockThemeColors
       * @see {http://localhost/MS-VSDX.pdf#page=199}
       * @param {VisioCell} lockThemeColors
       */,
      set: function set(lockTextEdit) {
        this.attributeSet('lockTextEdit');
        this._lockTextEdit = lockTextEdit;
      }
    }, {
      key: "lockThemeColors",
      get:
      /**
       * 2.4.4.207 LockThemeColors
       * @see {http://localhost/MS-VSDX.pdf#page=199}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._lockThemeColors;
        if (cell === undefined) cell = this.getParentCell('lockThemeColors');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.208 LockThemeConnectors
       * @see {http://localhost/MS-VSDX.pdf#page=199}
       * @param {VisioCell} lockThemeConnectors
       */,
      set: function set(lockThemeColors) {
        this.attributeSet('lockThemeColors');
        this._lockThemeColors = lockThemeColors;
      }
    }, {
      key: "lockThemeConnectors",
      get:
      /**
       * 2.4.4.208 LockThemeConnectors
       * @see {http://localhost/MS-VSDX.pdf#page=199}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._lockThemeConnectors;
        if (cell === undefined) cell = this.getParentCell('lockThemeConnectors');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.209 LockThemeEffects
       * @see {http://localhost/MS-VSDX.pdf#page=199}
       * @param {VisioCell} lockThemeEffects
       */,
      set: function set(lockThemeConnectors) {
        this.attributeSet('lockThemeConnectors');
        this._lockThemeConnectors = lockThemeConnectors;
      }
    }, {
      key: "lockThemeEffects",
      get:
      /**
       * 2.4.4.209 LockThemeEffects
       * @see {http://localhost/MS-VSDX.pdf#page=199}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._lockThemeEffects;
        if (cell === undefined) cell = this.getParentCell('lockThemeEffects');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.210 LockThemeFonts
       * @see {http://localhost/MS-VSDX.pdf#page=199}
       * @param {VisioCell} lockThemeFonts
       */,
      set: function set(lockThemeEffects) {
        this.attributeSet('lockThemeEffects');
        this._lockThemeEffects = lockThemeEffects;
      }
    }, {
      key: "lockThemeFonts",
      get:
      /**
       * 2.4.4.210 LockThemeFonts
       * @see {http://localhost/MS-VSDX.pdf#page=199}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._lockThemeFonts;
        if (cell === undefined) cell = this.getParentCell('lockThemeFonts');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.211 LockThemeIndex
       * @see {http://localhost/MS-VSDX.pdf#page=199}
       * @param {VisioCell} lockThemeIndex
       */,
      set: function set(lockThemeFonts) {
        this.attributeSet('lockThemeFonts');
        this._lockThemeFonts = lockThemeFonts;
      }
    }, {
      key: "lockThemeIndex",
      get:
      /**
       * 2.4.4.211 LockThemeIndex
       * @see {http://localhost/MS-VSDX.pdf#page=199}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._lockThemeIndex;
        if (cell === undefined) cell = this.getParentCell('lockThemeIndex');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.212 LockVariation
       * @see {http://localhost/MS-VSDX.pdf#page=199}
       * @param {VisioCell} lockVariation
       */,
      set: function set(lockThemeIndex) {
        this.attributeSet('lockThemeIndex');
        this._lockThemeIndex = lockThemeIndex;
      }
    }, {
      key: "lockVariation",
      get:
      /**
       * 2.4.4.212 LockVariation
       * @see {http://localhost/MS-VSDX.pdf#page=199}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._lockVariation;
        if (cell === undefined) cell = this.getParentCell('lockVariation');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.213 LockVtxEdit
       * @see {http://localhost/MS-VSDX.pdf#page=199}
       * @param {VisioCell} lockVtxEdit
       */,
      set: function set(lockVariation) {
        this.attributeSet('lockVariation');
        this._lockVariation = lockVariation;
      }
    }, {
      key: "lockVtxEdit",
      get:
      /**
       * 2.4.4.213 LockVtxEdit
       * @see {http://localhost/MS-VSDX.pdf#page=199}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._lockVtxEdit;
        if (cell === undefined) cell = this.getParentCell('lockVtxEdit');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.214 LockWidth
       * @see {http://localhost/MS-VSDX.pdf#page=199}
       * @param {VisioCell} lockWidth
       */,
      set: function set(lockVtxEdit) {
        this.attributeSet('lockVtxEdit');
        this._lockVtxEdit = lockVtxEdit;
      }
    }, {
      key: "lockWidth",
      get:
      /**
       * 2.4.4.214 LockWidth
       * @see {http://localhost/MS-VSDX.pdf#page=199}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._lockWidth;
        if (cell === undefined) cell = this.getParentCell('lockWidth');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.215 LocPinX
       * @see {http://localhost/MS-VSDX.pdf#page=200}
       * @param {VisioCell} locPinX
       */,
      set: function set(lockWidth) {
        this.attributeSet('lockWidth');
        this._lockWidth = lockWidth;
      }
    }, {
      key: "locPinX",
      get:
      /**
       * 2.4.4.215 LocPinX
       * @see {http://localhost/MS-VSDX.pdf#page=200}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._locPinX;
        if (cell === undefined) cell = this.getParentCell('locPinX');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.216 LocPinY
       * @see {http://localhost/MS-VSDX.pdf#page=200}
       * @param {VisioCell} locPinY
       */,
      set: function set(locPinX) {
        this.attributeSet('locPinX');
        this._locPinX = locPinX;
      }
    }, {
      key: "locPinY",
      get:
      /**
       * 2.4.4.216 LocPinY
       * @see {http://localhost/MS-VSDX.pdf#page=200}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._locPinY;
        if (cell === undefined) cell = this.getParentCell('locPinY');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.217 Menu
       * @see {http://localhost/MS-VSDX.pdf#page=200}
       * @param {VisioCell} menu
       */,
      set: function set(locPinY) {
        this.attributeSet('locPinY');
        this._locPinY = locPinY;
      }
    }, {
      key: "menu",
      get:
      /**
       * 2.4.4.217 Menu
       * @see {http://localhost/MS-VSDX.pdf#page=200}
       */
      function get() {
        var visioType = VisioValueType.PtgString;
        var cell = this._menu;
        if (cell === undefined) cell = this.getParentCell('menu');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.218 Name
       * @see {http://localhost/MS-VSDX.pdf#page=200}
       * @param {VisioCell} name
       */,
      set: function set(menu) {
        this.attributeSet('menu');
        this._menu = menu;
      }
    }, {
      key: "name",
      get:
      /**
       * 2.4.4.218 Name
       * @see {http://localhost/MS-VSDX.pdf#page=200}
       */
      function get() {
        var visioType = VisioValueType.PtgString;
        var cell = this._name;
        if (cell === undefined) cell = this.getParentCell('name');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.219 NameUniv
       * @see {http://localhost/MS-VSDX.pdf#page=200}
       * @param {VisioCell} nameUniv
       */,
      set: function set(name) {
        this.attributeSet('name');
        this._name = name;
      }
    }, {
      key: "nameUniv",
      get:
      /**
       * 2.4.4.219 NameUniv
       * @see {http://localhost/MS-VSDX.pdf#page=200}
       */
      function get() {
        var visioType = VisioValueType.PtgString;
        var cell = this._nameUniv;
        if (cell === undefined) cell = this.getParentCell('nameUniv');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.220 NewWindow
       * @see {http://localhost/MS-VSDX.pdf#page=200}
       * @param {VisioCell} newWindow
       */,
      set: function set(nameUniv) {
        this.attributeSet('nameUniv');
        this._nameUniv = nameUniv;
      }
    }, {
      key: "newWindow",
      get:
      /**
       * 2.4.4.220 NewWindow
       * @see {http://localhost/MS-VSDX.pdf#page=200}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._newWindow;
        if (cell === undefined) cell = this.getParentCell('newWindow');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.221 NoAlignBox
       * @see {http://localhost/MS-VSDX.pdf#page=200}
       * @param {VisioCell} noAlignBox
       */,
      set: function set(newWindow) {
        this.attributeSet('newWindow');
        this._newWindow = newWindow;
      }
    }, {
      key: "noAlignBox",
      get:
      /**
       * 2.4.4.221 NoAlignBox
       * @see {http://localhost/MS-VSDX.pdf#page=200}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._noAlignBox;
        if (cell === undefined) cell = this.getParentCell('noAlignBox');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.222 NoCoauth
       * @see {http://localhost/MS-VSDX.pdf#page=200}
       * @param {VisioCell} noCoauth
       */,
      set: function set(noAlignBox) {
        this.attributeSet('noAlignBox');
        this._noAlignBox = noAlignBox;
      }
    }, {
      key: "noCoauth",
      get:
      /**
       * 2.4.4.222 NoCoauth
       * @see {http://localhost/MS-VSDX.pdf#page=200}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._noCoauth;
        if (cell === undefined) cell = this.getParentCell('noCoauth');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.223 NoCtlHandles
       * @see {http://localhost/MS-VSDX.pdf#page=200}
       * @param {VisioCell} noCtlHandles
       */,
      set: function set(noCoauth) {
        this.attributeSet('noCoauth');
        this._noCoauth = noCoauth;
      }
    }, {
      key: "noCtlHandles",
      get:
      /**
       * 2.4.4.223 NoCtlHandles
       * @see {http://localhost/MS-VSDX.pdf#page=200}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._noCtlHandles;
        if (cell === undefined) cell = this.getParentCell('noCtlHandles');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.224 NoFill
       * @see {http://localhost/MS-VSDX.pdf#page=200}
       * @param {VisioCell} noFill
       */,
      set: function set(noCtlHandles) {
        this.attributeSet('noCtlHandles');
        this._noCtlHandles = noCtlHandles;
      }
    }, {
      key: "noFill",
      get:
      /**
       * 2.4.4.224 NoFill
       * @see {http://localhost/MS-VSDX.pdf#page=200}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._noFill;
        if (cell === undefined) cell = this.getParentCell('noFill');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.225 NoLine
       * @see {http://localhost/MS-VSDX.pdf#page=201}
       * @param {VisioCell} noLine
       */,
      set: function set(noFill) {
        this.attributeSet('noFill');
        this._noFill = noFill;
      }
    }, {
      key: "noLine",
      get:
      /**
       * 2.4.4.225 NoLine
       * @see {http://localhost/MS-VSDX.pdf#page=201}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._noLine;
        if (cell === undefined) cell = this.getParentCell('noLine');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.226 NoLiveDynamics
       * @see {http://localhost/MS-VSDX.pdf#page=201}
       * @param {VisioCell} noLiveDynamics
       */,
      set: function set(noLine) {
        this.attributeSet('noLine');
        this._noLine = noLine;
      }
    }, {
      key: "noLiveDynamics",
      get:
      /**
       * 2.4.4.226 NoLiveDynamics
       * @see {http://localhost/MS-VSDX.pdf#page=201}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._noLiveDynamics;
        if (cell === undefined) cell = this.getParentCell('noLiveDynamics');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.227 NonPrinting
       * @see {http://localhost/MS-VSDX.pdf#page=201}
       * @param {VisioCell} nonPrinting
       */,
      set: function set(noLiveDynamics) {
        this.attributeSet('noLiveDynamics');
        this._noLiveDynamics = noLiveDynamics;
      }
    }, {
      key: "nonPrinting",
      get:
      /**
       * 2.4.4.227 NonPrinting
       * @see {http://localhost/MS-VSDX.pdf#page=201}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._nonPrinting;
        if (cell === undefined) cell = this.getParentCell('nonPrinting');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.228 NoObjHandles
       * @see {http://localhost/MS-VSDX.pdf#page=201}
       * @param {VisioCell} noObjHandles
       */,
      set: function set(nonPrinting) {
        this.attributeSet('nonPrinting');
        this._nonPrinting = nonPrinting;
      }
    }, {
      key: "noObjHandles",
      get:
      /**
       * 2.4.4.228 NoObjHandles
       * @see {http://localhost/MS-VSDX.pdf#page=201}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._noObjHandles;
        if (cell === undefined) cell = this.getParentCell('noObjHandles');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.229 NoProofing
       * @see {http://localhost/MS-VSDX.pdf#page=201}
       * @param {VisioCell} noProofing
       */,
      set: function set(noObjHandles) {
        this.attributeSet('noObjHandles');
        this._noObjHandles = noObjHandles;
      }
    }, {
      key: "noProofing",
      get:
      /**
       * 2.4.4.229 NoProofing
       * @see {http://localhost/MS-VSDX.pdf#page=201}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._noProofing;
        if (cell === undefined) cell = this.getParentCell('noProofing');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.230 NoQuickDrag
       * @see {http://localhost/MS-VSDX.pdf#page=201}
       * @param {VisioCell} noQuickDrag
       */,
      set: function set(noProofing) {
        this.attributeSet('noProofing');
        this._noProofing = noProofing;
      }
    }, {
      key: "noQuickDrag",
      get:
      /**
       * 2.4.4.230 NoQuickDrag
       * @see {http://localhost/MS-VSDX.pdf#page=201}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._noQuickDrag;
        if (cell === undefined) cell = this.getParentCell('noQuickDrag');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.231 NoShow
       * @see {http://localhost/MS-VSDX.pdf#page=201}
       * @param {VisioCell} noShow
       */,
      set: function set(noQuickDrag) {
        this.attributeSet('noQuickDrag');
        this._noQuickDrag = noQuickDrag;
      }
    }, {
      key: "noShow",
      get:
      /**
       * 2.4.4.231 NoShow
       * @see {http://localhost/MS-VSDX.pdf#page=201}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._noShow;
        if (cell === undefined) cell = this.getParentCell('noShow');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.232 NoSnap
       * @see {http://localhost/MS-VSDX.pdf#page=201}
       * @param {VisioCell} noSnap
       */,
      set: function set(noShow) {
        this.attributeSet('noShow');
        this._noShow = noShow;
      }
    }, {
      key: "noSnap",
      get:
      /**
       * 2.4.4.232 NoSnap
       * @see {http://localhost/MS-VSDX.pdf#page=201}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._noSnap;
        if (cell === undefined) cell = this.getParentCell('noSnap');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.233 ObjectKind
       * @see {http://localhost/MS-VSDX.pdf#page=201}
       * @param {VisioCell} objectKind
       */,
      set: function set(noSnap) {
        this.attributeSet('noSnap');
        this._noSnap = noSnap;
      }
    }, {
      key: "objectKind",
      get:
      /**
       * 2.4.4.233 ObjectKind
       * @see {http://localhost/MS-VSDX.pdf#page=201}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._objectKind;
        if (cell === undefined) cell = this.getParentCell('objectKind');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.234 ObjType
       * @see {http://localhost/MS-VSDX.pdf#page=202}
       * @param {VisioCell} objType
       */,
      set: function set(objectKind) {
        this.attributeSet('objectKind');
        this._objectKind = objectKind;
      }
    }, {
      key: "objType",
      get:
      /**
       * 2.4.4.234 ObjType
       * @see {http://localhost/MS-VSDX.pdf#page=202}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._objType;
        if (cell === undefined) cell = this.getParentCell('objType');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.235 OnPage
       * @see {http://localhost/MS-VSDX.pdf#page=202}
       * @param {VisioCell} onPage
       */,
      set: function set(objType) {
        this.attributeSet('objType');
        this._objType = objType;
      }
    }, {
      key: "onPage",
      get:
      /**
       * 2.4.4.235 OnPage
       * @see {http://localhost/MS-VSDX.pdf#page=202}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._onPage;
        if (cell === undefined) cell = this.getParentCell('onPage');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.236 OutputFormat
       * @see {http://localhost/MS-VSDX.pdf#page=202}
       * @param {VisioCell} outputFormat
       */,
      set: function set(onPage) {
        this.attributeSet('onPage');
        this._onPage = onPage;
      }
    }, {
      key: "outputFormat",
      get:
      /**
       * 2.4.4.236 OutputFormat
       * @see {http://localhost/MS-VSDX.pdf#page=202}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._outputFormat;
        if (cell === undefined) cell = this.getParentCell('outputFormat');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.237 Overline
       * @see {http://localhost/MS-VSDX.pdf#page=202}
       * @param {VisioCell} overline
       */,
      set: function set(outputFormat) {
        this.attributeSet('outputFormat');
        this._outputFormat = outputFormat;
      }
    }, {
      key: "overline",
      get:
      /**
       * 2.4.4.237 Overline
       * @see {http://localhost/MS-VSDX.pdf#page=202}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._overline;
        if (cell === undefined) cell = this.getParentCell('overline');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.238 PageBottomMargin
       * @see {http://localhost/MS-VSDX.pdf#page=202}
       * @param {VisioCell} pageBottomMargin
       */,
      set: function set(overline) {
        this.attributeSet('overline');
        this._overline = overline;
      }
    }, {
      key: "pageBottomMargin",
      get:
      /**
       * 2.4.4.238 PageBottomMargin
       * @see {http://localhost/MS-VSDX.pdf#page=202}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._pageBottomMargin;
        if (cell === undefined) cell = this.getParentCell('pageBottomMargin');
        if (cell === undefined) return this.getDefaultCellValue(visioType);
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.239 PageHeight
       * @see {http://localhost/MS-VSDX.pdf#page=202}
       * @param {VisioCell} pageHeight
       */,
      set: function set(pageBottomMargin) {
        this.attributeSet('pageBottomMargin');
        this._pageBottomMargin = pageBottomMargin;
      }
    }, {
      key: "pageHeight",
      get:
      /**
       * 2.4.4.239 PageHeight
       * @see {http://localhost/MS-VSDX.pdf#page=202}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._pageHeight;
        if (cell === undefined) cell = this.getParentCell('pageHeight');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.240 PageLeftMargin
       * @see {http://localhost/MS-VSDX.pdf#page=202}
       * @param {VisioCell} pageLeftMargin
       */,
      set: function set(pageHeight) {
        this.attributeSet('pageHeight');
        this._pageHeight = pageHeight;
      }
    }, {
      key: "pageLeftMargin",
      get:
      /**
       * 2.4.4.240 PageLeftMargin
       * @see {http://localhost/MS-VSDX.pdf#page=202}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._pageLeftMargin;
        if (cell === undefined) cell = this.getParentCell('pageLeftMargin');
        if (cell === undefined) return this.getDefaultCellValue(visioType);
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.241 PageLineJumpDirX
       * @see {http://localhost/MS-VSDX.pdf#page=202}
       * @param {VisioCell} pageLineJumpDirX
       */,
      set: function set(pageLeftMargin) {
        this.attributeSet('pageLeftMargin');
        this._pageLeftMargin = pageLeftMargin;
      }
    }, {
      key: "pageLineJumpDirX",
      get:
      /**
       * 2.4.4.241 PageLineJumpDirX
       * @see {http://localhost/MS-VSDX.pdf#page=202}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._pageLineJumpDirX;
        if (cell === undefined) cell = this.getParentCell('pageLineJumpDirX');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.242 PageLineJumpDirY
       * @see {http://localhost/MS-VSDX.pdf#page=203}
       * @param {VisioCell} pageLineJumpDirY
       */,
      set: function set(pageLineJumpDirX) {
        this.attributeSet('pageLineJumpDirX');
        this._pageLineJumpDirX = pageLineJumpDirX;
      }
    }, {
      key: "pageLineJumpDirY",
      get:
      /**
       * 2.4.4.242 PageLineJumpDirY
       * @see {http://localhost/MS-VSDX.pdf#page=203}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._pageLineJumpDirY;
        if (cell === undefined) cell = this.getParentCell('pageLineJumpDirY');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.243 PageLockDuplicate
       * @see {http://localhost/MS-VSDX.pdf#page=203}
       * @param {VisioCell} pageLockDuplicate
       */,
      set: function set(pageLineJumpDirY) {
        this.attributeSet('pageLineJumpDirY');
        this._pageLineJumpDirY = pageLineJumpDirY;
      }
    }, {
      key: "pageLockDuplicate",
      get:
      /**
       * 2.4.4.243 PageLockDuplicate
       * @see {http://localhost/MS-VSDX.pdf#page=203}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._pageLockDuplicate;
        if (cell === undefined) cell = this.getParentCell('pageLockDuplicate');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.244 PageLockReplace
       * @see {http://localhost/MS-VSDX.pdf#page=203}
       * @param {VisioCell} pageLockReplace
       */,
      set: function set(pageLockDuplicate) {
        this.attributeSet('pageLockDuplicate');
        this._pageLockDuplicate = pageLockDuplicate;
      }
    }, {
      key: "pageLockReplace",
      get:
      /**
       * 2.4.4.244 PageLockReplace
       * @see {http://localhost/MS-VSDX.pdf#page=203}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._pageLockReplace;
        if (cell === undefined) cell = this.getParentCell('pageLockReplace');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.245 PageRightMargin
       * @see {http://localhost/MS-VSDX.pdf#page=203}
       * @param {VisioCell} pageRightMargin
       */,
      set: function set(pageLockReplace) {
        this.attributeSet('pageLockReplace');
        this._pageLockReplace = pageLockReplace;
      }
    }, {
      key: "pageRightMargin",
      get:
      /**
       * 2.4.4.245 PageRightMargin
       * @see {http://localhost/MS-VSDX.pdf#page=203}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._pageRightMargin;
        if (cell === undefined) cell = this.getParentCell('pageRightMargin');
        if (cell === undefined) return this.getDefaultCellValue(visioType);
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.246 PageScale
       * @see {http://localhost/MS-VSDX.pdf#page=203}
       * @param {VisioCell} pageScale
       */,
      set: function set(pageRightMargin) {
        this.attributeSet('pageRightMargin');
        this._pageRightMargin = pageRightMargin;
      }
    }, {
      key: "pageScale",
      get:
      /**
       * 2.4.4.246 PageScale
       * @see {http://localhost/MS-VSDX.pdf#page=203}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._pageScale;
        if (cell === undefined) cell = this.getParentCell('pageScale');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.247 PageShapeSplit
       * @see {http://localhost/MS-VSDX.pdf#page=203}
       * @param {VisioCell} pageShapeSplit
       */,
      set: function set(pageScale) {
        this.attributeSet('pageScale');
        this._pageScale = pageScale;
      }
    }, {
      key: "pageShapeSplit",
      get:
      /**
       * 2.4.4.247 PageShapeSplit
       * @see {http://localhost/MS-VSDX.pdf#page=203}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._pageShapeSplit;
        if (cell === undefined) cell = this.getParentCell('pageShapeSplit');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.248 PagesX
       * @see {http://localhost/MS-VSDX.pdf#page=203}
       * @param {VisioCell} pagesX
       */,
      set: function set(pageShapeSplit) {
        this.attributeSet('pageShapeSplit');
        this._pageShapeSplit = pageShapeSplit;
      }
    }, {
      key: "pagesX",
      get:
      /**
       * 2.4.4.248 PagesX
       * @see {http://localhost/MS-VSDX.pdf#page=203}
       */
      function get() {
        var visioType = VisioValueType.PtgUnsShort;
        var cell = this._pagesX;
        if (cell === undefined) cell = this.getParentCell('pagesX');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.249 PagesY
       * @see {http://localhost/MS-VSDX.pdf#page=203}
       * @param {VisioCell} pagesY
       */,
      set: function set(pagesX) {
        this.attributeSet('pagesX');
        this._pagesX = pagesX;
      }
    }, {
      key: "pagesY",
      get:
      /**
       * 2.4.4.249 PagesY
       * @see {http://localhost/MS-VSDX.pdf#page=203}
       */
      function get() {
        var visioType = VisioValueType.PtgUnsShort;
        var cell = this._pagesY;
        if (cell === undefined) cell = this.getParentCell('pagesY');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.250 PageTopMargin
       * @see {http://localhost/MS-VSDX.pdf#page=203}
       * @param {VisioCell} pageTopMargin
       */,
      set: function set(pagesY) {
        this.attributeSet('pagesY');
        this._pagesY = pagesY;
      }
    }, {
      key: "pageTopMargin",
      get:
      /**
       * 2.4.4.250 PageTopMargin
       * @see {http://localhost/MS-VSDX.pdf#page=203}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._pageTopMargin;
        if (cell === undefined) cell = this.getParentCell('pageTopMargin');
        if (cell === undefined) return this.getDefaultCellValue(visioType);
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.251 PageWidth
       * @see {http://localhost/MS-VSDX.pdf#page=203}
       * @param {VisioCell} pageWidth
       */,
      set: function set(pageTopMargin) {
        this.attributeSet('pageTopMargin');
        this._pageTopMargin = pageTopMargin;
      }
    }, {
      key: "pageWidth",
      get:
      /**
       * 2.4.4.251 PageWidth
       * @see {http://localhost/MS-VSDX.pdf#page=203}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._pageWidth;
        if (cell === undefined) cell = this.getParentCell('pageWidth');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.252 PaperKind
       * @see {http://localhost/MS-VSDX.pdf#page=204}
       * @param {VisioCell} paperKind
       */,
      set: function set(pageWidth) {
        this.attributeSet('pageWidth');
        this._pageWidth = pageWidth;
      }
    }, {
      key: "paperKind",
      get:
      /**
       * 2.4.4.252 PaperKind
       * @see {http://localhost/MS-VSDX.pdf#page=204}
       */
      function get() {
        var visioType = VisioValueType.PtgUnsShort;
        var cell = this._paperKind;
        if (cell === undefined) cell = this.getParentCell('paperKind');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.253 PaperSource
       * @see {http://localhost/MS-VSDX.pdf#page=204}
       * @param {VisioCell} paperSource
       */,
      set: function set(paperKind) {
        this.attributeSet('paperKind');
        this._paperKind = paperKind;
      }
    }, {
      key: "paperSource",
      get:
      /**
       * 2.4.4.253 PaperSource
       * @see {http://localhost/MS-VSDX.pdf#page=204}
       */
      function get() {
        var visioType = VisioValueType.PtgUnsShort;
        var cell = this._paperSource;
        if (cell === undefined) cell = this.getParentCell('paperSource');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.254 Perspective
       * @see {http://localhost/MS-VSDX.pdf#page=204}
       * @param {VisioCell} perspective
       */,
      set: function set(paperSource) {
        this.attributeSet('paperSource');
        this._paperSource = paperSource;
      }
    }, {
      key: "perspective",
      get:
      /**
       * 2.4.4.254 Perspective
       * @see {http://localhost/MS-VSDX.pdf#page=204}
       */
      function get() {
        var cell = this._perspective;
        if (cell === undefined) cell = this.getParentCell('perspective');
        var visioType = VisioValueType.vAngle;
        //TODO miky
        // VisioValueType.vScalar
        debug.log('resolve cell type "perspective"');
        if (cell.units) {
          debug.log('vScalar unclear');
        }
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.255 PinX
       * @see {http://localhost/MS-VSDX.pdf#page=204}
       * @param {VisioCell} pinX
       */,
      set: function set(perspective) {
        this.attributeSet('perspective');
        this._perspective = perspective;
      }
    }, {
      key: "pinX",
      get:
      /**
       * 2.4.4.255 PinX
       * @see {http://localhost/MS-VSDX.pdf#page=204}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._pinX;
        if (cell === undefined) cell = this.getParentCell('pinX');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.256 PinY
       * @see {http://localhost/MS-VSDX.pdf#page=204}
       * @param {VisioCell} pinY
       */,
      set: function set(pinX) {
        this.attributeSet('pinX');
        this._pinX = pinX;
      }
    }, {
      key: "pinY",
      get:
      /**
       * 2.4.4.256 PinY
       * @see {http://localhost/MS-VSDX.pdf#page=204}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._pinY;
        if (cell === undefined) cell = this.getParentCell('pinY');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.257 PlaceDepth
       * @see {http://localhost/MS-VSDX.pdf#page=204}
       * @param {VisioCell} placeDepth
       */,
      set: function set(pinY) {
        this.attributeSet('pinY');
        this._pinY = pinY;
      }
    }, {
      key: "placeDepth",
      get:
      /**
       * 2.4.4.257 PlaceDepth
       * @see {http://localhost/MS-VSDX.pdf#page=204}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._placeDepth;
        if (cell === undefined) cell = this.getParentCell('placeDepth');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.258 PlaceFlip
       * @see {http://localhost/MS-VSDX.pdf#page=204}
       * @param {VisioCell} placeFlip
       */,
      set: function set(placeDepth) {
        this.attributeSet('placeDepth');
        this._placeDepth = placeDepth;
      }
    }, {
      key: "placeFlip",
      get:
      /**
       * 2.4.4.258 PlaceFlip
       * @see {http://localhost/MS-VSDX.pdf#page=204}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._placeFlip;
        if (cell === undefined) cell = this.getParentCell('placeFlip');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.259 PlaceStyle
       * @see {http://localhost/MS-VSDX.pdf#page=204}
       * @param {VisioCell} placeStyle
       */,
      set: function set(placeFlip) {
        this.attributeSet('placeFlip');
        this._placeFlip = placeFlip;
      }
    }, {
      key: "placeStyle",
      get:
      /**
       * 2.4.4.259 PlaceStyle
       * @see {http://localhost/MS-VSDX.pdf#page=204}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._placeStyle;
        if (cell === undefined) cell = this.getParentCell('placeStyle');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.260 PlowCode
       * @see {http://localhost/MS-VSDX.pdf#page=204}
       * @param {VisioCell} plowCode
       */,
      set: function set(placeStyle) {
        this.attributeSet('placeStyle');
        this._placeStyle = placeStyle;
      }
    }, {
      key: "plowCode",
      get:
      /**
       * 2.4.4.260 PlowCode
       * @see {http://localhost/MS-VSDX.pdf#page=204}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._plowCode;
        if (cell === undefined) cell = this.getParentCell('plowCode');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.261 Pos
       * @see {http://localhost/MS-VSDX.pdf#page=205}
       * @param {VisioCell} pos
       */,
      set: function set(plowCode) {
        this.attributeSet('plowCode');
        this._plowCode = plowCode;
      }
    }, {
      key: "pos",
      get:
      /**
       * 2.4.4.261 Pos
       * @see {http://localhost/MS-VSDX.pdf#page=205}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._pos;
        if (cell === undefined) cell = this.getParentCell('pos');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.262 Position
       * @see {http://localhost/MS-VSDX.pdf#page=205}
       * @param {VisioCell} position
       */,
      set: function set(pos) {
        this.attributeSet('pos');
        this._pos = pos;
      }
    }, {
      key: "position",
      get:
      /**
       * 2.4.4.262 Position
       * @see {http://localhost/MS-VSDX.pdf#page=205}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._position;
        if (cell === undefined) cell = this.getParentCell('position');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.263 PreviewQuality
       * @see {http://localhost/MS-VSDX.pdf#page=205}
       * @param {VisioCell} previewQuality
       */,
      set: function set(position) {
        this.attributeSet('position');
        this._position = position;
      }
    }, {
      key: "previewQuality",
      get:
      /**
       * 2.4.4.263 PreviewQuality
       * @see {http://localhost/MS-VSDX.pdf#page=205}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._previewQuality;
        if (cell === undefined) cell = this.getParentCell('previewQuality');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.264 PreviewScope
       * @see {http://localhost/MS-VSDX.pdf#page=205}
       * @param {VisioCell} previewScope
       */,
      set: function set(previewQuality) {
        this.attributeSet('previewQuality');
        this._previewQuality = previewQuality;
      }
    }, {
      key: "previewScope",
      get:
      /**
       * 2.4.4.264 PreviewScope
       * @see {http://localhost/MS-VSDX.pdf#page=205}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._previewScope;
        if (cell === undefined) cell = this.getParentCell('previewScope');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.265 Print
       * @see {http://localhost/MS-VSDX.pdf#page=205}
       * @param {VisioCell} print
       */,
      set: function set(previewScope) {
        this.attributeSet('previewScope');
        this._previewScope = previewScope;
      }
    }, {
      key: "print",
      get:
      /**
       * 2.4.4.265 Print
       * @see {http://localhost/MS-VSDX.pdf#page=205}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._print;
        if (cell === undefined) cell = this.getParentCell('print');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.266 PrintGrid
       * @see {http://localhost/MS-VSDX.pdf#page=205}
       * @param {VisioCell} printGrid
       */,
      set: function set(print) {
        this.attributeSet('print');
        this._print = print;
      }
    }, {
      key: "printGrid",
      get:
      /**
       * 2.4.4.266 PrintGrid
       * @see {http://localhost/MS-VSDX.pdf#page=205}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._printGrid;
        if (cell === undefined) cell = this.getParentCell('printGrid');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.267 PrintPageOrientation
       * @see {http://localhost/MS-VSDX.pdf#page=205}
       * @param {VisioCell} printPageOrientation
       */,
      set: function set(printGrid) {
        this.attributeSet('printGrid');
        this._printGrid = printGrid;
      }
    }, {
      key: "printPageOrientation",
      get:
      /**
       * 2.4.4.267 PrintPageOrientation
       * @see {http://localhost/MS-VSDX.pdf#page=205}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._printPageOrientation;
        if (cell === undefined) cell = this.getParentCell('printPageOrientation');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.268 Prompt
       * @see {http://localhost/MS-VSDX.pdf#page=206}
       * @param {VisioCell} prompt
       */,
      set: function set(printPageOrientation) {
        this.attributeSet('printPageOrientation');
        this._printPageOrientation = printPageOrientation;
      }
    }, {
      key: "prompt",
      get:
      /**
       * 2.4.4.268 Prompt
       * @see {http://localhost/MS-VSDX.pdf#page=206}
       */
      function get() {
        var visioType = VisioValueType.PtgString;
        var cell = this._prompt;
        if (cell === undefined) cell = this.getParentCell('prompt');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.269 QuickStyleEffectsMatrix
       * @see {http://localhost/MS-VSDX.pdf#page=206}
       * @param {VisioCell} quickStyleEffectsMatrix
       */,
      set: function set(prompt) {
        this.attributeSet('prompt');
        this._prompt = prompt;
      }
    }, {
      key: "quickStyleEffectsMatrix",
      get:
      /**
       * 2.4.4.269 QuickStyleEffectsMatrix
       * @see {http://localhost/MS-VSDX.pdf#page=206}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._quickStyleEffectsMatrix;
        if (cell === undefined) cell = this.getParentCell('quickStyleEffectsMatrix');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.270 QuickStyleFillColor
       * @see {http://localhost/MS-VSDX.pdf#page=207}
       * @param {VisioCell} quickStyleFillColor
       */,
      set: function set(quickStyleEffectsMatrix) {
        this.attributeSet('quickStyleEffectsMatrix');
        this._quickStyleEffectsMatrix = quickStyleEffectsMatrix;
      }
    }, {
      key: "quickStyleFillColor",
      get:
      /**
       * 2.4.4.270 QuickStyleFillColor
       * @see {http://localhost/MS-VSDX.pdf#page=207}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._quickStyleFillColor;
        if (cell === undefined) cell = this.getParentCell('quickStyleFillColor');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.271 QuickStyleFillMatrix
       * @see {http://localhost/MS-VSDX.pdf#page=208}
       * @param {VisioCell} quickStyleFillMatrix
       */,
      set: function set(quickStyleFillColor) {
        this.attributeSet('quickStyleFillColor');
        this._quickStyleFillColor = quickStyleFillColor;
      }
    }, {
      key: "quickStyleFillMatrix",
      get:
      /**
       * 2.4.4.271 QuickStyleFillMatrix
       * @see {http://localhost/MS-VSDX.pdf#page=208}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._quickStyleFillMatrix;
        if (cell === undefined) cell = this.getParentCell('quickStyleFillMatrix');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.272 QuickStyleFontColor
       * @see {http://localhost/MS-VSDX.pdf#page=209}
       * @param {VisioCell} quickStyleFontColor
       */,
      set: function set(quickStyleFillMatrix) {
        this.attributeSet('quickStyleFillMatrix');
        this._quickStyleFillMatrix = quickStyleFillMatrix;
      }
    }, {
      key: "quickStyleFontColor",
      get:
      /**
       * 2.4.4.272 QuickStyleFontColor
       * @see {http://localhost/MS-VSDX.pdf#page=209}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._quickStyleFontColor;
        if (cell === undefined) cell = this.getParentCell('quickStyleFontColor');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.273 QuickStyleFontMatrix
       * @see {http://localhost/MS-VSDX.pdf#page=209}
       * @param {VisioCell} quickStyleFontMatrix
       */,
      set: function set(quickStyleFontColor) {
        this.attributeSet('quickStyleFontColor');
        this._quickStyleFontColor = quickStyleFontColor;
      }
    }, {
      key: "quickStyleFontMatrix",
      get:
      /**
       * 2.4.4.273 QuickStyleFontMatrix
       * @see {http://localhost/MS-VSDX.pdf#page=209}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._quickStyleFontMatrix;
        if (cell === undefined) cell = this.getParentCell('quickStyleFontMatrix');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.274 QuickStyleLineColor
       * @see {http://localhost/MS-VSDX.pdf#page=210}
       * @param {VisioCell} quickStyleLineColor
       */,
      set: function set(quickStyleFontMatrix) {
        this.attributeSet('quickStyleFontMatrix');
        this._quickStyleFontMatrix = quickStyleFontMatrix;
      }
    }, {
      key: "quickStyleLineColor",
      get:
      /**
       * 2.4.4.274 QuickStyleLineColor
       * @see {http://localhost/MS-VSDX.pdf#page=210}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._quickStyleLineColor;
        if (cell === undefined) cell = this.getParentCell('quickStyleLineColor');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.275 QuickStyleLineMatrix
       * @see {http://localhost/MS-VSDX.pdf#page=210}
       * @param {VisioCell} quickStyleLineMatrix
       */,
      set: function set(quickStyleLineColor) {
        this.attributeSet('quickStyleLineColor');
        this._quickStyleLineColor = quickStyleLineColor;
      }
    }, {
      key: "quickStyleLineMatrix",
      get:
      /**
       * 2.4.4.275 QuickStyleLineMatrix
       * @see {http://localhost/MS-VSDX.pdf#page=210}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._quickStyleLineMatrix;
        if (cell === undefined) cell = this.getParentCell('quickStyleLineMatrix');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.276 QuickStyleShadowColor
       * @see {http://localhost/MS-VSDX.pdf#page=211}
       * @param {VisioCell} quickStyleShadowColor
       */,
      set: function set(quickStyleLineMatrix) {
        this.attributeSet('quickStyleLineMatrix');
        this._quickStyleLineMatrix = quickStyleLineMatrix;
      }
    }, {
      key: "quickStyleShadowColor",
      get:
      /**
       * 2.4.4.276 QuickStyleShadowColor
       * @see {http://localhost/MS-VSDX.pdf#page=211}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._quickStyleShadowColor;
        if (cell === undefined) cell = this.getParentCell('quickStyleShadowColor');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.277 QuickStyleType
       * @see {http://localhost/MS-VSDX.pdf#page=211}
       * @param {VisioCell} quickStyleType
       */,
      set: function set(quickStyleShadowColor) {
        this.attributeSet('quickStyleShadowColor');
        this._quickStyleShadowColor = quickStyleShadowColor;
      }
    }, {
      key: "quickStyleType",
      get:
      /**
       * 2.4.4.277 QuickStyleType
       * @see {http://localhost/MS-VSDX.pdf#page=211}
       */
      function get() {
        var visioType = VisioValueType.PtgInt;
        var cell = this._quickStyleType;
        if (cell === undefined) cell = this.getParentCell('quickStyleType');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.278 QuickStyleVariation
       * @see {http://localhost/MS-VSDX.pdf#page=211}
       * @param {VisioCell} quickStyleVariation
       */,
      set: function set(quickStyleType) {
        this.attributeSet('quickStyleType');
        this._quickStyleType = quickStyleType;
      }
    }, {
      key: "quickStyleVariation",
      get:
      /**
       * 2.4.4.278 QuickStyleVariation
       * @see {http://localhost/MS-VSDX.pdf#page=211}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._quickStyleVariation;
        if (cell === undefined) cell = this.getParentCell('quickStyleVariation');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.279 ReadOnly
       * @see {http://localhost/MS-VSDX.pdf#page=213}
       * @param {VisioCell} readOnly
       */,
      set: function set(quickStyleVariation) {
        this.attributeSet('quickStyleVariation');
        this._quickStyleVariation = quickStyleVariation;
      }
    }, {
      key: "readOnly",
      get:
      /**
       * 2.4.4.279 ReadOnly
       * @see {http://localhost/MS-VSDX.pdf#page=213}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._readOnly;
        if (cell === undefined) cell = this.getParentCell('readOnly');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.280 ReflectionBlur
       * @see {http://localhost/MS-VSDX.pdf#page=213}
       * @param {VisioCell} reflectionBlur
       */,
      set: function set(readOnly) {
        this.attributeSet('readOnly');
        this._readOnly = readOnly;
      }
    }, {
      key: "reflectionBlur",
      get:
      /**
       * 2.4.4.280 ReflectionBlur
       * @see {http://localhost/MS-VSDX.pdf#page=213}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._reflectionBlur;
        if (cell === undefined) cell = this.getParentCell('reflectionBlur');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.281 ReflectionDist
       * @see {http://localhost/MS-VSDX.pdf#page=213}
       * @param {VisioCell} reflectionDist
       */,
      set: function set(reflectionBlur) {
        this.attributeSet('reflectionBlur');
        this._reflectionBlur = reflectionBlur;
      }
    }, {
      key: "reflectionDist",
      get:
      /**
       * 2.4.4.281 ReflectionDist
       * @see {http://localhost/MS-VSDX.pdf#page=213}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._reflectionDist;
        if (cell === undefined) cell = this.getParentCell('reflectionDist');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.282 ReflectionSize
       * @see {http://localhost/MS-VSDX.pdf#page=213}
       * @param {VisioCell} reflectionSize
       */,
      set: function set(reflectionDist) {
        this.attributeSet('reflectionDist');
        this._reflectionDist = reflectionDist;
      }
    }, {
      key: "reflectionSize",
      get:
      /**
       * 2.4.4.282 ReflectionSize
       * @see {http://localhost/MS-VSDX.pdf#page=213}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._reflectionSize;
        if (cell === undefined) cell = this.getParentCell('reflectionSize');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.283 ReflectionTrans
       * @see {http://localhost/MS-VSDX.pdf#page=213}
       * @param {VisioCell} reflectionTrans
       */,
      set: function set(reflectionSize) {
        this.attributeSet('reflectionSize');
        this._reflectionSize = reflectionSize;
      }
    }, {
      key: "reflectionTrans",
      get:
      /**
       * 2.4.4.283 ReflectionTrans
       * @see {http://localhost/MS-VSDX.pdf#page=213}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._reflectionTrans;
        if (cell === undefined) cell = this.getParentCell('reflectionTrans');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.284 Relationships
       * @see {http://localhost/MS-VSDX.pdf#page=213}
       * @param {VisioCell} relationships
       */,
      set: function set(reflectionTrans) {
        this.attributeSet('reflectionTrans');
        this._reflectionTrans = reflectionTrans;
      }
    }, {
      key: "relationships",
      get:
      /**
       * 2.4.4.284 Relationships
       * @see {http://localhost/MS-VSDX.pdf#page=213}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._relationships;
        if (cell === undefined) cell = this.getParentCell('relationships');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.285 ReplaceCopyCells
       * @see {http://localhost/MS-VSDX.pdf#page=213}
       * @param {VisioCell} replaceCopyCells
       */,
      set: function set(relationships) {
        this.attributeSet('relationships');
        this._relationships = relationships;
      }
    }, {
      key: "replaceCopyCells",
      get:
      /**
       * 2.4.4.285 ReplaceCopyCells
       * @see {http://localhost/MS-VSDX.pdf#page=213}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._replaceCopyCells;
        if (cell === undefined) cell = this.getParentCell('replaceCopyCells');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.286 ReplaceLockFormat
       * @see {http://localhost/MS-VSDX.pdf#page=213}
       * @param {VisioCell} replaceLockFormat
       */,
      set: function set(replaceCopyCells) {
        this.attributeSet('replaceCopyCells');
        this._replaceCopyCells = replaceCopyCells;
      }
    }, {
      key: "replaceLockFormat",
      get:
      /**
       * 2.4.4.286 ReplaceLockFormat
       * @see {http://localhost/MS-VSDX.pdf#page=213}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._replaceLockFormat;
        if (cell === undefined) cell = this.getParentCell('replaceLockFormat');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.287 ReplaceLockShapeData
       * @see {http://localhost/MS-VSDX.pdf#page=214}
       * @param {VisioCell} replaceLockShapeData
       */,
      set: function set(replaceLockFormat) {
        this.attributeSet('replaceLockFormat');
        this._replaceLockFormat = replaceLockFormat;
      }
    }, {
      key: "replaceLockShapeData",
      get:
      /**
       * 2.4.4.287 ReplaceLockShapeData
       * @see {http://localhost/MS-VSDX.pdf#page=214}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._replaceLockShapeData;
        if (cell === undefined) cell = this.getParentCell('replaceLockShapeData');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.288 ReplaceLockText
       * @see {http://localhost/MS-VSDX.pdf#page=214}
       * @param {VisioCell} replaceLockText
       */,
      set: function set(replaceLockShapeData) {
        this.attributeSet('replaceLockShapeData');
        this._replaceLockShapeData = replaceLockShapeData;
      }
    }, {
      key: "replaceLockText",
      get:
      /**
       * 2.4.4.288 ReplaceLockText
       * @see {http://localhost/MS-VSDX.pdf#page=214}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._replaceLockText;
        if (cell === undefined) cell = this.getParentCell('replaceLockText');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.289 ResizeMode
       * @see {http://localhost/MS-VSDX.pdf#page=214}
       * @param {VisioCell} resizeMode
       */,
      set: function set(replaceLockText) {
        this.attributeSet('replaceLockText');
        this._replaceLockText = replaceLockText;
      }
    }, {
      key: "resizeMode",
      get:
      /**
       * 2.4.4.289 ResizeMode
       * @see {http://localhost/MS-VSDX.pdf#page=214}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._resizeMode;
        if (cell === undefined) cell = this.getParentCell('resizeMode');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.290 ResizePage
       * @see {http://localhost/MS-VSDX.pdf#page=214}
       * @param {VisioCell} resizePage
       */,
      set: function set(resizeMode) {
        this.attributeSet('resizeMode');
        this._resizeMode = resizeMode;
      }
    }, {
      key: "resizePage",
      get:
      /**
       * 2.4.4.290 ResizePage
       * @see {http://localhost/MS-VSDX.pdf#page=214}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._resizePage;
        if (cell === undefined) cell = this.getParentCell('resizePage');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.291 ReviewerID
       * @see {http://localhost/MS-VSDX.pdf#page=214}
       * @param {VisioCell} reviewerID
       */,
      set: function set(resizePage) {
        this.attributeSet('resizePage');
        this._resizePage = resizePage;
      }
    }, {
      key: "reviewerID",
      get:
      /**
       * 2.4.4.291 ReviewerID
       * @see {http://localhost/MS-VSDX.pdf#page=214}
       */
      function get() {
        var visioType = VisioValueType.PtgShort;
        var cell = this._reviewerID;
        if (cell === undefined) cell = this.getParentCell('reviewerID');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.292 RightMargin
       * @see {http://localhost/MS-VSDX.pdf#page=214}
       * @param {VisioCell} rightMargin
       */,
      set: function set(reviewerID) {
        this.attributeSet('reviewerID');
        this._reviewerID = reviewerID;
      }
    }, {
      key: "rightMargin",
      get:
      /**
       * 2.4.4.292 RightMargin
       * @see {http://localhost/MS-VSDX.pdf#page=214}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._rightMargin;
        if (cell === undefined) cell = this.getParentCell('rightMargin');
        if (cell === undefined) cell = this.getStylesheetTextStyleCell('rightMargin');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.293 RotateGradientWithShape
       * @see {http://localhost/MS-VSDX.pdf#page=214}
       * @param {VisioCell} rotateGradientWithShape
       */,
      set: function set(rightMargin) {
        this.attributeSet('rightMargin');
        this._rightMargin = rightMargin;
      }
    }, {
      key: "rotateGradientWithShape",
      get:
      /**
       * 2.4.4.293 RotateGradientWithShape
       * @see {http://localhost/MS-VSDX.pdf#page=214}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._rotateGradientWithShape;
        if (cell === undefined) cell = this.getParentCell('rotateGradientWithShape');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.294 RotationType
       * @see {http://localhost/MS-VSDX.pdf#page=214}
       * @param {VisioCell} rotationType
       */,
      set: function set(rotateGradientWithShape) {
        this.attributeSet('rotateGradientWithShape');
        this._rotateGradientWithShape = rotateGradientWithShape;
      }
    }, {
      key: "rotationType",
      get:
      /**
       * 2.4.4.294 RotationType
       * @see {http://localhost/MS-VSDX.pdf#page=214}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._rotationType;
        if (cell === undefined) cell = this.getParentCell('rotationType');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.295 RotationXAngle
       * @see {http://localhost/MS-VSDX.pdf#page=215}
       * @param {VisioCell} rotationXAngle
       */,
      set: function set(rotationType) {
        this.attributeSet('rotationType');
        this._rotationType = rotationType;
      }
    }, {
      key: "rotationXAngle",
      get:
      /**
       * 2.4.4.295 RotationXAngle
       * @see {http://localhost/MS-VSDX.pdf#page=215}
       */
      function get() {
        var visioType = VisioValueType.vAngle;
        var cell = this._rotationXAngle;
        if (cell === undefined) cell = this.getParentCell('rotationXAngle');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.296 RotationYAngle
       * @see {http://localhost/MS-VSDX.pdf#page=215}
       * @param {VisioCell} rotationYAngle
       */,
      set: function set(rotationXAngle) {
        this.attributeSet('rotationXAngle');
        this._rotationXAngle = rotationXAngle;
      }
    }, {
      key: "rotationYAngle",
      get:
      /**
       * 2.4.4.296 RotationYAngle
       * @see {http://localhost/MS-VSDX.pdf#page=215}
       */
      function get() {
        var visioType = VisioValueType.vAngle;
        var cell = this._rotationYAngle;
        if (cell === undefined) cell = this.getParentCell('rotationYAngle');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.297 RotationZAngle
       * @see {http://localhost/MS-VSDX.pdf#page=215}
       * @param {VisioCell} rotationZAngle
       */,
      set: function set(rotationYAngle) {
        this.attributeSet('rotationYAngle');
        this._rotationYAngle = rotationYAngle;
      }
    }, {
      key: "rotationZAngle",
      get:
      /**
       * 2.4.4.297 RotationZAngle
       * @see {http://localhost/MS-VSDX.pdf#page=215}
       */
      function get() {
        var visioType = VisioValueType.vAngle;
        var cell = this._rotationZAngle;
        if (cell === undefined) cell = this.getParentCell('rotationZAngle');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.298 Rounding
       * @see {http://localhost/MS-VSDX.pdf#page=215}
       * @param {VisioCell} rounding
       */,
      set: function set(rotationZAngle) {
        this.attributeSet('rotationZAngle');
        this._rotationZAngle = rotationZAngle;
      }
    }, {
      key: "rounding",
      get:
      /**
       * 2.4.4.298 Rounding
       * @see {http://localhost/MS-VSDX.pdf#page=215}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._rounding;
        if (cell === undefined) cell = this.getParentCell('rounding');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.299 RouteStyle
       * @see {http://localhost/MS-VSDX.pdf#page=215}
       * @param {VisioCell} routeStyle
       */,
      set: function set(rounding) {
        this.attributeSet('rounding');
        this._rounding = rounding;
      }
    }, {
      key: "routeStyle",
      get:
      /**
       * 2.4.4.299 RouteStyle
       * @see {http://localhost/MS-VSDX.pdf#page=215}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._routeStyle;
        if (cell === undefined) cell = this.getParentCell('routeStyle');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.300 ScaleX
       * @see {http://localhost/MS-VSDX.pdf#page=215}
       * @param {VisioCell} scaleX
       */,
      set: function set(routeStyle) {
        this.attributeSet('routeStyle');
        this._routeStyle = routeStyle;
      }
    }, {
      key: "scaleX",
      get:
      /**
       * 2.4.4.300 ScaleX
       * @see {http://localhost/MS-VSDX.pdf#page=215}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._scaleX;
        if (cell === undefined) cell = this.getParentCell('scaleX');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.301 ScaleY
       * @see {http://localhost/MS-VSDX.pdf#page=216}
       * @param {VisioCell} scaleY
       */,
      set: function set(scaleX) {
        this.attributeSet('scaleX');
        this._scaleX = scaleX;
      }
    }, {
      key: "scaleY",
      get:
      /**
       * 2.4.4.301 ScaleY
       * @see {http://localhost/MS-VSDX.pdf#page=216}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._scaleY;
        if (cell === undefined) cell = this.getParentCell('scaleY');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.302 SelectMode
       * @see {http://localhost/MS-VSDX.pdf#page=216}
       * @param {VisioCell} selectMode
       */,
      set: function set(scaleY) {
        this.attributeSet('scaleY');
        this._scaleY = scaleY;
      }
    }, {
      key: "selectMode",
      get:
      /**
       * 2.4.4.302 SelectMode
       * @see {http://localhost/MS-VSDX.pdf#page=216}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._selectMode;
        if (cell === undefined) cell = this.getParentCell('selectMode');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.303 ShapeFixedCode
       * @see {http://localhost/MS-VSDX.pdf#page=216}
       * @param {VisioCell} shapeFixedCode
       */,
      set: function set(selectMode) {
        this.attributeSet('selectMode');
        this._selectMode = selectMode;
      }
    }, {
      key: "shapeFixedCode",
      get:
      /**
       * 2.4.4.303 ShapeFixedCode
       * @see {http://localhost/MS-VSDX.pdf#page=216}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._shapeFixedCode;
        if (cell === undefined) cell = this.getParentCell('shapeFixedCode');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.304 ShapeKeywords
       * @see {http://localhost/MS-VSDX.pdf#page=216}
       * @param {VisioCell} shapeKeywords
       */,
      set: function set(shapeFixedCode) {
        this.attributeSet('shapeFixedCode');
        this._shapeFixedCode = shapeFixedCode;
      }
    }, {
      key: "shapeKeywords",
      get:
      /**
       * 2.4.4.304 ShapeKeywords
       * @see {http://localhost/MS-VSDX.pdf#page=216}
       */
      function get() {
        var visioType = VisioValueType.PtgString;
        var cell = this._shapeKeywords;
        if (cell === undefined) cell = this.getParentCell('shapeKeywords');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.305 ShapePermeablePlace
       * @see {http://localhost/MS-VSDX.pdf#page=216}
       * @param {VisioCell} shapePermeablePlace
       */,
      set: function set(shapeKeywords) {
        this.attributeSet('shapeKeywords');
        this._shapeKeywords = shapeKeywords;
      }
    }, {
      key: "shapePermeablePlace",
      get:
      /**
       * 2.4.4.305 ShapePermeablePlace
       * @see {http://localhost/MS-VSDX.pdf#page=216}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._shapePermeablePlace;
        if (cell === undefined) cell = this.getParentCell('shapePermeablePlace');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.306 ShapePermeableX
       * @see {http://localhost/MS-VSDX.pdf#page=216}
       * @param {VisioCell} shapePermeableX
       */,
      set: function set(shapePermeablePlace) {
        this.attributeSet('shapePermeablePlace');
        this._shapePermeablePlace = shapePermeablePlace;
      }
    }, {
      key: "shapePermeableX",
      get:
      /**
       * 2.4.4.306 ShapePermeableX
       * @see {http://localhost/MS-VSDX.pdf#page=216}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._shapePermeableX;
        if (cell === undefined) cell = this.getParentCell('shapePermeableX');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.307 ShapePermeableY
       * @see {http://localhost/MS-VSDX.pdf#page=216}
       * @param {VisioCell} shapePermeableY
       */,
      set: function set(shapePermeableX) {
        this.attributeSet('shapePermeableX');
        this._shapePermeableX = shapePermeableX;
      }
    }, {
      key: "shapePermeableY",
      get:
      /**
       * 2.4.4.307 ShapePermeableY
       * @see {http://localhost/MS-VSDX.pdf#page=216}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._shapePermeableY;
        if (cell === undefined) cell = this.getParentCell('shapePermeableY');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.308 ShapePlaceFlip
       * @see {http://localhost/MS-VSDX.pdf#page=216}
       * @param {VisioCell} shapePlaceFlip
       */,
      set: function set(shapePermeableY) {
        this.attributeSet('shapePermeableY');
        this._shapePermeableY = shapePermeableY;
      }
    }, {
      key: "shapePlaceFlip",
      get:
      /**
       * 2.4.4.308 ShapePlaceFlip
       * @see {http://localhost/MS-VSDX.pdf#page=216}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._shapePlaceFlip;
        if (cell === undefined) cell = this.getParentCell('shapePlaceFlip');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.309 ShapePlaceStyle
       * @see {http://localhost/MS-VSDX.pdf#page=217}
       * @param {VisioCell} shapePlaceStyle
       */,
      set: function set(shapePlaceFlip) {
        this.attributeSet('shapePlaceFlip');
        this._shapePlaceFlip = shapePlaceFlip;
      }
    }, {
      key: "shapePlaceStyle",
      get:
      /**
       * 2.4.4.309 ShapePlaceStyle
       * @see {http://localhost/MS-VSDX.pdf#page=217}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._shapePlaceStyle;
        if (cell === undefined) cell = this.getParentCell('shapePlaceStyle');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.310 ShapePlowCode
       * @see {http://localhost/MS-VSDX.pdf#page=217}
       * @param {VisioCell} shapePlowCode
       */,
      set: function set(shapePlaceStyle) {
        this.attributeSet('shapePlaceStyle');
        this._shapePlaceStyle = shapePlaceStyle;
      }
    }, {
      key: "shapePlowCode",
      get:
      /**
       * 2.4.4.310 ShapePlowCode
       * @see {http://localhost/MS-VSDX.pdf#page=217}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._shapePlowCode;
        if (cell === undefined) cell = this.getParentCell('shapePlowCode');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.311 ShapeRouteStyle
       * @see {http://localhost/MS-VSDX.pdf#page=217}
       * @param {VisioCell} shapeRouteStyle
       */,
      set: function set(shapePlowCode) {
        this.attributeSet('shapePlowCode');
        this._shapePlowCode = shapePlowCode;
      }
    }, {
      key: "shapeRouteStyle",
      get:
      /**
       * 2.4.4.311 ShapeRouteStyle
       * @see {http://localhost/MS-VSDX.pdf#page=217}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._shapeRouteStyle;
        if (cell === undefined) cell = this.getParentCell('shapeRouteStyle');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.312 ShapeShdwBlur
       * @see {http://localhost/MS-VSDX.pdf#page=217}
       * @param {VisioCell} shapeShdwBlur
       */,
      set: function set(shapeRouteStyle) {
        this.attributeSet('shapeRouteStyle');
        this._shapeRouteStyle = shapeRouteStyle;
      }
    }, {
      key: "shapeShdwBlur",
      get:
      /**
       * 2.4.4.312 ShapeShdwBlur
       * @see {http://localhost/MS-VSDX.pdf#page=217}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._shapeShdwBlur;
        if (cell === undefined) cell = this.getParentCell('shapeShdwBlur');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.313 ShapeShdwObliqueAngle
       * @see {http://localhost/MS-VSDX.pdf#page=217}
       * @param {VisioCell} shapeShdwObliqueAngle
       */,
      set: function set(shapeShdwBlur) {
        this.attributeSet('shapeShdwBlur');
        this._shapeShdwBlur = shapeShdwBlur;
      }
    }, {
      key: "shapeShdwObliqueAngle",
      get:
      /**
       * 2.4.4.313 ShapeShdwObliqueAngle
       * @see {http://localhost/MS-VSDX.pdf#page=217}
       */
      function get() {
        var visioType = VisioValueType.vAngle;
        var cell = this._shapeShdwObliqueAngle;
        if (cell === undefined) cell = this.getParentCell('shapeShdwObliqueAngle');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.314 ShapeShdwOffsetX
       * @see {http://localhost/MS-VSDX.pdf#page=217}
       * @param {VisioCell} shapeShdwOffsetX
       */,
      set: function set(shapeShdwObliqueAngle) {
        this.attributeSet('shapeShdwObliqueAngle');
        this._shapeShdwObliqueAngle = shapeShdwObliqueAngle;
      }
    }, {
      key: "shapeShdwOffsetX",
      get:
      /**
       * 2.4.4.314 ShapeShdwOffsetX
       * @see {http://localhost/MS-VSDX.pdf#page=217}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._shapeShdwOffsetX;
        if (cell === undefined) cell = this.getParentCell('shapeShdwOffsetX');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.315 ShapeShdwOffsetY
       * @see {http://localhost/MS-VSDX.pdf#page=217}
       * @param {VisioCell} shapeShdwOffsetY
       */,
      set: function set(shapeShdwOffsetX) {
        this.attributeSet('shapeShdwOffsetX');
        this._shapeShdwOffsetX = shapeShdwOffsetX;
      }
    }, {
      key: "shapeShdwOffsetY",
      get:
      /**
       * 2.4.4.315 ShapeShdwOffsetY
       * @see {http://localhost/MS-VSDX.pdf#page=217}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._shapeShdwOffsetY;
        if (cell === undefined) cell = this.getParentCell('shapeShdwOffsetY');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.316 ShapeShdwScaleFactor
       * @see {http://localhost/MS-VSDX.pdf#page=217}
       * @param {VisioCell} shapeShdwScaleFactor
       */,
      set: function set(shapeShdwOffsetY) {
        this.attributeSet('shapeShdwOffsetY');
        this._shapeShdwOffsetY = shapeShdwOffsetY;
      }
    }, {
      key: "shapeShdwScaleFactor",
      get:
      /**
       * 2.4.4.316 ShapeShdwScaleFactor
       * @see {http://localhost/MS-VSDX.pdf#page=217}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._shapeShdwScaleFactor;
        if (cell === undefined) cell = this.getParentCell('shapeShdwScaleFactor');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.317 ShapeShdwShow
       * @see {http://localhost/MS-VSDX.pdf#page=218}
       * @param {VisioCell} shapeShdwShow
       */,
      set: function set(shapeShdwScaleFactor) {
        this.attributeSet('shapeShdwScaleFactor');
        this._shapeShdwScaleFactor = shapeShdwScaleFactor;
      }
    }, {
      key: "shapeShdwShow",
      get:
      /**
       * 2.4.4.317 ShapeShdwShow
       * @see {http://localhost/MS-VSDX.pdf#page=218}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._shapeShdwShow;
        if (cell === undefined) cell = this.getParentCell('shapeShdwShow');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.318 ShapeShdwType
       * @see {http://localhost/MS-VSDX.pdf#page=218}
       * @param {VisioCell} shapeShdwType
       */,
      set: function set(shapeShdwShow) {
        this.attributeSet('shapeShdwShow');
        this._shapeShdwShow = shapeShdwShow;
      }
    }, {
      key: "shapeShdwType",
      get:
      /**
       * 2.4.4.318 ShapeShdwType
       * @see {http://localhost/MS-VSDX.pdf#page=218}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._shapeShdwType;
        if (cell === undefined) cell = this.getParentCell('shapeShdwType');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.319 ShapeSplit
       * @see {http://localhost/MS-VSDX.pdf#page=218}
       * @param {VisioCell} shapeSplit
       */,
      set: function set(shapeShdwType) {
        this.attributeSet('shapeShdwType');
        this._shapeShdwType = shapeShdwType;
      }
    }, {
      key: "shapeSplit",
      get:
      /**
       * 2.4.4.319 ShapeSplit
       * @see {http://localhost/MS-VSDX.pdf#page=218}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._shapeSplit;
        if (cell === undefined) cell = this.getParentCell('shapeSplit');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.320 ShapeSplittable
       * @see {http://localhost/MS-VSDX.pdf#page=218}
       * @param {VisioCell} shapeSplittable
       */,
      set: function set(shapeSplit) {
        this.attributeSet('shapeSplit');
        this._shapeSplit = shapeSplit;
      }
    }, {
      key: "shapeSplittable",
      get:
      /**
       * 2.4.4.320 ShapeSplittable
       * @see {http://localhost/MS-VSDX.pdf#page=218}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._shapeSplittable;
        if (cell === undefined) cell = this.getParentCell('shapeSplittable');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.321 Sharpen
       * @see {http://localhost/MS-VSDX.pdf#page=218}
       * @param {VisioCell} sharpen
       */,
      set: function set(shapeSplittable) {
        this.attributeSet('shapeSplittable');
        this._shapeSplittable = shapeSplittable;
      }
    }, {
      key: "sharpen",
      get:
      /**
       * 2.4.4.321 Sharpen
       * @see {http://localhost/MS-VSDX.pdf#page=218}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._sharpen;
        if (cell === undefined) cell = this.getParentCell('sharpen');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.322 ShdwForegnd
       * @see {http://localhost/MS-VSDX.pdf#page=219}
       * @param {VisioCell} shdwForegnd
       */,
      set: function set(sharpen) {
        this.attributeSet('sharpen');
        this._sharpen = sharpen;
      }
    }, {
      key: "shdwForegnd",
      get:
      /**
       * 2.4.4.322 ShdwForegnd
       * @see {http://localhost/MS-VSDX.pdf#page=219}
       */
      function get() {
        var visioType = VisioValueType.vColor;
        var cell = this._shdwForegnd;
        if (cell === undefined) cell = this.getParentCell('shdwForegnd');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.323 ShdwForegndTrans
       * @see {http://localhost/MS-VSDX.pdf#page=219}
       * @param {VisioCell} shdwForegndTrans
       */,
      set: function set(shdwForegnd) {
        this.attributeSet('shdwForegnd');
        this._shdwForegnd = shdwForegnd;
      }
    }, {
      key: "shdwForegndTrans",
      get:
      /**
       * 2.4.4.323 ShdwForegndTrans
       * @see {http://localhost/MS-VSDX.pdf#page=219}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._shdwForegndTrans;
        if (cell === undefined) cell = this.getParentCell('shdwForegndTrans');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.324 ShdwObliqueAngle
       * @see {http://localhost/MS-VSDX.pdf#page=219}
       * @param {VisioCell} shdwObliqueAngle
       */,
      set: function set(shdwForegndTrans) {
        this.attributeSet('shdwForegndTrans');
        this._shdwForegndTrans = shdwForegndTrans;
      }
    }, {
      key: "shdwObliqueAngle",
      get:
      /**
       * 2.4.4.324 ShdwObliqueAngle
       * @see {http://localhost/MS-VSDX.pdf#page=219}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._shdwObliqueAngle;
        if (cell === undefined) cell = this.getParentCell('shdwObliqueAngle');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.325 ShdwOffsetX
       * @see {http://localhost/MS-VSDX.pdf#page=219}
       * @param {VisioCell} shdwOffsetX
       */,
      set: function set(shdwObliqueAngle) {
        this.attributeSet('shdwObliqueAngle');
        this._shdwObliqueAngle = shdwObliqueAngle;
      }
    }, {
      key: "shdwOffsetX",
      get:
      /**
       * 2.4.4.325 ShdwOffsetX
       * @see {http://localhost/MS-VSDX.pdf#page=219}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._shdwOffsetX;
        if (cell === undefined) cell = this.getParentCell('shdwOffsetX');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.326 ShdwOffsetY
       * @see {http://localhost/MS-VSDX.pdf#page=219}
       * @param {VisioCell} shdwOffsetY
       */,
      set: function set(shdwOffsetX) {
        this.attributeSet('shdwOffsetX');
        this._shdwOffsetX = shdwOffsetX;
      }
    }, {
      key: "shdwOffsetY",
      get:
      /**
       * 2.4.4.326 ShdwOffsetY
       * @see {http://localhost/MS-VSDX.pdf#page=219}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._shdwOffsetY;
        if (cell === undefined) cell = this.getParentCell('shdwOffsetY');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.327 ShdwPattern
       * @see {http://localhost/MS-VSDX.pdf#page=220}
       * @param {VisioCell} shdwPattern
       */,
      set: function set(shdwOffsetY) {
        this.attributeSet('shdwOffsetY');
        this._shdwOffsetY = shdwOffsetY;
      }
    }, {
      key: "shdwPattern",
      get:
      /**
       * 2.4.4.327 ShdwPattern
       * @see {http://localhost/MS-VSDX.pdf#page=220}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._shdwPattern;
        if (cell === undefined) cell = this.getParentCell('shdwPattern');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.328 ShdwScaleFactor
       * @see {http://localhost/MS-VSDX.pdf#page=220}
       * @param {VisioCell} shdwScaleFactor
       */,
      set: function set(shdwPattern) {
        this.attributeSet('shdwPattern');
        this._shdwPattern = shdwPattern;
      }
    }, {
      key: "shdwScaleFactor",
      get:
      /**
       * 2.4.4.328 ShdwScaleFactor
       * @see {http://localhost/MS-VSDX.pdf#page=220}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._shdwScaleFactor;
        if (cell === undefined) cell = this.getParentCell('shdwScaleFactor');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.329 ShdwType
       * @see {http://localhost/MS-VSDX.pdf#page=220}
       * @param {VisioCell} shdwType
       */,
      set: function set(shdwScaleFactor) {
        this.attributeSet('shdwScaleFactor');
        this._shdwScaleFactor = shdwScaleFactor;
      }
    }, {
      key: "shdwType",
      get:
      /**
       * 2.4.4.329 ShdwType
       * @see {http://localhost/MS-VSDX.pdf#page=220}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._shdwType;
        if (cell === undefined) cell = this.getParentCell('shdwType');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.330 Size
       * @see {http://localhost/MS-VSDX.pdf#page=220}
       * @param {VisioCell} size
       */,
      set: function set(shdwType) {
        this.attributeSet('shdwType');
        this._shdwType = shdwType;
      }
    }, {
      key: "size",
      get:
      /**
       * 2.4.4.330 Size
       * @see {http://localhost/MS-VSDX.pdf#page=220}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._size;
        if (cell === undefined) cell = this.getParentCell('size');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.331 SketchAmount
       * @see {http://localhost/MS-VSDX.pdf#page=220}
       * @param {VisioCell} sketchAmount
       */,
      set: function set(size) {
        this.attributeSet('size');
        this._size = size;
      }
    }, {
      key: "sketchAmount",
      get:
      /**
       * 2.4.4.331 SketchAmount
       * @see {http://localhost/MS-VSDX.pdf#page=220}
       */
      function get() {
        var visioType = VisioValueType.PtgInt;
        var cell = this._sketchAmount;
        if (cell === undefined) cell = this.getParentCell('sketchAmount');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.332 SketchEnabled
       * @see {http://localhost/MS-VSDX.pdf#page=221}
       * @param {VisioCell} sketchEnabled
       */,
      set: function set(sketchAmount) {
        this.attributeSet('sketchAmount');
        this._sketchAmount = sketchAmount;
      }
    }, {
      key: "sketchEnabled",
      get:
      /**
       * 2.4.4.332 SketchEnabled
       * @see {http://localhost/MS-VSDX.pdf#page=221}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._sketchEnabled;
        if (cell === undefined) cell = this.getParentCell('sketchEnabled');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.333 SketchFillChange
       * @see {http://localhost/MS-VSDX.pdf#page=221}
       * @param {VisioCell} sketchFillChange
       */,
      set: function set(sketchEnabled) {
        this.attributeSet('sketchEnabled');
        this._sketchEnabled = sketchEnabled;
      }
    }, {
      key: "sketchFillChange",
      get:
      /**
       * 2.4.4.333 SketchFillChange
       * @see {http://localhost/MS-VSDX.pdf#page=221}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._sketchFillChange;
        if (cell === undefined) cell = this.getParentCell('sketchFillChange');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.334 SketchLineChange
       * @see {http://localhost/MS-VSDX.pdf#page=221}
       * @param {VisioCell} sketchLineChange
       */,
      set: function set(sketchFillChange) {
        this.attributeSet('sketchFillChange');
        this._sketchFillChange = sketchFillChange;
      }
    }, {
      key: "sketchLineChange",
      get:
      /**
       * 2.4.4.334 SketchLineChange
       * @see {http://localhost/MS-VSDX.pdf#page=221}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._sketchLineChange;
        if (cell === undefined) cell = this.getParentCell('sketchLineChange');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.335 SketchLineWeight
       * @see {http://localhost/MS-VSDX.pdf#page=221}
       * @param {VisioCell} sketchLineWeight
       */,
      set: function set(sketchLineChange) {
        this.attributeSet('sketchLineChange');
        this._sketchLineChange = sketchLineChange;
      }
    }, {
      key: "sketchLineWeight",
      get:
      /**
       * 2.4.4.335 SketchLineWeight
       * @see {http://localhost/MS-VSDX.pdf#page=221}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._sketchLineWeight;
        if (cell === undefined) cell = this.getParentCell('sketchLineWeight');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.336 SketchSeed
       * @see {http://localhost/MS-VSDX.pdf#page=221}
       * @param {VisioCell} sketchSeed
       */,
      set: function set(sketchLineWeight) {
        this.attributeSet('sketchLineWeight');
        this._sketchLineWeight = sketchLineWeight;
      }
    }, {
      key: "sketchSeed",
      get:
      /**
       * 2.4.4.336 SketchSeed
       * @see {http://localhost/MS-VSDX.pdf#page=221}
       */
      function get() {
        var visioType = VisioValueType.PtgInt;
        var cell = this._sketchSeed;
        if (cell === undefined) cell = this.getParentCell('sketchSeed');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.337 Snap
       * @see {http://localhost/MS-VSDX.pdf#page=221}
       * @param {VisioCell} snap
       */,
      set: function set(sketchSeed) {
        this.attributeSet('sketchSeed');
        this._sketchSeed = sketchSeed;
      }
    }, {
      key: "snap",
      get:
      /**
       * 2.4.4.337 Snap
       * @see {http://localhost/MS-VSDX.pdf#page=221}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._snap;
        if (cell === undefined) cell = this.getParentCell('snap');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.338 SoftEdgesSize
       * @see {http://localhost/MS-VSDX.pdf#page=221}
       * @param {VisioCell} softEdgesSize
       */,
      set: function set(snap) {
        this.attributeSet('snap');
        this._snap = snap;
      }
    }, {
      key: "softEdgesSize",
      get:
      /**
       * 2.4.4.338 SoftEdgesSize
       * @see {http://localhost/MS-VSDX.pdf#page=221}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._softEdgesSize;
        if (cell === undefined) cell = this.getParentCell('softEdgesSize');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.339 SortKey
       * @see {http://localhost/MS-VSDX.pdf#page=222}
       * @param {VisioCell} sortKey
       */,
      set: function set(softEdgesSize) {
        this.attributeSet('softEdgesSize');
        this._softEdgesSize = softEdgesSize;
      }
    }, {
      key: "sortKey",
      get:
      /**
       * 2.4.4.339 SortKey
       * @see {http://localhost/MS-VSDX.pdf#page=222}
       */
      function get() {
        var visioType = VisioValueType.PtgString;
        var cell = this._sortKey;
        if (cell === undefined) cell = this.getParentCell('sortKey');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.340 SpAfter
       * @see {http://localhost/MS-VSDX.pdf#page=222}
       * @param {VisioCell} spAfter
       */,
      set: function set(sortKey) {
        this.attributeSet('sortKey');
        this._sortKey = sortKey;
      }
    }, {
      key: "spAfter",
      get:
      /**
       * 2.4.4.340 SpAfter
       * @see {http://localhost/MS-VSDX.pdf#page=222}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._spAfter;
        if (cell === undefined) cell = this.getParentCell('spAfter');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.341 SpBefore
       * @see {http://localhost/MS-VSDX.pdf#page=222}
       * @param {VisioCell} spBefore
       */,
      set: function set(spAfter) {
        this.attributeSet('spAfter');
        this._spAfter = spAfter;
      }
    }, {
      key: "spBefore",
      get:
      /**
       * 2.4.4.341 SpBefore
       * @see {http://localhost/MS-VSDX.pdf#page=222}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._spBefore;
        if (cell === undefined) cell = this.getParentCell('spBefore');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.342 SpLine
       * @see {http://localhost/MS-VSDX.pdf#page=222}
       * @param {VisioCell} spLine
       */,
      set: function set(spBefore) {
        this.attributeSet('spBefore');
        this._spBefore = spBefore;
      }
    }, {
      key: "spLine",
      get:
      /**
       * 2.4.4.342 SpLine
       * @see {http://localhost/MS-VSDX.pdf#page=222}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._spLine;
        if (cell === undefined) cell = this.getParentCell('spLine');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.343 Status
       * @see {http://localhost/MS-VSDX.pdf#page=222}
       * @param {VisioCell} status
       */,
      set: function set(spLine) {
        this.attributeSet('spLine');
        this._spLine = spLine;
      }
    }, {
      key: "status",
      get:
      /**
       * 2.4.4.343 Status
       * @see {http://localhost/MS-VSDX.pdf#page=222}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._status;
        if (cell === undefined) cell = this.getParentCell('status');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.344 Strikethru
       * @see {http://localhost/MS-VSDX.pdf#page=222}
       * @param {VisioCell} strikethru
       */,
      set: function set(status) {
        this.attributeSet('status');
        this._status = status;
      }
    }, {
      key: "strikethru",
      get:
      /**
       * 2.4.4.344 Strikethru
       * @see {http://localhost/MS-VSDX.pdf#page=222}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._strikethru;
        if (cell === undefined) cell = this.getParentCell('strikethru');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.345 Style
       * @see {http://localhost/MS-VSDX.pdf#page=222}
       * @param {VisioCell} style
       */,
      set: function set(strikethru) {
        this.attributeSet('strikethru');
        this._strikethru = strikethru;
      }
    }, {
      key: "style",
      get:
      /**
       * 2.4.4.345 Style
       * @see {http://localhost/MS-VSDX.pdf#page=222}
       *
       * 0x00 Specifies that the text run is unformatted.
       * 0x01 Specifies that the text run has a bold character property.
       * 0x02 Specifies that the text run has an italic character property.
       * 0x04 Specifies that the text run has an underline character property.
       * 0x08 Specifies that the text run has a small caps character property.
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._style;
        if (cell === undefined) cell = this.getParentCell('style');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.346 SubAddress
       * @see {http://localhost/MS-VSDX.pdf#page=223}
       * @param {VisioCell} subAddress
       */,
      set: function set(style) {
        this.attributeSet('style');
        this._style = style;
      }
    }, {
      key: "subAddress",
      get:
      /**
       * 2.4.4.346 SubAddress
       * @see {http://localhost/MS-VSDX.pdf#page=223}
       */
      function get() {
        var visioType = VisioValueType.PtgString;
        var cell = this._subAddress;
        if (cell === undefined) cell = this.getParentCell('subAddress');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.347 TagName
       * @see {http://localhost/MS-VSDX.pdf#page=223}
       * @param {VisioCell} tagName
       */,
      set: function set(subAddress) {
        this.attributeSet('subAddress');
        this._subAddress = subAddress;
      }
    }, {
      key: "tagName",
      get:
      /**
       * 2.4.4.347 TagName
       * @see {http://localhost/MS-VSDX.pdf#page=223}
       */
      function get() {
        var visioType = VisioValueType.PtgString;
        var cell = this._tagName;
        if (cell === undefined) cell = this.getParentCell('tagName');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.348 TextBkgnd
       * @see {http://localhost/MS-VSDX.pdf#page=223}
       * @param {VisioCell} textBkgnd
       */,
      set: function set(tagName) {
        this.attributeSet('tagName');
        this._tagName = tagName;
      }
    }, {
      key: "textBkgnd",
      get:
      /**
       * 2.4.4.348 TextBkgnd
       * @see {http://localhost/MS-VSDX.pdf#page=223}
       */
      function get() {
        var visioType = VisioValueType.PtgColorRGB;
        var cell = this._textBkgnd;
        if (cell === undefined) cell = this.getParentCell('textBkgnd');
        if (cell === undefined) cell = this.getStylesheetTextStyleCell('textBkgnd');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.349 TextBkgndTrans
       * @see {http://localhost/MS-VSDX.pdf#page=223}
       * @param {VisioCell} textBkgndTrans
       */,
      set: function set(textBkgnd) {
        this.attributeSet('textBkgnd');
        this._textBkgnd = textBkgnd;
      }
    }, {
      key: "textBkgndTrans",
      get:
      /**
       * 2.4.4.349 TextBkgndTrans
       * @see {http://localhost/MS-VSDX.pdf#page=223}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._textBkgndTrans;
        if (cell === undefined) cell = this.getParentCell('textBkgndTrans');
        if (cell === undefined) cell = this.getStylesheetTextStyleCell('textBkgndTrans');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.350 TextDirection
       * @see {http://localhost/MS-VSDX.pdf#page=224}
       * @param {VisioCell} textDirection
       */,
      set: function set(textBkgndTrans) {
        this.attributeSet('textBkgndTrans');
        this._textBkgndTrans = textBkgndTrans;
      }
    }, {
      key: "textDirection",
      get:
      /**
       * 2.4.4.350 TextDirection
       * @see {http://localhost/MS-VSDX.pdf#page=224}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._textDirection;
        if (cell === undefined) cell = this.getParentCell('textDirection');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.351 TextPosAfterBullet
       * @see {http://localhost/MS-VSDX.pdf#page=224}
       * @param {VisioCell} textPosAfterBullet
       */,
      set: function set(textDirection) {
        this.attributeSet('textDirection');
        this._textDirection = textDirection;
      }
    }, {
      key: "textPosAfterBullet",
      get:
      /**
       * 2.4.4.351 TextPosAfterBullet
       * @see {http://localhost/MS-VSDX.pdf#page=224}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._textPosAfterBullet;
        if (cell === undefined) cell = this.getParentCell('textPosAfterBullet');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.352 TheData
       * @see {http://localhost/MS-VSDX.pdf#page=224}
       * @param {VisioCell} theData
       */,
      set: function set(textPosAfterBullet) {
        this.attributeSet('textPosAfterBullet');
        this._textPosAfterBullet = textPosAfterBullet;
      }
    }, {
      key: "theData",
      get:
      /**
       * 2.4.4.352 TheData
       * @see {http://localhost/MS-VSDX.pdf#page=224}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._theData;
        if (cell === undefined) cell = this.getParentCell('theData');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.353 ThemeIndex
       * @see {http://localhost/MS-VSDX.pdf#page=224}
       * @param {VisioCell} themeIndex
       */,
      set: function set(theData) {
        this.attributeSet('theData');
        this._theData = theData;
      }
    }, {
      key: "themeIndex",
      get:
      /**
       * 2.4.4.353 ThemeIndex
       * @see {http://localhost/MS-VSDX.pdf#page=224}
       */
      function get() {
        var visioType = VisioValueType.PtgInt;
        var cell = this._themeIndex;
        if (cell === undefined) cell = this.getParentCell('themeIndex');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.354 TheText
       * @see {http://localhost/MS-VSDX.pdf#page=224}
       * @param {VisioCell} theText
       */,
      set: function set(themeIndex) {
        this.attributeSet('themeIndex');
        this._themeIndex = themeIndex;
      }
    }, {
      key: "theText",
      get:
      /**
       * 2.4.4.354 TheText
       * @see {http://localhost/MS-VSDX.pdf#page=224}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._theText;
        if (cell === undefined) cell = this.getParentCell('theText');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.355 TopMargin
       * @see {http://localhost/MS-VSDX.pdf#page=224}
       * @param {VisioCell} topMargin
       */,
      set: function set(theText) {
        this.attributeSet('theText');
        this._theText = theText;
      }
    }, {
      key: "topMargin",
      get:
      /**
       * 2.4.4.355 TopMargin
       * @see {http://localhost/MS-VSDX.pdf#page=224}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._topMargin;
        if (cell === undefined) cell = this.getParentCell('topMargin');
        if (cell === undefined) cell = this.getStylesheetTextStyleCell('topMargin');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.356 Transparency
       * @see {http://localhost/MS-VSDX.pdf#page=224}
       * @param {VisioCell} transparency
       */,
      set: function set(topMargin) {
        this.attributeSet('topMargin');
        this._topMargin = topMargin;
      }
    }, {
      key: "transparency",
      get:
      /**
       * 2.4.4.356 Transparency
       * @see {http://localhost/MS-VSDX.pdf#page=224}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._transparency;
        if (cell === undefined) cell = this.getParentCell('transparency');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.357 TxtAngle
       * @see {http://localhost/MS-VSDX.pdf#page=225}
       * @param {VisioCell} txtAngle
       */,
      set: function set(transparency) {
        this.attributeSet('transparency');
        this._transparency = transparency;
      }
    }, {
      key: "txtAngle",
      get:
      /**
       * 2.4.4.357 TxtAngle
       * @see {http://localhost/MS-VSDX.pdf#page=225}
       */
      function get() {
        var cell = this._txtAngle;
        if (cell === undefined) cell = this.getParentCell('txtAngle');
        var visioType = VisioValueType.vAngle;
        //TODO miky
        // VisioValueType.vScalar
        debug.log('resolve cell type "txtAngle"');
        if (cell && cell.value !== '0' && cell.units && cell.units !== VisioUnitType.DEG) {
          debug.log('txtAngle unclear');
        }
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.358 TxtHeight
       * @see {http://localhost/MS-VSDX.pdf#page=225}
       * @param {VisioCell} txtHeight
       */,
      set: function set(txtAngle) {
        this.attributeSet('txtAngle');
        this._txtAngle = txtAngle;
      }
    }, {
      key: "txtHeight",
      get:
      /**
       * 2.4.4.358 TxtHeight
       * @see {http://localhost/MS-VSDX.pdf#page=225}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._txtHeight;
        if (cell === undefined) cell = this.getParentCell('txtHeight');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.359 TxtLocPinX
       * @see {http://localhost/MS-VSDX.pdf#page=225}
       * @param {VisioCell} txtLocPinX
       */,
      set: function set(txtHeight) {
        this.attributeSet('txtHeight');
        this._txtHeight = txtHeight;
      }
    }, {
      key: "txtLocPinX",
      get:
      /**
       * 2.4.4.359 TxtLocPinX
       * @see {http://localhost/MS-VSDX.pdf#page=225}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._txtLocPinX;
        if (cell === undefined) cell = this.getParentCell('txtLocPinX');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.360 TxtLocPinY
       * @see {http://localhost/MS-VSDX.pdf#page=225}
       * @param {VisioCell} txtLocPinY
       */,
      set: function set(txtLocPinX) {
        this.attributeSet('txtLocPinX');
        this._txtLocPinX = txtLocPinX;
      }
    }, {
      key: "txtLocPinY",
      get:
      /**
       * 2.4.4.360 TxtLocPinY
       * @see {http://localhost/MS-VSDX.pdf#page=225}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._txtLocPinY;
        if (cell === undefined) cell = this.getParentCell('txtLocPinY');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.361 TxtPinX
       * @see {http://localhost/MS-VSDX.pdf#page=225}
       * @param {VisioCell} txtPinX
       */,
      set: function set(txtLocPinY) {
        this.attributeSet('txtLocPinY');
        this._txtLocPinY = txtLocPinY;
      }
    }, {
      key: "txtPinX",
      get:
      /**
       * 2.4.4.361 TxtPinX
       * @see {http://localhost/MS-VSDX.pdf#page=225}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._txtPinX;
        if (cell === undefined) cell = this.getParentCell('txtPinX');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.362 TxtPinY
       * @see {http://localhost/MS-VSDX.pdf#page=225}
       * @param {VisioCell} txtPinY
       */,
      set: function set(txtPinX) {
        this.attributeSet('txtPinX');
        this._txtPinX = txtPinX;
      }
    }, {
      key: "txtPinY",
      get:
      /**
       * 2.4.4.362 TxtPinY
       * @see {http://localhost/MS-VSDX.pdf#page=225}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._txtPinY;
        if (cell === undefined) cell = this.getParentCell('txtPinY');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.363 TxtWidth
       * @see {http://localhost/MS-VSDX.pdf#page=225}
       * @param {VisioCell} txtWidth
       */,
      set: function set(txtPinY) {
        this.attributeSet('txtPinY');
        this._txtPinY = txtPinY;
      }
    }, {
      key: "txtWidth",
      get:
      /**
       * 2.4.4.363 TxtWidth
       * @see {http://localhost/MS-VSDX.pdf#page=225}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._txtWidth;
        if (cell === undefined) cell = this.getParentCell('txtWidth');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.364 Type
       * @see {http://localhost/MS-VSDX.pdf#page=225}
       * @param {VisioCell} type
       */,
      set: function set(txtWidth) {
        this.attributeSet('txtWidth');
        this._txtWidth = txtWidth;
      }
    }, {
      key: "type",
      get:
      /**
       * 2.4.4.364 Type
       * @see {http://localhost/MS-VSDX.pdf#page=225}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._type;
        if (cell === undefined) cell = this.getParentCell('type');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.365 UICat
       * @see {http://localhost/MS-VSDX.pdf#page=226}
       * @param {VisioCell} uICat
       */,
      set: function set(type) {
        this.attributeSet('type');
        this._type = type;
      }
    }, {
      key: "uICat",
      get:
      /**
       * 2.4.4.365 UICat
       * @see {http://localhost/MS-VSDX.pdf#page=226}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._uICat;
        if (cell === undefined) cell = this.getParentCell('uICat');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.366 UICod
       * @see {http://localhost/MS-VSDX.pdf#page=226}
       * @param {VisioCell} uICod
       */,
      set: function set(uICat) {
        this.attributeSet('uICat');
        this._uICat = uICat;
      }
    }, {
      key: "uICod",
      get:
      /**
       * 2.4.4.366 UICod
       * @see {http://localhost/MS-VSDX.pdf#page=226}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._uICod;
        if (cell === undefined) cell = this.getParentCell('uICod');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.367 UIFmt
       * @see {http://localhost/MS-VSDX.pdf#page=226}
       * @param {VisioCell} uIFmt
       */,
      set: function set(uICod) {
        this.attributeSet('uICod');
        this._uICod = uICod;
      }
    }, {
      key: "uIFmt",
      get:
      /**
       * 2.4.4.367 UIFmt
       * @see {http://localhost/MS-VSDX.pdf#page=226}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._uIFmt;
        if (cell === undefined) cell = this.getParentCell('uIFmt');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.368 UIVisibility
       * @see {http://localhost/MS-VSDX.pdf#page=226}
       * @param {VisioCell} uIVisibility
       */,
      set: function set(uIFmt) {
        this.attributeSet('uIFmt');
        this._uIFmt = uIFmt;
      }
    }, {
      key: "uIVisibility",
      get:
      /**
       * 2.4.4.368 UIVisibility
       * @see {http://localhost/MS-VSDX.pdf#page=226}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._uIVisibility;
        if (cell === undefined) cell = this.getParentCell('uIVisibility');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.369 UpdateAlignBox
       * @see {http://localhost/MS-VSDX.pdf#page=226}
       * @param {VisioCell} updateAlignBox
       */,
      set: function set(uIVisibility) {
        this.attributeSet('uIVisibility');
        this._uIVisibility = uIVisibility;
      }
    }, {
      key: "updateAlignBox",
      get:
      /**
       * 2.4.4.369 UpdateAlignBox
       * @see {http://localhost/MS-VSDX.pdf#page=226}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._updateAlignBox;
        if (cell === undefined) cell = this.getParentCell('updateAlignBox');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.370 UseGroupGradient
       * @see {http://localhost/MS-VSDX.pdf#page=226}
       * @param {VisioCell} useGroupGradient
       */,
      set: function set(updateAlignBox) {
        this.attributeSet('updateAlignBox');
        this._updateAlignBox = updateAlignBox;
      }
    }, {
      key: "useGroupGradient",
      get:
      /**
       * 2.4.4.370 UseGroupGradient
       * @see {http://localhost/MS-VSDX.pdf#page=226}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._useGroupGradient;
        if (cell === undefined) cell = this.getParentCell('useGroupGradient');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.371 Value
       * @see {http://localhost/MS-VSDX.pdf#page=226}
       * @param {VisioCell} value
       */,
      set: function set(useGroupGradient) {
        this.attributeSet('useGroupGradient');
        this._useGroupGradient = useGroupGradient;
      }
    }, {
      key: "value",
      get:
      /**
       * 2.4.4.371 Value
       * @see {http://localhost/MS-VSDX.pdf#page=226}
       */
      function get() {
        var visioType = VisioValueType.vAny;
        var cell = this._value;
        if (cell === undefined) cell = this.getParentCell('value');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.372 VariationColorIndex
       * @see {http://localhost/MS-VSDX.pdf#page=226}
       * @param {VisioCell} variationColorIndex
       */,
      set: function set(value) {
        this.attributeSet('value');
        this._value = value;
      }
    }, {
      key: "variationColorIndex",
      get:
      /**
       * 2.4.4.372 VariationColorIndex
       * @see {http://localhost/MS-VSDX.pdf#page=226}
       */
      function get() {
        var visioType = VisioValueType.PtgInt;
        var cell = this._variationColorIndex;
        if (cell === undefined) cell = this.getParentCell('variationColorIndex');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.373 VariationStyleIndex
       * @see {http://localhost/MS-VSDX.pdf#page=227}
       * @param {VisioCell} variationStyleIndex
       */,
      set: function set(variationColorIndex) {
        this.attributeSet('variationColorIndex');
        this._variationColorIndex = variationColorIndex;
      }
    }, {
      key: "variationStyleIndex",
      get:
      /**
       * 2.4.4.373 VariationStyleIndex
       * @see {http://localhost/MS-VSDX.pdf#page=227}
       */
      function get() {
        var visioType = VisioValueType.PtgInt;
        var cell = this._variationStyleIndex;
        if (cell === undefined) cell = this.getParentCell('variationStyleIndex');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.374 Verify
       * @see {http://localhost/MS-VSDX.pdf#page=228}
       * @param {VisioCell} verify
       */,
      set: function set(variationStyleIndex) {
        this.attributeSet('variationStyleIndex');
        this._variationStyleIndex = variationStyleIndex;
      }
    }, {
      key: "verify",
      get:
      /**
       * 2.4.4.374 Verify
       * @see {http://localhost/MS-VSDX.pdf#page=228}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._verify;
        if (cell === undefined) cell = this.getParentCell('verify');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.375 VerticalAlign
       * @see {http://localhost/MS-VSDX.pdf#page=228}
       * @param {VisioCell} verticalAlign
       */,
      set: function set(verify) {
        this.attributeSet('verify');
        this._verify = verify;
      }
    }, {
      key: "verticalAlign",
      get:
      /**
       * 2.4.4.375 VerticalAlign
       * @see {http://localhost/MS-VSDX.pdf#page=228}
       */
      function get() {
        var visioType = VisioValueType.vScalar;
        var cell = this._verticalAlign;
        if (cell === undefined) cell = this.getParentCell('verticalAlign');
        if (cell === undefined) cell = this.getStylesheetTextStyleCell('verticalAlign');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.376 ViewMarkup
       * @see {http://localhost/MS-VSDX.pdf#page=228}
       * @param {VisioCell} viewMarkup
       */,
      set: function set(verticalAlign) {
        this.attributeSet('verticalAlign');
        this._verticalAlign = verticalAlign;
      }
    }, {
      key: "viewMarkup",
      get:
      /**
       * 2.4.4.376 ViewMarkup
       * @see {http://localhost/MS-VSDX.pdf#page=228}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._viewMarkup;
        if (cell === undefined) cell = this.getParentCell('viewMarkup');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.377 Visible
       * @see {http://localhost/MS-VSDX.pdf#page=228}
       * @param {VisioCell} visible
       */,
      set: function set(viewMarkup) {
        this.attributeSet('viewMarkup');
        this._viewMarkup = viewMarkup;
      }
    }, {
      key: "visible",
      get:
      /**
       * 2.4.4.377 Visible
       * @see {http://localhost/MS-VSDX.pdf#page=228}
       */
      function get() {
        var visioType = VisioValueType.PtgBool;
        var cell = this._visible;
        if (cell === undefined) cell = this.getParentCell('visible');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.378 WalkPreference
       * @see {http://localhost/MS-VSDX.pdf#page=228}
       * @param {VisioCell} walkPreference
       */,
      set: function set(visible) {
        this.attributeSet('visible');
        this._visible = visible;
      }
    }, {
      key: "walkPreference",
      get:
      /**
       * 2.4.4.378 WalkPreference
       * @see {http://localhost/MS-VSDX.pdf#page=228}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._walkPreference;
        if (cell === undefined) cell = this.getParentCell('walkPreference');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.379 Width
       * @see {http://localhost/MS-VSDX.pdf#page=229}
       * @param {VisioCell} width
       */,
      set: function set(walkPreference) {
        this.attributeSet('walkPreference');
        this._walkPreference = walkPreference;
      }
    }, {
      key: "width",
      get:
      /**
       * 2.4.4.379 Width
       * @see {http://localhost/MS-VSDX.pdf#page=229}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._width;
        if (cell === undefined) cell = this.getParentCell('width');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.380 X
       * @see {http://localhost/MS-VSDX.pdf#page=229}
       * @param {VisioCell} x
       */,
      set: function set(width) {
        this.attributeSet('width');
        this._width = width;
      }
    }, {
      key: "x",
      get:
      /**
       * 2.4.4.380 X
       * @see {http://localhost/MS-VSDX.pdf#page=229}
       */
      function get() {
        var visioType;
        if (this.isDescendantOfSectionType([VisioSectionType.Control, VisioSectionType.Scratch, VisioSectionType.ActionTag, VisioSectionType.Connection])) visioType = VisioValueType.vLength; // for the formula eval
        else switch (this.getRowType()) {
          case VisioRowType.ArcTo:
          case VisioRowType.Ellipse:
          case VisioRowType.EllipticalArcTo:
          case VisioRowType.InfiniteLine:
          case VisioRowType.LineTo:
          case VisioRowType.MoveTo:
          case VisioRowType.NURBSTo:
          case VisioRowType.PolylineTo:
          case VisioRowType.SplineKnot:
          case VisioRowType.SplineStart:
            visioType = VisioValueType.vLength;
            break;
          case VisioRowType.RelCubBezTo:
          case VisioRowType.RelEllipticalArcTo:
          case VisioRowType.RelLineTo:
          case VisioRowType.RelMoveTo:
          case VisioRowType.RelQuadBezTo:
            visioType = VisioValueType.vScalar;
            break;
          default:
            debug.log('Incorrect cell type', {
              attributeName: 'x',
              cells: this,
              rowType: this.getRowType()
            });
        }
        var cell = this._x;
        if (cell === undefined) cell = this.getParentCell('x');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.381 XCon
       * @see {http://localhost/MS-VSDX.pdf#page=229}
       * @param {VisioCell} xCon
       */,
      set: function set(x) {
        this.attributeSet('x');
        this._x = x;
      }
    }, {
      key: "xCon",
      get:
      /**
       * 2.4.4.381 XCon
       * @see {http://localhost/MS-VSDX.pdf#page=229}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._xCon;
        if (cell === undefined) cell = this.getParentCell('xCon');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.382 XDyn
       * @see {http://localhost/MS-VSDX.pdf#page=229}
       * @param {VisioCell} xDyn
       */,
      set: function set(xCon) {
        this.attributeSet('xCon');
        this._xCon = xCon;
      }
    }, {
      key: "xDyn",
      get:
      /**
       * 2.4.4.382 XDyn
       * @see {http://localhost/MS-VSDX.pdf#page=229}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._xDyn;
        if (cell === undefined) cell = this.getParentCell('xDyn');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.383 XGridDensity
       * @see {http://localhost/MS-VSDX.pdf#page=229}
       * @param {VisioCell} xGridDensity
       */,
      set: function set(xDyn) {
        this.attributeSet('xDyn');
        this._xDyn = xDyn;
      }
    }, {
      key: "xGridDensity",
      get:
      /**
       * 2.4.4.383 XGridDensity
       * @see {http://localhost/MS-VSDX.pdf#page=229}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._xGridDensity;
        if (cell === undefined) cell = this.getParentCell('xGridDensity');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.384 XGridOrigin
       * @see {http://localhost/MS-VSDX.pdf#page=229}
       * @param {VisioCell} xGridOrigin
       */,
      set: function set(xGridDensity) {
        this.attributeSet('xGridDensity');
        this._xGridDensity = xGridDensity;
      }
    }, {
      key: "xGridOrigin",
      get:
      /**
       * 2.4.4.384 XGridOrigin
       * @see {http://localhost/MS-VSDX.pdf#page=229}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._xGridOrigin;
        if (cell === undefined) cell = this.getParentCell('xGridOrigin');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.385 XGridSpacing
       * @see {http://localhost/MS-VSDX.pdf#page=229}
       * @param {VisioCell} xGridSpacing
       */,
      set: function set(xGridOrigin) {
        this.attributeSet('xGridOrigin');
        this._xGridOrigin = xGridOrigin;
      }
    }, {
      key: "xGridSpacing",
      get:
      /**
       * 2.4.4.385 XGridSpacing
       * @see {http://localhost/MS-VSDX.pdf#page=229}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._xGridSpacing;
        if (cell === undefined) cell = this.getParentCell('xGridSpacing');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.386 XJustify
       * @see {http://localhost/MS-VSDX.pdf#page=229}
       * @param {VisioCell} xJustify
       */,
      set: function set(xGridSpacing) {
        this.attributeSet('xGridSpacing');
        this._xGridSpacing = xGridSpacing;
      }
    }, {
      key: "xJustify",
      get:
      /**
       * 2.4.4.386 XJustify
       * @see {http://localhost/MS-VSDX.pdf#page=229}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._xJustify;
        if (cell === undefined) cell = this.getParentCell('xJustify');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.387 XRulerDensity
       * @see {http://localhost/MS-VSDX.pdf#page=229}
       * @param {VisioCell} xRulerDensity
       */,
      set: function set(xJustify) {
        this.attributeSet('xJustify');
        this._xJustify = xJustify;
      }
    }, {
      key: "xRulerDensity",
      get:
      /**
       * 2.4.4.387 XRulerDensity
       * @see {http://localhost/MS-VSDX.pdf#page=229}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._xRulerDensity;
        if (cell === undefined) cell = this.getParentCell('xRulerDensity');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.388 XRulerOrigin
       * @see {http://localhost/MS-VSDX.pdf#page=230}
       * @param {VisioCell} xRulerOrigin
       */,
      set: function set(xRulerDensity) {
        this.attributeSet('xRulerDensity');
        this._xRulerDensity = xRulerDensity;
      }
    }, {
      key: "xRulerOrigin",
      get:
      /**
       * 2.4.4.388 XRulerOrigin
       * @see {http://localhost/MS-VSDX.pdf#page=230}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._xRulerOrigin;
        if (cell === undefined) cell = this.getParentCell('xRulerOrigin');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.389 Y
       * @see {http://localhost/MS-VSDX.pdf#page=230}
       * @param {VisioCell} y
       */,
      set: function set(xRulerOrigin) {
        this.attributeSet('xRulerOrigin');
        this._xRulerOrigin = xRulerOrigin;
      }
    }, {
      key: "y",
      get:
      /**
       * 2.4.4.389 Y
       * @see {http://localhost/MS-VSDX.pdf#page=230}
       */
      function get() {
        var visioType;
        if (this.isDescendantOfSectionType([VisioSectionType.Control, VisioSectionType.Scratch, VisioSectionType.ActionTag, VisioSectionType.Connection])) visioType = VisioValueType.vLength; // for the formula eval
        else switch (this.getRowType()) {
          case VisioRowType.ArcTo:
          case VisioRowType.Ellipse:
          case VisioRowType.EllipticalArcTo:
          case VisioRowType.InfiniteLine:
          case VisioRowType.LineTo:
          case VisioRowType.MoveTo:
          case VisioRowType.NURBSTo:
          case VisioRowType.PolylineTo:
          case VisioRowType.SplineKnot:
          case VisioRowType.SplineStart:
            visioType = VisioValueType.vLength;
            break;
          case VisioRowType.RelCubBezTo:
          case VisioRowType.RelEllipticalArcTo:
          case VisioRowType.RelLineTo:
          case VisioRowType.RelMoveTo:
          case VisioRowType.RelQuadBezTo:
            visioType = VisioValueType.vScalar;
            break;
          default:
            debug.log('Incorrect cell type', {
              attributeName: 'a',
              cells: this
            });
        }
        var cell = this._y;
        if (cell === undefined) cell = this.getParentCell('y');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.390 YCon
       * @see {http://localhost/MS-VSDX.pdf#page=230}
       * @param {VisioCell} yCon
       */,
      set: function set(y) {
        this.attributeSet('y');
        this._y = y;
      }
    }, {
      key: "yCon",
      get:
      /**
       * 2.4.4.390 YCon
       * @see {http://localhost/MS-VSDX.pdf#page=230}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._yCon;
        if (cell === undefined) cell = this.getParentCell('yCon');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.391 YDyn
       * @see {http://localhost/MS-VSDX.pdf#page=230}
       * @param {VisioCell} yDyn
       */,
      set: function set(yCon) {
        this.attributeSet('yCon');
        this._yCon = yCon;
      }
    }, {
      key: "yDyn",
      get:
      /**
       * 2.4.4.391 YDyn
       * @see {http://localhost/MS-VSDX.pdf#page=230}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._yDyn;
        if (cell === undefined) cell = this.getParentCell('yDyn');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.392 YGridDensity
       * @see {http://localhost/MS-VSDX.pdf#page=230}
       * @param {VisioCell} yGridDensity
       */,
      set: function set(yDyn) {
        this.attributeSet('yDyn');
        this._yDyn = yDyn;
      }
    }, {
      key: "yGridDensity",
      get:
      /**
       * 2.4.4.392 YGridDensity
       * @see {http://localhost/MS-VSDX.pdf#page=230}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._yGridDensity;
        if (cell === undefined) cell = this.getParentCell('yGridDensity');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.393 YGridOrigin
       * @see {http://localhost/MS-VSDX.pdf#page=230}
       * @param {VisioCell} yGridOrigin
       */,
      set: function set(yGridDensity) {
        this.attributeSet('yGridDensity');
        this._yGridDensity = yGridDensity;
      }
    }, {
      key: "yGridOrigin",
      get:
      /**
       * 2.4.4.393 YGridOrigin
       * @see {http://localhost/MS-VSDX.pdf#page=230}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._yGridOrigin;
        if (cell === undefined) cell = this.getParentCell('yGridOrigin');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.394 YGridSpacing
       * @see {http://localhost/MS-VSDX.pdf#page=230}
       * @param {VisioCell} yGridSpacing
       */,
      set: function set(yGridOrigin) {
        this.attributeSet('yGridOrigin');
        this._yGridOrigin = yGridOrigin;
      }
    }, {
      key: "yGridSpacing",
      get:
      /**
       * 2.4.4.394 YGridSpacing
       * @see {http://localhost/MS-VSDX.pdf#page=230}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._yGridSpacing;
        if (cell === undefined) cell = this.getParentCell('yGridSpacing');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.395 YJustify
       * @see {http://localhost/MS-VSDX.pdf#page=230}
       * @param {VisioCell} yJustify
       */,
      set: function set(yGridSpacing) {
        this.attributeSet('yGridSpacing');
        this._yGridSpacing = yGridSpacing;
      }
    }, {
      key: "yJustify",
      get:
      /**
       * 2.4.4.395 YJustify
       * @see {http://localhost/MS-VSDX.pdf#page=230}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._yJustify;
        if (cell === undefined) cell = this.getParentCell('yJustify');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.396 YRulerDensity
       * @see {http://localhost/MS-VSDX.pdf#page=230}
       * @param {VisioCell} yRulerDensity
       */,
      set: function set(yJustify) {
        this.attributeSet('yJustify');
        this._yJustify = yJustify;
      }
    }, {
      key: "yRulerDensity",
      get:
      /**
       * 2.4.4.396 YRulerDensity
       * @see {http://localhost/MS-VSDX.pdf#page=230}
       */
      function get() {
        var visioType = VisioValueType.PtgByte;
        var cell = this._yRulerDensity;
        if (cell === undefined) cell = this.getParentCell('yRulerDensity');
        return this.resolveCellValue(cell, visioType);
      }

      /**
       * 2.4.4.397 YRulerOrigin
       * @see {http://localhost/MS-VSDX.pdf#page=231}
       * @param {VisioCell} yRulerOrigin
       */,
      set: function set(yRulerDensity) {
        this.attributeSet('yRulerDensity');
        this._yRulerDensity = yRulerDensity;
      }
    }, {
      key: "yRulerOrigin",
      get:
      /**
       * 2.4.4.397 YRulerOrigin
       * @see {http://localhost/MS-VSDX.pdf#page=231}
       */
      function get() {
        var visioType = VisioValueType.vLength;
        var cell = this._yRulerOrigin;
        if (cell === undefined) cell = this.getParentCell('yRulerOrigin');
        return this.resolveCellValue(cell, visioType);
      },
      set: function set(yRulerOrigin) {
        this.attributeSet('yRulerOrigin');
        this._yRulerOrigin = yRulerOrigin;
      }
    }]);
    return VisioCells;
  }(VisioCellsBase);

  var SECTION_ROW_TYPES = ['MoveTo', 'RelMoveTo', 'LineTo', 'RelLineTo', 'ArcTo', 'InfiniteLine', 'Ellipse', 'EllipticalArcTo', 'RelEllipticalArcTo', 'SplineStart', 'SplineKnow', 'PolylineTo', 'NURBSTo', 'RelCubBezTo', 'RelQuadBezTo'];

  // TODO: implement VisioIndexedRow and VisioNamedRow

  var VisioRow = /*#__PURE__*/function (_VisioSheetObject) {
    _inherits(VisioRow, _VisioSheetObject);
    var _super = _createSuper(VisioRow);
    function VisioRow(_ref) {
      var _this;
      var init = Object.assign({}, (_objectDestructuringEmpty(_ref), _ref));
      _classCallCheck(this, VisioRow);
      _this = _super.call(this, init);
      var _init$cells = init.cells,
        cells = _init$cells === void 0 ? new VisioCells({
          archive: _this.archive
        }) : _init$cells;
      _this.cells = cells;
      _this.debugType = init.debugType;
      _this.jxon = init.jxon;
      if (init.type) {
        _this.type = init.type;
      }
      if (init.debugType === VisioRowStructureType.Named) {
        _this.name = init.name;
      } else {
        _this.index = init.index;
      }
      return _this;
    }
    _createClass(VisioRow, [{
      key: "type",
      get: function get() {
        return this._type;
      },
      set: function set(rowType) {
        if (SECTION_ROW_TYPES.includes(rowType) && this.jxon) {
          // user created a geometry row, set type in jxon
          this.jxon[VisioJxonRowAttributeName.Type] = rowType;
        }
        this._type = rowType;
      }
    }]);
    return VisioRow;
  }(VisioSheetObject);

  // geometry section has its own cells in addition to rows and their cells
  // todo: geometry section may inherit from VisioSheetObject and allow cell addition
  var SECTION_CELL_NAMES = {
    Geometry: ['NoFill', 'NoLine', 'NoShow', 'NoSnap', 'NoQuickDrag']
  };
  var SECTION_ROW_CELL_NAMES = {
    Actions: ['Menu', 'Action', 'Checked', 'Disabled', 'ReadOnly', 'Invisible', 'BeginGroup', 'FlyoutChild', 'TagName', 'ButtonFace', 'SortKey'],
    Character: ['Font', 'Color', 'Style', 'Case', 'Pos', 'FontScale', 'Size', 'DblUnderline', 'Overline', 'Strikethru', 'DoubleStrikethrough', 'Letterspace', 'ColorTrans', 'AsianFont', 'ComplexScriptFont', 'ComplexScriptSize', 'LangID'],
    Connection: ['X', 'Y', 'DirX', 'DirY', 'Type', 'AutoGen', 'Prompt'],
    Control: ['X', 'Y', 'XDyn', 'YDyn', 'XCon', 'YCon', 'CanGlue', 'Prompt'],
    Field: ['Value', 'Format', 'Type', 'UICat', 'UICod', 'UIFmt', 'Calendar', 'ObjectKind'],
    FillGradient: ['GradientStopColor', 'GradientStopColorTrans', 'GradientStopPosition'],
    Geometry: ['X', 'Y', 'A', 'B', 'C', 'D', 'E'],
    Hyperlink: ['Description', 'Address', 'SubAddress', 'ExtraInfo', 'Frame', 'NewWindow', 'Default', 'Invisible', 'SortKey'],
    Layer: ['Name', 'Color', 'Status', 'Visible', 'Print', 'Active', 'Lock', 'Snap', 'Glue', 'NameUniv', 'ColorTrans'],
    LineGradient: ['GradientStopColor', 'GradientStopColorTrans', 'GradientStopPosition'],
    Paragraph: ['IndFirst', 'IndLeft', 'IndRight', 'SpLine', 'SpBefore', 'SpAfter', 'HorzAlign', 'Bullet', 'BulletStr', 'BulletFont', 'BulletFontSize', 'TextPosAfterBullet', 'Flags'],
    Property: ['Value', 'Prompt', 'Label', 'Format', 'SortKey', 'Type', 'Invisible', 'Verify', 'DataLinked', 'LangID', 'Calendar'],
    Reviewer: ['Name', 'Initials', 'Color', 'ReviewerID', 'CurrentIndex'],
    Scratch: ['X', 'Y', 'A', 'B', 'C', 'D'],
    ActionTag: ['X', 'Y', 'TagName', 'XJustify', 'YJustify', 'DisplayMode', 'ButtonFace', 'Disabled', 'Description'],
    Tabs: ['Position', 'Alignment'],
    User: ['Value', 'Prompt']
    // Annotation: ['X', 'Y', 'ReviewerID', 'MarkerIndex', 'Date', 'Comment', 'LangID'],
    // ConnectionABCD: ['X', 'Y', 'A', 'B', 'C', 'D']
  };

  var VisioSection = /*#__PURE__*/function (_VisioObject) {
    _inherits(VisioSection, _VisioObject);
    var _super = _createSuper(VisioSection);
    function VisioSection(init) {
      var _this;
      _classCallCheck(this, VisioSection);
      _this = _super.call(this, init);
      var _init$rows = init.rows,
        rows = _init$rows === void 0 ? [] : _init$rows,
        _init$cells = init.cells,
        cells = _init$cells === void 0 ? new VisioCells({
          archive: _this.archive
        }) : _init$cells;
      _this.cells = cells;
      _this.rows = rows.map(function (row) {
        return new VisioRow(_objectSpread2(_objectSpread2({}, row), {}, {
          archive: init.archive
        }));
      });
      return _this;
    }
    _createClass(VisioSection, [{
      key: "getRows",
      value: function getRows() {
        var rows = this.rows;
        if (!rows) return [];
        return rows;
      }

      // To be overridden
    }, {
      key: "getRow",
      value: function getRow() {}
    }, {
      key: "addRow",
      value: function addRow() {}
    }, {
      key: "removeRow",
      value: function removeRow() {}

      // Statics
    }], [{
      key: "from",
      value: function from(section) {
        if (section.type === VisioSectionType.Geometry) {
          return new VisioGeometrySection(section);
        } else if (section.type === VisioSectionType.Property) {
          return new VisioDataSection(section);
        } else if (section.type === VisioSectionType.User) {
          return new VisioDataSection(section);
        } else if (VisioSectionStructureType[section.type] === VisioRowStructureType.Indexed) {
          return new VisioIndexedSection(section);
        } else {
          return new VisioNamedSection(section);
        }
      }
    }]);
    return VisioSection;
  }(VisioObject);
  var VisioIndexedSection = /*#__PURE__*/function (_VisioSection) {
    _inherits(VisioIndexedSection, _VisioSection);
    var _super2 = _createSuper(VisioIndexedSection);
    function VisioIndexedSection() {
      _classCallCheck(this, VisioIndexedSection);
      return _super2.apply(this, arguments);
    }
    _createClass(VisioIndexedSection, [{
      key: "getRow",
      value: function getRow(index) {
        var row = this.rows[index];
        if (!row) return null;
        return row;
      }
    }, {
      key: "addRow",
      value: function addRow() {
        var _jxon;
        var lastIndex = this.rows.map(function (section) {
          return section.index;
        }).sort().pop();
        var rowIndex = Number.isInteger(lastIndex) ? lastIndex + 1 : 1;
        var jxon = (_jxon = {}, _defineProperty(_jxon, VisioJxonRowKey.Id, rowIndex.toString()), _defineProperty(_jxon, "Cell", []), _jxon);
        var row = new VisioRow({
          debugType: VisioRowStructureType.Indexed,
          index: rowIndex,
          jxon: jxon,
          archive: this.archive
        });

        // set valid cells based on section type
        var rowCellNames = SECTION_ROW_CELL_NAMES[this.type];
        rowCellNames.forEach(function (name) {
          return row.setCell(name, {
            value: ''
          });
        });

        // update structures
        this.jxon.Row.push(row.jxon);
        this.rows.push(row);
        return row;
      }
    }, {
      key: "removeRow",
      value: function removeRow(index) {
        this.rows.splice(index, 1);
        this.jxon.Row.splice(index, 1);
        return this.rows;
      }
    }]);
    return VisioIndexedSection;
  }(VisioSection);
  var VisioNamedSection = /*#__PURE__*/function (_VisioSection2) {
    _inherits(VisioNamedSection, _VisioSection2);
    var _super3 = _createSuper(VisioNamedSection);
    function VisioNamedSection() {
      _classCallCheck(this, VisioNamedSection);
      return _super3.apply(this, arguments);
    }
    _createClass(VisioNamedSection, [{
      key: "getRow",
      value: function getRow(name) {
        var row = this.rows.find(function (row) {
          return row.name === name;
        });
        if (!row) return null;
        return row;
      }
    }, {
      key: "addRow",
      value: function addRow(name) {
        var _jxon2;
        if (this.rows.findIndex(function (row) {
          return row.name === name;
        }) > -1) {
          throw new Error("Row named \"".concat(name, "\" already exists."));
        }
        var jxon = (_jxon2 = {}, _defineProperty(_jxon2, VisioJxonRowKey.Name, name), _defineProperty(_jxon2, "Cell", []), _jxon2);
        var row = new VisioRow({
          name: name,
          jxon: jxon,
          debugType: VisioRowStructureType.Named,
          archive: this.archive
        });

        // set valid cells based on section type
        var rowCellNames = SECTION_ROW_CELL_NAMES[this.type];
        rowCellNames.forEach(function (name) {
          return row.setCell(name, {
            value: ''
          });
        });

        // update structures
        this.jxon.Row.push(row.jxon);
        this.rows.push(row);
        return row;
      }
    }, {
      key: "removeRow",
      value: function removeRow(name) {
        this.rows = this.rows.filter(function (row) {
          return row.name !== name;
        });
        this.jxon.Row = this.jxon.Row.filter(function (row) {
          return row['@N'] !== name;
        });
        return this.rows;
      }
    }]);
    return VisioNamedSection;
  }(VisioSection);
  var VisioDataSection = /*#__PURE__*/function (_VisioNamedSection) {
    _inherits(VisioDataSection, _VisioNamedSection);
    var _super4 = _createSuper(VisioDataSection);
    function VisioDataSection() {
      _classCallCheck(this, VisioDataSection);
      return _super4.apply(this, arguments);
    }
    _createClass(VisioDataSection, [{
      key: "getProperty",
      value: function getProperty(propertyName) {
        var propertyAttribute = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'value';
        var row = this.getRow(propertyName);
        if (!row) return null;
        return row.cells[propertyAttribute];
      }
    }, {
      key: "getPropertyNames",
      value: function getPropertyNames() {
        return this.rows.map(function (row) {
          return row.name;
        });
      }
    }]);
    return VisioDataSection;
  }(VisioNamedSection);
  var VisioGeometrySection = /*#__PURE__*/function (_VisioIndexedSection) {
    _inherits(VisioGeometrySection, _VisioIndexedSection);
    var _super5 = _createSuper(VisioGeometrySection);
    function VisioGeometrySection(init) {
      var _this2;
      _classCallCheck(this, VisioGeometrySection);
      _this2 = _super5.call(this, init);
      if (init.cells) {
        // todo: create jxon based on existing cells
        // this can be done when working on JXON related classes
        // this jxon is missing when importing a project
        _this2.cells = init.cells;
      } else {
        _this2.cells = new VisioCells({
          archive: _this2.archive
        });
        _this2.jxon.Cell = [];
        SECTION_CELL_NAMES.Geometry.forEach(function (cellName) {
          var locName = firstLetterLowercase(cellName);
          if (_this2.cells.has(locName) || _this2.cells["_".concat(locName)]) return;
          _this2.setCell(cellName, {
            value: ''
          });
        });
      }
      return _this2;
    }
    _createClass(VisioGeometrySection, [{
      key: "getOwnCellNames",
      value: function getOwnCellNames() {
        return VisioSheetObject.prototype.getOwnCellNames.call(this);
      }
    }, {
      key: "getCell",
      value: function getCell(cellName) {
        return VisioSheetObject.prototype.getCell.call(this, cellName);
      }
    }, {
      key: "setCell",
      value: function setCell(name, attributes) {
        if (!SECTION_CELL_NAMES.Geometry.includes(name)) {
          debug.log("Cannot add ".concat(name, " cell to Geometry section."));
          return;
        }
        VisioSheetObject.prototype.setCell.call(this, name, attributes);
      }
    }, {
      key: "removeCell",
      value: function removeCell(cellName) {
        VisioSheetObject.prototype.removeCell.call(this, cellName);
      }
    }, {
      key: "toPath",
      value: function toPath(width, height) {
        var _this$rows = this.rows,
          rows = _this$rows === void 0 ? [] : _this$rows;
        // Visio geometry path, based on cartesian coordinate system
        var d = geometrySingleShapeArrayToPath({
          rows: rows
        }, {
          width: width,
          height: height
        });
        d = jointjs.V.normalizePathData(d);
        var path = new jointjs.g.Path(d);

        // Remove redundant segments at the end so the last segment is differentiable
        // i.e. markers at the end can find a proper direction
        var segCount = path.segments.length;
        while (segCount > 2) {
          if (!path.segments[segCount - 1].end.equals(path.segments[segCount - 2].end)) {
            break;
          }
          path.removeSegment(segCount - 2);
          segCount--;
        }

        // transform geometry path to JointJS non-cartesian coordinate system
        path.translate(0, -height).scale(1, -1);
        return path;
      }

      // adding two RelMoveTo rows next ot each other, at index 1 and 2 seems to hang Visio
    }, {
      key: "addRow",
      value: function addRow(geometryRowType) {
        var row = _get(_getPrototypeOf(VisioGeometrySection.prototype), "addRow", this).call(this);
        var rowType = geometryRowType;
        if (!rowType) {
          // just called super, so at least one row will be present
          rowType = this.getRows().length === 1 ? VisioRowType.RelMoveTo : VisioRowType.RelLineTo;
        }
        row.type = rowType;
        return row;
      }
    }]);
    return VisioGeometrySection;
  }(VisioIndexedSection);

  // `Map` constructor
  // https://tc39.es/ecma262/#sec-map-objects
  collection('Map', function (init) {
    return function Map() { return init(this, arguments.length ? arguments[0] : undefined); };
  }, collectionStrong);

  // `FlattenIntoArray` abstract operation
  // https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
  var flattenIntoArray = function (target, original, source, sourceLen, start, depth, mapper, thisArg) {
    var targetIndex = start;
    var sourceIndex = 0;
    var mapFn = mapper ? functionBindContext(mapper, thisArg) : false;
    var element, elementLen;

    while (sourceIndex < sourceLen) {
      if (sourceIndex in source) {
        element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

        if (depth > 0 && isArray(element)) {
          elementLen = lengthOfArrayLike(element);
          targetIndex = flattenIntoArray(target, original, element, elementLen, targetIndex, depth - 1) - 1;
        } else {
          doesNotExceedSafeInteger(targetIndex + 1);
          target[targetIndex] = element;
        }

        targetIndex++;
      }
      sourceIndex++;
    }
    return targetIndex;
  };

  var flattenIntoArray_1 = flattenIntoArray;

  // `Array.prototype.flat` method
  // https://tc39.es/ecma262/#sec-array.prototype.flat
  _export({ target: 'Array', proto: true }, {
    flat: function flat(/* depthArg = 1 */) {
      var depthArg = arguments.length ? arguments[0] : undefined;
      var O = toObject(this);
      var sourceLen = lengthOfArrayLike(O);
      var A = arraySpeciesCreate(O, 0);
      A.length = flattenIntoArray_1(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toIntegerOrInfinity(depthArg));
      return A;
    }
  });

  // this method was added to unscopables after implementation
  // in popular engines, so it's moved to a separate module


  // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
  addToUnscopables('flat');

  function expectedSchema(jxonTree, xmlSchemaKey) {
    //TODO miky even the "@xmlns:r"

    if (!XmlSchema.hasOwnProperty(xmlSchemaKey)) debug.log("Unknown xmlSchemaKey \"".concat(xmlSchemaKey, "\""), {
      jxonTree: jxonTree
    });

    // special case
    if (xmlSchemaKey === XmlSchemaKey.DrawingML && jxonTree['@xmlns:a'] === XmlSchema.DrawingML) return; // ok

    // special case
    if (xmlSchemaKey === XmlSchemaKey.Theme && jxonTree['@xmlns:vt'] === XmlSchema.Theme) return; // ok

    // universal
    if (!jxonTree.hasOwnProperty('@xmlns') || !jxonTree['@xmlns']) debug.log('"@xmlns" attribute not found', {
      jxonTree: jxonTree
    });
    if (jxonTree['@xmlns'] !== XmlSchema[xmlSchemaKey]) debug.log("Unexpected schema actual: \"".concat(jxonTree['@xmlns'], "\" ") + "(expected \"".concat(XmlSchema[xmlSchemaKey], "\")"));
  }

  function assertIsSimpleShapeJxon(shapeJxon) {

    assertHasKeyValue('SimpleShape', shapeJxon, _defineProperty({}, VisioJxonShapeKey.Type, VisioShapeType.Shape));
  }
  function assertIsGroupedShapeJxon(groupedShapeJxon) {
    assertHasKeyValue('GroupedShape', groupedShapeJxon, _defineProperty({}, VisioJxonShapeKey.Type, VisioShapeType.Group));
  }

  /**
   * @param {VisioCellJXON} cell
   * @returns {boolean}
   */
  function assertIsCellJxon(cell) {
    if (_typeof(cell) !== 'object') debug.log('Cell is not object.', cell);
    var requiredKeys = [VisioJxonCellKey.Name
    //TODO miky FIGS.vsdx has cell with formula only!!!
    // VisioJxonCellKey.Value,
    ];

    requiredKeys.forEach(function (key) {
      if (!cell.hasOwnProperty(key)) debug.log('Cell required key "${key}" missing.', cell);
    });
  }
  function assertIsRelationshipJxon(relationshipJxon /*, { type = null }*/) {
    // if (type) {
    //     const keyValues = {
    //         [VisioRelationType.Master]: {
    //             [VisioJxonRelationKey.Type]: VisioRelationTypeSchema.Master
    //         },
    //     }[type] || {};
    //
    //     assertHasKeyValue(
    //         'Relationship',
    //         relationshipJxon,
    //         keyValues
    //     );
    // }
  }

  function assertIsRelJxon(relJxon) {
    var attributesCount = Object.keys(relJxon).length;
    if (attributesCount !== 1) debug.log('Rel should have one attribute', relJxon);
  }
  function assertIsDocumentColorJxon(documentColorJxon) {
    var attributesCount = Object.keys(documentColorJxon).length;
    if (attributesCount !== 1) debug.log('DocumentColor should have one attribute', {
      documentColorJxon: documentColorJxon
    });
  }
  function assertIsDocumentColorEntryRgbJxon(documentColorEntryRgbJxon) {
    var attributesCount = Object.keys(documentColorEntryRgbJxon).length;
    if (attributesCount !== 2) debug.log('documentColorEntryRgbJxon should have two attributes', {
      documentColorEntryRgbJxon: documentColorEntryRgbJxon
    });
  }

  // // template
  // export function assertIsXxxJxon(xxx) {
  //     assertIsJxonTreeWithKeys(
  //         'xxx',
  //         xxx,
  //         [
  //         ],
  //         [
  //         ]
  //     );
  //
  //     assertHasKeyValue(
  //         'xxx',
  //         xxx,
  //         {
  //         }
  //     );
  // }

  /**
   * @param {string} string
   * @returns {number}
   */
  function relationshipToNumber(string) {
    var idPattern = /^rId(\d+)$/;
    if (!idPattern.test(string)) debug.log('incorrect format of relationship to master', string);
    return asInteger(string.match(idPattern)[1]);
  }

  function getParsedRel(relJxon) {
    assertIsRelJxon(relJxon);
    return relationshipToNumber(relJxon[VisioJxonRelKey.RelId]);
  }

  /**
   * @param {VisioShapeTextJXON} textJxon
   * @param {VisioStructurePath} structurePath
   * @returns {VisioShapeText}
   */
  function getParsedText(textJxon, structurePath) {
    // assertIsShapeTextJxon(textJxon);

    var text = getRootAttributes(textJxon, VisioJxonType.ShapeText, structurePath);
    var _textJxon$orderedNode = textJxon.orderedNodes,
      orderedNodes = _textJxon$orderedNode === void 0 ? [] : _textJxon$orderedNode;

    // full structure (format, dynamic parts)
    var structure = [];
    var characterPropertiesIndex = null;
    var paragraphPropertiesIndex = null;
    var tabsPropertiesIndex = null;
    var structureNode = newNode(structure, {
      characterPropertiesIndex: characterPropertiesIndex,
      paragraphPropertiesIndex: paragraphPropertiesIndex,
      tabsPropertiesIndex: tabsPropertiesIndex
    });
    var _iterator = _createForOfIteratorHelper(orderedNodes),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var node = _step.value;
        // static string content
        if (typeof node === 'string') {
          pushContent(structureNode, node);
          continue;
        }
        var tagName = /** @type {'cp'|'pp'|'tp'} */node._tagName;
        var index = asNumber(node['@IX']);

        // Properties
        if (['cp', 'pp', 'tp'].includes(tagName)) {
          // new content part
          if (hasContent(structureNode)) structureNode = newNode(structure, {
            characterPropertiesIndex: characterPropertiesIndex,
            paragraphPropertiesIndex: paragraphPropertiesIndex,
            tabsPropertiesIndex: tabsPropertiesIndex
          });
          if (tagName === 'cp') {
            characterPropertiesIndex = index;
            structureNode.characterPropertiesIndex = index;
          }
          if (tagName === 'pp') {
            paragraphPropertiesIndex = index;
            structureNode.paragraphPropertiesIndex = index;
          }
          if (tagName === 'tp') {
            tabsPropertiesIndex = index;
            structureNode.tabsPropertiesIndex = index;
          }
        } else if (tagName === 'fld') {
          pushContent(structureNode, {
            fieldIndex: index,
            defaultValue: node.keyValue
          });
        } else debug.log('Unknown text tag.', {
          tagName: tagName,
          textJxon: textJxon
        });
      }

      // remove last if empty
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var lastStructureItem = structure[structure.length - 1];
    if (lastStructureItem.content === undefined) structure.pop();
    text.structure = structure;
    return text;
  }
  function pushContent(structureNode, content) {
    if (!hasContent(structureNode)) structureNode.content = [];
    structureNode.content.push(content);
  }
  function hasContent(structureNode) {
    return Array.isArray(structureNode.content);
  }
  function newNode(structure, _ref) {
    var characterPropertiesIndex = _ref.characterPropertiesIndex,
      paragraphPropertiesIndex = _ref.paragraphPropertiesIndex,
      tabsPropertiesIndex = _ref.tabsPropertiesIndex;
    var node = {};
    if (characterPropertiesIndex !== null) node.characterPropertiesIndex = characterPropertiesIndex;
    if (paragraphPropertiesIndex !== null) node.paragraphPropertiesIndex = paragraphPropertiesIndex;
    if (tabsPropertiesIndex !== null) node.tabsPropertiesIndex = tabsPropertiesIndex;
    structure.push(node);
    return node;
  }

  /**
   * @param {VisioCellJXON} cell
   * @returns {VisioCellName}
   */
  function getName(cell) {
    return cell[VisioJxonCellKey.Name];
  }

  /**
   * @param {VisioCellJXON} cell
   * @returns {VisioUnitType}
   */
  function getUnits(cell) {
    return cell[VisioJxonCellKey.Units];
  }

  /**
   * @param {VisioCellJXON} cell
   * @returns {string}
   */
  function getValueString(cell) {
    var key = VisioJxonCellKey.Value;
    if (key in cell) return cell[key];
    return cell.keyValue;
  }

  /**
   * @param {VisioCellJXON} cell
   * @returns {string}
   */
  function getFormulaString(cell) {
    return cell[VisioJxonCellKey.Formula];
  }

  /**
   * @this {Visio}
   * @param {VisioCellJXON|Array.<VisioCellJXON>} cellsJxonOrArrayOfJxons
   * @param {VisioStructurePath} structurePath
   * @returns {Object}
   */
  function parseCellsAttributes(cellsJxonOrArrayOfJxons, structurePath) {
    var _this = this;
    if (!structurePath) debug.log('path not defined');
    var cellsJxonArray = toArray(cellsJxonOrArrayOfJxons);
    return cellsJxonArray.reduce(function (parsedCells, cellJxon) {
      assertIsCellJxon(cellJxon);
      var parsedCell = parseCellAttribute.call(_this, cellJxon, structurePath);
      parsedCells[parsedCell.name] = parsedCell;
      return parsedCells;
    }, {});
  }

  /**
   * Normalize a name
   * all magic done in Cells.getter
   *
   * @this {Visio}
   * @param {VisioCellJXON} cell
   * @param {VisioStructurePath} structurePath
   * @returns {VisioCell|null}
   */
  function parseCellAttribute(cell, structurePath) {
    var cellAttributeName = getName(cell);
    if (!VisioCellName.hasOwnProperty(cellAttributeName)) {
      debug.log('unknown cell attribute name', cellAttributeName);
    }
    return {
      name: visioAttributeNameToRappidConvention(cellAttributeName),
      value: getValueString(cell),
      formula: getFormulaString(cell) || null,
      units: getUnits(cell)
    };
  }

  /**
   *
   * @param {VisioCellName} visioAttributeName
   * @returns {string}
   */
  function visioAttributeNameToRappidConvention(visioAttributeName) {
    if (visioAttributeName === 'Case') return 'uppercase';
    return firstLetterLowercase(visioAttributeName);
  }

  function getKeyValuesFromJxon(visioJxon) {
    var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var jxonType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    return Object.entries(visioJxon)
    // only non attributes (not starting with @)
    .filter(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
        key = _ref2[0],
        _value = _ref2[1];
      return key[0] !== '@';
    })
    // convert to key: value structure
    .reduce(function (result, _ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
        attributeName = _ref4[0],
        value = _ref4[1];
      var normalizedAttributeName = normalizeRootKey(attributeName, jxonType);
      if (result.hasOwnProperty(normalizedAttributeName)) debug.log("keys collision ".concat(normalizedAttributeName), visioJxon);
      var keyValue = value.hasOwnProperty('keyValue') ? value['keyValue'] : null;
      result[normalizedAttributeName] = parseRootValue(normalizedAttributeName, keyValue);
      return result;
    }, base);
  }

  function parseDocumentSettings(documentSettingsJxon, structurePath) {
    var rootAttributes = getRootAttributes(documentSettingsJxon, VisioJxonType.DocumentSettings, structurePath);
    return getKeyValuesFromJxon(documentSettingsJxon, rootAttributes);
  }

  /**
   * @param {VisioJxon} colorsJxon
   * @param {VisioStructurePath} structurePath
   * @returns {Map}
   */
  function parseColors(colorsJxon, structurePath) {
    assertIsDocumentColorJxon(colorsJxon);
    var baseColors = getDefaultColors();
    var colorEntriesArray = toArray(colorsJxon[VisioJxonDocumentKey.ColorEntry]);
    return colorEntriesArray.reduce(function (colorEntriesById, colorEntryJxon) {
      assertIsDocumentColorEntryRgbJxon(colorEntryJxon);
      var ix = colorEntryJxon[VisioJxonDocumentKey.Ix];
      var rgb = colorEntryJxon[VisioJxonDocumentKey.Rgb];
      if (colorEntriesById.has(ix)) debug.log('Color override', {
        colorsJxon: colorsJxon
      });
      colorEntriesById.set(ix, rgb);
      return colorEntriesById;
    }, baseColors);
  }

  /**
   * @returns {Map<number, string>}
   */
  function getDefaultColors() {
    var base = new Map();
    base.set(0, '#000000');
    base.set(1, '#FFFFFF');
    base.set(2, '#FF0000');
    base.set(3, '#00FF00');
    base.set(4, '#0000FF');
    base.set(5, '#FFFF00');
    base.set(6, '#FF00FF');
    base.set(7, '#00FFFF');
    base.set(8, '#800000');
    base.set(9, '#008000');
    base.set(10, '#000080');
    base.set(11, '#808000');
    base.set(12, '#800080');
    base.set(13, '#008080');
    base.set(14, '#C0C0C0');
    base.set(15, '#E6E6E6');
    base.set(16, '#CDCDCD');
    base.set(17, '#B3B3B3');
    base.set(18, '#9A9A9A');
    base.set(19, '#808080');
    base.set(20, '#666666');
    base.set(21, '#4D4D4D');
    base.set(22, '#333333');
    base.set(23, '#1A1A1A');
    return base;
  }

  var FORCED$4 = fails(function () {
    return new Date(NaN).toJSON() !== null
      || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
  });

  // `Date.prototype.toJSON` method
  // https://tc39.es/ecma262/#sec-date.prototype.tojson
  _export({ target: 'Date', proto: true, arity: 1, forced: FORCED$4 }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    toJSON: function toJSON(key) {
      var O = toObject(this);
      var pv = toPrimitive(O, 'number');
      return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
    }
  });

  // `URL.prototype.toJSON` method
  // https://url.spec.whatwg.org/#dom-url-tojson
  _export({ target: 'URL', proto: true, enumerable: true }, {
    toJSON: function toJSON() {
      return functionCall(URL.prototype.toString, this);
    }
  });

  function getArrows(cells) {
    var endArrow = cells.endArrow,
      endArrowSize = cells.endArrowSize,
      beginArrow = cells.beginArrow,
      beginArrowSize = cells.beginArrowSize,
      lineWeight = cells.lineWeight;
    var arrows = {};
    if (beginArrow) {
      arrows.sourceMarker = getArrow(beginArrow, beginArrowSize, lineWeight);
    } else {
      arrows.sourceMarker = null;
    }
    if (endArrow) {
      arrows.targetMarker = getArrow(endArrow, endArrowSize, lineWeight);
    } else {
      arrows.targetMarker = null;
    }
    return arrows;
  }
  function getArrow(_arrowType) {
    var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var lineWeight = arguments.length > 2 ? arguments[2] : undefined;
    // defaults
    var fill = '#000000';
    var stroke = '#000000';
    var arrowDefinition = arrowPath(_arrowType);
    if (!arrowDefinition) return null;
    var d = arrowDefinition.d,
      type = arrowDefinition.type;
    if (d.includes('A') || d.includes('a')) d = jointjs.V.normalizePathData(d);
    var path = new jointjs.g.Path(d); //TODO miky
    var scale = getScale(size); //TODO miky
    path.scale(scale, scale);
    if (type === 'stroke') {
      fill = 'none';
    }
    if (type === 'fill') {
      stroke = 'none';
    }
    if (type === 'stroke-empty') {
      fill = '#ffffff';
    }
    return {
      'type': 'path',
      'd': path.serialize(),
      'stroke-width': lineWeight,
      fill: fill,
      stroke: stroke
    };
  }
  function getScale(size) {
    switch (size) {
      case 0:
        return 3.253333333333325;
      case 1:
        return 3.7333333333333236;
      case 2:
        return 4.693333333333321;
      case 3:
        return 5.653333333333319;
      case 4:
        return 6.613333333333316;
      case 5:
        return 13.3333333333333;
      case 6:
        return 25.333333333333268;
      default:
        return 4.693333333333321;
    }
  }
  function arrowPath(type) {
    switch (type) {
      case 0:
        return null;
      case 1:
        return {
          d: 'M 1 -1 L 0 0 L 1 1',
          type: 'stroke'
        };
      case 2:
        return {
          d: 'M 1 1 L 0 0 L 1 -1 L 1 1',
          type: 'fill'
        };
      case 3:
        return {
          d: 'M 2 -1 0 0 2 1',
          type: 'stroke'
        };
      case 4:
        return {
          d: 'M 2 -1 0 0 2 1 Z',
          type: 'fill'
        };
      case 5:
        return {
          d: 'M 2 1 L 0 0 L 1.98117 -0.993387 C 1.67173 -0.364515 1.67301 0.372641 1.98465 1.00043',
          type: 'fill'
        };
      case 6:
        return {
          d: 'M 2 1 L 0 0 L 2.01237 -1.00641 C 2.32921 -0.372874 2.32921 0.37287 2.01238 1.0064',
          type: 'fill'
        };
      case 7:
        return {
          d: 'M 1.84309 -0.959455 C 1.43792 -0.3808 0.784502 -0.0260248 0.0785258 -0.00137083 L 0.0785228 0.00137063 C 0.784499 0.0260235 1.43791 0.380798 1.84309 0.959452',
          type: 'stroke'
        };
      case 8:
        return {
          d: 'M 1.84309 -0.959455 C 1.43792 -0.3808 0.784502 -0.0260248 0.0785258 -0.00137083 L 0.0785228 0.00137063 C 0.784499 0.0260235 1.43791 0.380798 1.84309 0.959452 C 1.67173 0.364515 1.67301 -0.372641 1.84309 -0.959455',
          type: 'fill'
        };
      case 9:
        return {
          d: 'M -1 -1 0 0 1 1',
          type: 'stroke'
        };
      case 10:
        return {
          d: 'M -1 0 a 1 1 0 1 0 2 0 a 1 1 0 1 0 -2 0',
          type: 'fill'
        };
      case 11:
        return {
          d: 'M -1 -1 1 -1 1 1 -1 1 z',
          type: 'fill'
        };
      case 12:
        return {
          d: 'M 2 -1 0 0 2 1',
          type: 'stroke'
        };
      case 13:
        return {
          d: 'M 3 -1 0 0 3 1 Z',
          type: 'fill'
        };
      case 14:
        return {
          d: 'M 3 -1 0 0 3 1 Z',
          type: 'stroke-empty'
        };
      case 15:
        return {
          d: 'M 1 -1 0 0 1 1 Z',
          type: 'stroke-empty'
        };
      case 16:
        return {
          d: 'M 2 -1 0 0 2 1 Z',
          type: 'stroke-empty'
        };
      case 17:
        return {
          d: 'M 2 1 L 0 0 L 1.98117 -0.993387 C 1.67051 -0.362037 1.67309 0.378293 1.98815 1.00746',
          type: 'stroke-empty'
        };
      case 18:
        return {
          d: 'M 2 1 L 0 0 L 2.01237 -1.00641 C 2.32921 -0.372874 2.32921 0.37287 2.01238 1.0064',
          type: 'stroke-empty'
        };
      case 19:
        return {
          d: 'M 1.95144 1.125 C 1.55653 0.440984 1.54919 -0.400016 1.93211 -1.09082 L 1.92863 -1.09117 C 1.52903 -0.42613 0.815004 -0.013884 0.0392696 -0.000342899 L 0.0392671 0.000342659 C 0.815002 0.0138829 1.52903 0.426128 1.92863 1.09116',
          type: 'stroke-empty'
        };
      case 20:
        return {
          d: 'M -1 0 a 1 1 0 1 0 2 0 a 1 1 0 1 0 -2 0',
          type: 'stroke-empty'
        };
      case 21:
        return {
          d: 'M -1 -1 1 -1 1 1 -1 1 z',
          type: 'stroke-empty'
        };
      case 22:
        return {
          d: 'M 0 0 2 -1 4 0 2 1 z',
          type: 'stroke-empty'
        };
      case 23:
        return {
          d: 'M 2.5 -1 1.5 1',
          type: 'stroke'
        };
      case 24:
        return {
          d: 'M 1.5 -0.75 L 1.5 0.75',
          type: 'stroke'
        };
      case 25:
        return {
          d: 'M 1.5 -0.75 1.5 0.75 M 2.25 -0.75 2.25 0.75',
          type: 'stroke'
        };
      case 26:
        return {
          d: 'M 1.5 -0.75 L 1.5 0.75 M 2.25 -0.75 L 2.25 0.75 M 3 -0.75 L 3 0.75',
          type: 'stroke'
        };
      case 27:
        return {
          d: 'M 0 -0.75 L 1.5 0 L 0 0.75',
          type: 'stroke'
        };
      case 28:
        return {
          d: 'M 0 -0.75 L 1.5 0 L 0 0.75 M 2 -0.75 L 2 0.75',
          type: 'stroke'
        };
      case 29:
        return {
          d: 'M 2.25 0.75 C 1.83579 0.75 1.5 0.414214 1.5 0 1.5 -0.414214 1.83579 -0.75 2.25 -0.75 2.66421 -0.75 3 -0.414214 3 0 3 0.414214 2.66421 0.75 2.25 0.75 Z M 0 -0.75 L 1.5 0 L 0 0.75 M 1.5 0 L 0 0',
          type: 'stroke-empty'
        };
      case 30:
        return {
          d: 'M 2.25 0.75 C 1.83579 0.75 1.5 0.414214 1.5 0 1.5 -0.414214 1.83579 -0.75 2.25 -0.75 2.66421 -0.75 3 -0.414214 3 0 3 0.414214 2.66421 0.75 2.25 0.75 Z M 0.75 -0.75 L 0.75 0.75 M 1.5 0 L 0 0',
          type: 'stroke-empty'
        };
      case 31:
        return {
          d: 'M 0.75 0.75 C 0.335786 0.75 0 0.414214 0 0 0 -0.414214 0.335786 -0.75 0.75 -0.75 1.16421 -0.75 1.5 -0.414214 1.5 0 1.5 0.414214 1.16421 0.75 0.75 0.75 Z M 2.25 -0.75 L 2.25 0.75',
          type: 'stroke-empty'
        };
      case 32:
        return {
          d: 'M 0.75 0.75 C 0.335786 0.75 0 0.414214 0 0 0 -0.414214 0.335786 -0.75 0.75 -0.75 1.16421 -0.75 1.5 -0.414214 1.5 0 1.5 0.414214 1.16421 0.75 0.75 0.75 Z M 2.25 -0.75 L 2.25 0.75 M 3 -0.75 L 3 0.75',
          type: 'stroke-empty'
        };
      case 33:
        return {
          d: 'M 0.75 0.75 C 0.335786 0.75 0 0.414214 0 0 0 -0.414214 0.335786 -0.75 0.75 -0.75 1.16421 -0.75 1.5 -0.414214 1.5 0 1.5 0.414214 1.16421 0.75 0.75 0.75 Z M 2.25 -0.75 L 2.25 0.75 M 3 -0.75 L 3 0.75 M 3.75 -0.75 L 3.75 0.75',
          type: 'stroke-empty'
        };
      case 34:
        return {
          d: 'M 0.75 0.75 C 0.335786 0.75 0 0.414214 0 0 0 -0.414214 0.335786 -0.75 0.75 -0.75 1.16421 -0.75 1.5 -0.414214 1.5 0 1.5 0.414214 1.16421 0.75 0.75 0.75 Z M 1.5 0 L 3.75 -1.15 L 6 0 L 3.75 1.15 L 1.5 0',
          type: 'stroke-empty'
        };
      case 35:
        // <path
        //      d="M 0.75 0.75 C 0.335786 0.75 0 0.414214 0 0 0 -0.414214 0.335786 -0.75 0.75 -0.75 1.16421 -0.75 1.5 -0.414214 1.5 0 1.5 0.414214 1.16421 0.75 0.75 0.75 Z"
        //      stroke="none"
        // ></path>
        // <path
        //      d="M 2.25 -0.75 L 2.25 0.75"
        //      stroke-linecap="round"
        //      stroke-linejoin="round"
        //      fill="none"
        //  ></path>
        return {
          d: 'M 0.75 0.75 C 0.335786 0.75 0 0.414214 0 0 0 -0.414214 0.335786 -0.75 0.75 -0.75 1.16421 -0.75 1.5 -0.414214 1.5 0 1.5 0.414214 1.16421 0.75 0.75 0.75 Z' + ' M 2.25 -0.75 L 2.25 0.75',
          type: 'stroke'
        };
      case 36:
        //  <path d="M 0.75 0.75 C 0.335786 0.75 0 0.414214 0 0 0 -0.414214 0.335786 -0.75 0.75 -0.75 1.16421 -0.75 1.5 -0.414214 1.5 0 1.5 0.414214 1.16421 0.75 0.75 0.75 Z M 2.25 -0.75 L 2.25 0.75 M 3 -0.75 L 3 0.75"
        //                   stroke="none"></path>
        //             <path d="M 2.25 -0.75 L 2.25 0.75 M 3 -0.75 L 3 0.75" stroke-linecap="round"
        //                   stroke-linejoin="round" fill="none"></path>
        return {
          d: 'M 0.75 0.75 C 0.335786 0.75 0 0.414214 0 0 0 -0.414214 0.335786 -0.75 0.75 -0.75 1.16421 -0.75 1.5 -0.414214 1.5 0 1.5 0.414214 1.16421 0.75 0.75 0.75 Z M 2.25 -0.75 L 2.25 0.75 M 3 -0.75 L 3 0.75' + 'M 2.25 -0.75 L 2.25 0.75 M 3 -0.75 L 3 0.75',
          type: 'fill'
        };
      case 37:
        // <path d="M 0.75 0.75 C 0.335786 0.75 0 0.414214 0 0 0 -0.414214 0.335786 -0.75 0.75 -0.75 1.16421 -0.75 1.5 -0.414214 1.5 0 1.5 0.414214 1.16421 0.75 0.75 0.75 Z M 2.25 -0.75 L 2.25 0.75"
        //                   stroke="none"></path>
        //             <path d="M 3 -0.75 L 3 0.75 M 3.75 -0.75 L 3.75 0.75" stroke-linecap="round"
        //                   stroke-linejoin="round" fill="none"></path>
        return {
          d: '',
          type: 'fill'
        };
      case 38:
        //  <path d="M 0.75 0.75 C 0.335786 0.75 0 0.414214 0 0 0 -0.414214 0.335786 -0.75 0.75 -0.75 1.16421 -0.75 1.5 -0.414214 1.5 0 1.5 0.414214 1.16421 0.75 0.75 0.75 Z"
        //                   stroke="none"></path>
        //             <path d="M 1.5 0 L 3.75 -1.15 L 6 0 L 3.75 1.15 L 1.5 0"
        //                   stroke-linecap="round" stroke-linejoin="round" fill="none"></path>
        return {
          d: 'M 0.75 0.75 C 0.335786 0.75 0 0.414214 0 0 0 -0.414214 0.335786 -0.75 0.75 -0.75 1.16421 -0.75 1.5 -0.414214 1.5 0 1.5 0.414214 1.16421 0.75 0.75 0.75 Z ' + 'M 1.5 0 L 3.75 -1.15 ' + 'M 3.75 -1.15 L 6 0 ' + 'M 6 0 L 3.75 1.15 ' + 'M 3.75 1.15 L 1.5 0',
          // type: 'stroke'
          // type: 'fill'
          type: 'stroke-empty'
        };
      case 39:
        return {
          d: 'M 0 0 L 2 -1 L 2 1 L 0 0 M 2 0 L 4 -1 L 4 1 L 2 0',
          type: 'fill'
        };
      case 40:
        return {
          d: 'M 0 0 L 2 -1 L 2 1 L 0 0 M 2 0 L 4 -1 L 4 1 L 2 0',
          type: 'stroke-empty'
        };
      case 41:
        return {
          d: 'M 0.75 0.75 C 0.335786 0.75 0 0.414214 0 0 0 -0.414214 0.335786 -0.75 0.75 -0.75 1.16421 -0.75 1.5 -0.414214 1.5 0 1.5 0.414214 1.16421 0.75 0.75 0.75 Z',
          type: 'stroke-empty'
        };
      case 42:
        return {
          d: 'M 0.75 0.75 C 0.335786 0.75 0 0.414214 0 0 0 -0.414214 0.335786 -0.75 0.75 -0.75 1.16421 -0.75 1.5 -0.414214 1.5 0 1.5 0.414214 1.16421 0.75 0.75 0.75 Z M 2.25 -0.75 L 2.25 0.75 M 3 -0.75 L 3 0.75',
          type: 'fill'
        };
      case 43:
        return {
          d: 'M 2 -1 L 0 0 L 2 1 M 4 -1 L 2 0 L 4 1',
          type: 'stroke'
        };
      case 44:
        return {
          d: 'M 2 -1 L 0 0 L 2 1 M 3 0.75 L 3 -0.75',
          type: 'stroke'
        };
      case 45:
        return {
          d: 'M 2 -1 L 0 0 L 2 1 M 4 -1 L 2 0 L 4 1 M 5 0.75 L 5 -0.75',
          type: 'stroke'
        };
      //TODO miky
      // Use the master that is specified by the formula associated with this cell for the Arrowhead.
    }
  }

  /**
   * @param {number} linePattern (1-23)
   * @return {string}
   */
  function getLinePatternStrokeDasharray(linePattern) {
    switch (linePattern) {
      case 1:
      default:
        return 'none';
      // solid
      case 2:
        return '7 5';
      case 3:
        return '0 5';
      case 4:
        return '7 5 0 5';
      case 5:
        return '7 5 0 5 0 5';
      case 6:
        return '7 5 7 5 0 5';
      case 7:
        return '19 5 7 5';
      case 8:
        return '19 5 7 5 7 5';
      case 9:
        return '3 3';
      case 10:
        return '0 5';
      case 11:
        return '3 3 0 3';
      case 12:
        return '3 3 0 3 0 3';
      case 13:
        return '3 3 3 3 0 3';
      case 14:
        return '9 3 3 3';
      case 15:
        return '9 3 3 3 3 3';
      case 16:
        return '15 9';
      case 17:
        return '0 9';
      case 18:
        return '15 9 0 9';
      case 19:
        return '15 9 0 9 0 9';
      case 20:
        return '15 9 15 9 0 9';
      case 21:
        return '39 9 15 9';
      case 22:
        return '39 9 15 9 15 9';
      case 23:
        return '1 2';
    }
  }

  function getShapePagePoints(shape) {
    var _shape$getComputedGeo = shape.getComputedGeometry(),
      _shape$getComputedGeo2 = _slicedToArray(_shape$getComputedGeo, 1),
      geometry = _shape$getComputedGeo2[0];
    if (!geometry) return null;
    var width = shape.width,
      height = shape.height,
      pageContent = shape.pageContent;
    var _shape$cells = shape.cells,
      locPinX = _shape$cells.locPinX,
      locPinY = _shape$cells.locPinY,
      angle = _shape$cells.angle,
      flipX = _shape$cells.flipX,
      flipY = _shape$cells.flipY;
    var path = geometry.toPath(width, height);
    var _path$toPolylines = path.toPolylines(),
      _path$toPolylines2 = _slicedToArray(_path$toPolylines, 1),
      polyline = _path$toPolylines2[0];
    polyline.simplify();
    var relativePoints = polyline.points;
    var flipMod = flipX && !flipY || flipY && !flipX;
    relativePoints.forEach(function (relativePoint) {
      var x = locPinX;
      var y = locPinY;
      relativePoint.translate(0, -height).scale(1, -1);
      if (angle) {
        relativePoint.rotate({
          x: x,
          y: y
        }, flipMod ? -angle : angle);
      }
    });
    var sx = flipX ? -1 : 1;
    var sy = flipY ? -1 : 1;
    polyline.scale(sx, sy, {
      x: locPinX,
      y: locPinY
    });

    // TODO: Can't use shape.getPagePosition() when height has a negative value
    var matrix = shape.getPageMatrix();
    var px = matrix.e;
    var py = pageContent.page.height - matrix.f;
    var pagePoints = relativePoints.map(function (_ref) {
      var x = _ref.x,
        y = _ref.y;
      return {
        x: px + x,
        y: py - y
      };
    });
    return pagePoints;
  }

  /**
   *
   * @param {rappid.format.visio.Connect} [connect]
   * @returns {{attrs: {line: {targetMarker: null, sourceMarker: null}, root: {title: string}}}}
   */
  function convertVisioConnectToRappidAttributes(connect, sourceElement, targetElement) {
    var shape = connect.getShape();
    var pagePoints = getShapePagePoints(shape);
    if (!Array.isArray(pagePoints) || pagePoints.length < 2) {
      // always need points (for vertices)
      return null;
    }
    var attributes = {};

    // 'attrs'

    var _getArrows = getArrows(shape.cells),
      _getArrows$sourceMark = _getArrows.sourceMarker,
      sourceMarker = _getArrows$sourceMark === void 0 ? null : _getArrows$sourceMark,
      _getArrows$targetMark = _getArrows.targetMarker,
      targetMarker = _getArrows$targetMark === void 0 ? null : _getArrows$targetMark;
    var _shape$cells = shape.cells,
      _shape$cells$lineWeig = _shape$cells.lineWeight,
      lineWeight = _shape$cells$lineWeig === void 0 ? 1 : _shape$cells$lineWeig,
      _shape$cells$lineColo = _shape$cells.lineColor,
      lineColor = _shape$cells$lineColo === void 0 ? '#000000' : _shape$cells$lineColo,
      _shape$cells$linePatt = _shape$cells.linePattern,
      linePattern = _shape$cells$linePatt === void 0 ? 'none' : _shape$cells$linePatt;
    var attrs = {
      line: {
        sourceMarker: sourceMarker,
        targetMarker: targetMarker,
        stroke: lineColor,
        strokeWidth: Math.max(lineWeight, 1),
        strokeDasharray: getLinePatternStrokeDasharray(linePattern)
      }
    };
    var noShow = shape.getComputedGeometry().every(function (geom) {
      return geom.cells.noShow;
    });
    if (noShow) {
      attrs.line.visibility = 'hidden';
    }
    if (debug.level & debug.TOOLTIPS) {
      attrs.root = {
        title: "".concat(connect.tooltip)
      };
    }
    attributes.attrs = attrs;

    // 'source'
    var startPagePoint = pagePoints.shift();
    if (sourceElement) {
      var _calculateLinkOffset = calculateLinkOffset(sourceElement, startPagePoint),
        dx = _calculateLinkOffset.dx,
        dy = _calculateLinkOffset.dy;
      attributes.source = {
        id: sourceElement.id,
        anchor: {
          name: 'modelCenter',
          args: {
            dx: dx,
            dy: dy,
            rotate: true
          }
        }
      };
    } else {
      if (connect.getSource()) return null;
      attributes.source = new jointjs.g.Point(startPagePoint.x, startPagePoint.y).toJSON();
    }

    // 'target'
    var endPagePoint = pagePoints.pop();
    if (targetElement) {
      var _calculateLinkOffset2 = calculateLinkOffset(targetElement, endPagePoint),
        _dx = _calculateLinkOffset2.dx,
        _dy = _calculateLinkOffset2.dy;
      attributes.target = {
        id: targetElement.id,
        anchor: {
          name: 'modelCenter',
          args: {
            dx: _dx,
            dy: _dy,
            rotate: true
          }
        }
      };
    } else {
      if (connect.getTarget()) return null;
      attributes.target = new jointjs.g.Point(endPagePoint.x, endPagePoint.y).toJSON();
    }

    // 'vertices'
    attributes.vertices = pagePoints;
    return attributes;
  }

  /**
   *
   * @param {format.visio.Shape} [shape]
   * @param {Map<number,dia.Element>} [elementsMap]
   * @returns {dia.Element | undefined}
   */
  function getLinkConnectedShapeFromVisioConnect(shape, elementsMap) {
    var nearestElement = getNearestElementIdAndOffset(elementsMap, shape);
    if (!nearestElement) {
      debug.log('no nearestElement source');
      return null;
    }
    // TODO: investigate when the condition is not true
    // as this code could be possibly simplified.
    // shape.getRootShape() !== shape
    var groupShapeId = nearestElement.shapeId;
    return elementsMap.get(groupShapeId);
  }
  function calculateLinkOffset(shape) {
    var absolutePoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      x: 0,
      y: 0
    };
    var position = shape.get('position');
    var shapeX = position.x,
      shapeY = position.y;
    var _shape$get = shape.get('size'),
      width = _shape$get.width,
      height = _shape$get.height;
    return {
      dx: absolutePoint.x - shapeX - width / 2,
      dy: absolutePoint.y - shapeY - height / 2
    };
  }
  function getNearestElementIdAndOffset(elementsMap, shape) {
    var offsetX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var offsetY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var shapeId = shape.id;
    if (elementsMap.has(shapeId)) {
      return {
        shapeId: shapeId,
        offsetX: offsetX,
        offsetY: offsetY
      };
    }

    // recursion
    if (shape.parent) {
      return getNearestElementIdAndOffset(elementsMap, shape.parent, offsetX, offsetY);
    }
    return null;
  }

  /**
   * @this {joint.dia.Paper}
   * @param {Object} pattern
   */
  function definePattern(pattern) {
    if (!jointjs.util.isObject(pattern)) {
      throw new TypeError('dia.Paper: definePattern() requires 1. argument to be an object.');
    }

    // Generate a hash code from the stringified filter definition. This gives us
    // a unique filter ID for different definitions.
    var id = pattern.id || pattern.type + this.svg.id + jointjs.util.hashCode(JSON.stringify(pattern));

    // If the pattern already exists in the document,
    // we're done and we can just use it (reference it using `url()`).
    // If not, create one.
    if (this.isDefined(id)) return id;

    // ----------------------------------------------- //

    var d = pattern.d,
      _pattern$backgroundCo = pattern.backgroundColor,
      backgroundColor = _pattern$backgroundCo === void 0 ? '#ffffff' : _pattern$backgroundCo,
      _pattern$color = pattern.color,
      color = _pattern$color === void 0 ? '#000000' : _pattern$color,
      _pattern$strokeWidth = pattern.strokeWidth,
      strokeWidth = _pattern$strokeWidth === void 0 ? 1 : _pattern$strokeWidth,
      _pattern$x = pattern.x,
      x = _pattern$x === void 0 ? 0 : _pattern$x,
      _pattern$y = pattern.y,
      y = _pattern$y === void 0 ? 0 : _pattern$y,
      _pattern$width = pattern.width,
      width = _pattern$width === void 0 ? 10 : _pattern$width,
      _pattern$height = pattern.height,
      height = _pattern$height === void 0 ? 10 : _pattern$height,
      _pattern$patternUnits = pattern.patternUnits,
      patternUnits = _pattern$patternUnits === void 0 ? 'userSpaceOnUse' : _pattern$patternUnits,
      _pattern$strokeOpacit = pattern.strokeOpacity,
      strokeOpacity = _pattern$strokeOpacit === void 0 ? 1 : _pattern$strokeOpacit,
      _pattern$fillOpacity = pattern.fillOpacity,
      fillOpacity = _pattern$fillOpacity === void 0 ? 1 : _pattern$fillOpacity,
      _pattern$rotate = pattern.rotate,
      rotate = _pattern$rotate === void 0 ? 0 : _pattern$rotate,
      _pattern$scale = pattern.scale,
      scale = _pattern$scale === void 0 ? '1 1' : _pattern$scale,
      _pattern$viewBox = pattern.viewBox,
      viewBox = _pattern$viewBox === void 0 ? '0 0 10 10' : _pattern$viewBox;
    if (!d) throw new TypeError('dia.Paper: definePattern() requires "d" attribute not empty.');
    var patternSVGString = "<pattern>\n             <rect\n                width=\"100%\"\n                height=\"100%\"\n                fill-opacity=\"1\"\n                fill=\"".concat(backgroundColor, "\"\n                ></rect>\n            <path\n                d=\"").concat(d, "\"\n                stroke=\"").concat(color, "\"\n                stroke-width=\"").concat(strokeWidth, "\"\n                stroke-opacity=\"").concat(strokeOpacity, "\"\n                fill=\"").concat(color, "\"\n                fill-opacity=\"").concat(fillOpacity, "\"\n                ></path>\n                </pattern>");
    var patternAttrs = jointjs.util.assign({
      id: id,
      patternUnits: patternUnits,
      x: x,
      y: y,
      width: width,
      height: height,
      patternTransform: "rotate(".concat(rotate, ") scale(").concat(scale, ")"),
      viewBox: viewBox
    }, pattern.attrs);

    // "save" for this and later use
    jointjs.V(patternSVGString, patternAttrs).appendTo(this.defs);
    return id;
  }

  /**
   * @this {joint.dia.Paper}
   * @param {Object} gradient
   */
  function defineGradient(gradient) {
    if (!jointjs.util.isObject(gradient)) {
      throw new TypeError('dia.Paper: defineGradient() requires 1. argument to be an object.');
    }

    // Generate a hash code from the stringified filter definition. This gives us
    // a unique filter ID for different definitions.
    var id = gradient.id || gradient.type + this.svg.id + jointjs.util.hashCode(JSON.stringify(gradient));

    // If the gradient already exists in the document,
    // we're done and we can just use it (reference it using `url()`).
    // If not, create one.
    if (this.isDefined(id)) return id;

    // ----------------------------------------------- //

    var type = gradient.type;
    var gradientSVGString;
    var gradientAttrs;
    switch (gradient.type) {
      case 'linearGradient':
      case 'radialGradient':
        var _getGradient = getGradient(gradient, id, type);
        gradientSVGString = _getGradient.gradientSVGString;
        gradientAttrs = _getGradient.gradientAttrs;
        break;
      default:
        debug.log('Unknown Gradient', gradient);
    }

    // "save" for this and later use
    jointjs.V(gradientSVGString, gradientAttrs).appendTo(this.defs);
    return id;
  }
  function getGradient(gradient, id, tag) {
    var stops = gradient.stops,
      _gradient$rotate = gradient.rotate,
      rotate = _gradient$rotate === void 0 ? 0 : _gradient$rotate,
      _gradient$scale = gradient.scale,
      scale = _gradient$scale === void 0 ? '1 1' : _gradient$scale,
      viewBox = gradient.viewBox;
    if (!stops) {
      throw new TypeError('dia.Paper: definePattern() requires "stops" attribute not empty.');
    }
    var gradientSVGString = "<".concat(tag, ">\n                ").concat(toArray(stops).map(function (_ref) {
      var offset = _ref.offset,
        color = _ref.color,
        opacity = _ref.opacity;
      return "\n                    <stop\n                    offset=\"".concat(offset, "\"\n                    stop-color=\"").concat(color, "\"\n                    stop-opacity=\"").concat(opacity, "\"/>");
    }).join(''), "\n                </").concat(tag, ">");
    var gradientAttrs = {
      id: id,
      // gradientUnits,
      // x,
      // y,
      gradientTransform: "rotate(".concat(rotate, ") scale(").concat(scale, ")")
    };
    if (viewBox) {
      gradientAttrs.viewBox = viewBox;
    }
    return {
      gradientSVGString: gradientSVGString,
      gradientAttrs: jointjs.util.assign(gradientAttrs, gradient.attrs)
    };
  }

  function defineFilter(filter) {
    if (!jointjs.util.isObject(filter)) {
      throw new TypeError('dia.Paper: defineFilter() requires 1. argument to be an object.');
    }
    var filterId = filter.id;
    var name = filter.name;
    // Generate a hash code from the stringified filter definition. This gives us
    // a unique filter ID for different definitions.
    if (!filterId) {
      filterId = name + this.svg.id + jointjs.util.hashCode(JSON.stringify(filter));
    }
    // If the filter already exists in the document,
    // we're done and we can just use it (reference it using `url()`).
    // If not, create one.
    if (!this.isDefined(filterId)) {
      var namespace = jointjs.util.filter;
      var filterSVGString = namespace[name] && namespace[name](filter.args || {});
      if (!filterSVGString) {
        throw new Error('Non-existing filter ' + name);
      }

      // Set the filter area to be 3x the bounding box of the cell
      // and center the filter around the cell.
      var filterAttrs = jointjs.util.assign({
        filterUnits: 'userSpaceOnUse'
      }, filter.attrs, {
        id: filterId
      });
      jointjs.V(filterSVGString, filterAttrs).appendTo(this.defs);
    }
    return filterId;
  }

  var VisioElement = jointjs.dia.Element.define('visio.Element',
  //defaults
  {},
  // protoProps
  {},
  // staticProps
  {
    attributes: {
      filter: {
        qualify: jointjs.util.isPlainObject,
        set: function set(filter) {
          return "url(#".concat(defineFilter.call(this.paper, filter), ")");
        }
      },
      fill: {
        qualify: jointjs.util.isPlainObject,
        set: function set(fill) {
          switch (fill.type) {
            case 'linearGradient':
            case 'radialGradient':
              return 'url(#' + defineGradient.call(this.paper, fill) + ')';
            case 'pattern':
              return 'url(#' + definePattern.call(this.paper, fill) + ')';
          }
        }
      }
    }
  });

  var VisioLink = jointjs.dia.Link.define('visio.Link',
  //defaults
  {
    attrs: {
      line: {
        connection: true
      },
      wrapper: {
        connection: true
      }
    }
  },
  // protoProps
  {
    markup: [{
      tagName: 'path',
      selector: 'wrapper',
      attributes: {
        'fill': 'none',
        'cursor': 'pointer',
        'stroke': 'transparent',
        'stroke-linecap': 'round',
        'stroke-linejoin': 'round',
        'stroke-width': 10
      }
    }, {
      tagName: 'path',
      selector: 'line',
      attributes: {
        'fill': 'none',
        'pointer-events': 'none',
        'stroke-linejoin': 'round',
        'stroke-linecap': 'round',
        'stroke': '#333333'
      }
    }]
  },
  // staticProps
  {});

  // Elements

  function defaultImportShape(vsdShape, opts) {
    var attributes = vsdShape.toElementAttributes(opts);
    if (!attributes) {
      return null;
    }
    return new VisioElement(attributes);
  }

  // Links

  function defaultImportConnect(vsdConnect, source, target, opts) {
    var attributes = vsdConnect.toLinkAttributes(source, target);
    if (!attributes) {
      // Fallback
      return defaultImportShape(vsdConnect.getShape(), opts);
    }
    return new VisioLink(attributes);
  }

  // Labels

  function defaultImportLabels(vsdShape, _link) {
    var attributes = vsdShape.toElementAttributes({
      noGeometry: true
    });
    return [new VisioElement(attributes)];
  }

  // Images

  var placeholderBase64 = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mN0qwcAAREAx9X+/mIAAAAASUVORK5CYII=';
  var unsupportedExtensions = ['emf'];
  function defaultImportImage(_vsdShape, element, image) {
    var extension = image.extension,
      base64 = image.base64,
      selector = image.selector;
    var imageAttributes = {};
    var href;
    if (!base64 || unsupportedExtensions.includes(extension)) {
      href = placeholderBase64;
      imageAttributes.preserveAspectRatio = 'none';
    } else {
      href = base64;
    }
    imageAttributes.xlinkHref = href;
    element.attr([selector], imageAttributes);
    return href;
  }

  /*
  parsed item
  {
      "fromSheet": 379,
      "fromCell": "EndX",
      "fromPart": 12,
      "toSheet": 347,
      "toCell": "Connections.Float.X",
      "toPart": 104
  }*/

  var VisioConnect = /*#__PURE__*/function (_VisioObject) {
    _inherits(VisioConnect, _VisioObject);
    var _super = _createSuper(VisioConnect);
    function VisioConnect(init) {
      _classCallCheck(this, VisioConnect);
      return _super.call(this, init, new Set([VisioAttribute.source, VisioAttribute.target]));
    }
    _createClass(VisioConnect, [{
      key: "referencePageContent",
      value: function referencePageContent(pageContent) {
        this.pageContent = pageContent;
      }
    }, {
      key: "getShape",
      value: function getShape() {
        return this.pageContent.getShape(this.shapeId);
      }

      /**
       * @returns {Shape|null}
       */
    }, {
      key: "getSource",
      value: function getSource() {
        var source = this._source;
        if (!source) {
          // Is it a sub-shape which has a connect associated with it
          // If so, the root shape is the source.
          var shape = this.getShape();
          if (shape.isRootShape()) return null;
          return shape.getRootShape();
        }
        return this.pageContent.getShape(source.shapeId);
      }

      /**
       * @returns {Shape|null}
       */
    }, {
      key: "getTarget",
      value: function getTarget() {
        var target = this._target;
        if (!target) return null;
        return this.pageContent.getShape(target.shapeId);
      }

      // getPoint(connect) {
      //     const { cell, part } = connect;

      //     if ((cell === 'PinX' || cell === 'PinY') && part === 3) {
      //         return {
      //             type: 'automatic'
      //         }
      //     }

      //     if (part >= 100) {
      //         const zeroBasedRowId = part - 100;
      //         const oneBasedRowId = zeroBasedRowId + 1;
      //         const checkCellString = `Connections.X${oneBasedRowId}`;

      //         if (cell !== checkCellString) {
      //             logAndThrow('implement connection point');
      //         }

      //         const shape = this.getShape(connect.shapeId);
      //         const partValues = this.getPartFromRow(shape, zeroBasedRowId);
      //         return {
      //             type: 'exact',
      //             x: partValues.x,
      //             y: partValues.y
      //         }
      //     }

      //     logAndThrow('implement connection point');
      // }

      // getPartFromRow(shape, rowIndex) {
      //     const connections = shape.sections.get(VisioSectionType.Connection);
      //     if (!connections || !connections[0]) return { x: 0, y: 0 };
      //     const connectRows = connections.rows;
      //     const row = connectRows.find(row => row.index === rowIndex);
      //     const cells = row.cells;

      //     /*
      //         row cells:
      //             x          // relevant
      //             y          // relevant
      //             dirX       // used during formula evaluation only
      //             dirY       // used during formula evaluation only
      //             type       // used during formula evaluation only
      //             autoGen    // used during formula evaluation only
      //             prompt     // used during formula evaluation only
      //      */

      //     return cells.directValues;
      // }
    }, {
      key: "tooltip",
      get: function get() {
        var shape = this.getShape();
        var string = "connectId: ".concat(shape.id, " (shapeId)\n") + "type: ".concat(shape.type);
        return string;
      }
    }, {
      key: "toLinkAttributes",
      value: function toLinkAttributes(sourceElement, targetElement) {
        var attributes = convertVisioConnectToRappidAttributes(this, sourceElement, targetElement);
        if (!attributes) return null;
        var shape = this.getShape();
        attributes.z = shape.getPageZIndex();
        return attributes;
      }
    }, {
      key: "toLink",
      value: function toLink(elementsMap) {
        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref$importConnect = _ref.importConnect,
          importConnect = _ref$importConnect === void 0 ? defaultImportConnect : _ref$importConnect,
          _ref$ignoreNonPrintin = _ref.ignoreNonPrinting,
          ignoreNonPrinting = _ref$ignoreNonPrintin === void 0 ? true : _ref$ignoreNonPrintin;
        if (typeof importConnect !== 'function') return null;
        var shape = this.getShape();

        // in case entire top level Visio shape is marked as nonPrinting, exit early
        if (ignoreNonPrinting && !shape.isPrintable()) {
          return null;
        }
        var opts = {
          ignoreNonPrinting: ignoreNonPrinting
        };
        var vsdSource = this.getSource();
        var vsdTarget = this.getTarget();
        var source = vsdSource ? getLinkConnectedShapeFromVisioConnect(vsdSource, elementsMap) : null;
        var target = vsdTarget ? getLinkConnectedShapeFromVisioConnect(vsdTarget, elementsMap) : null;
        return importConnect(this, source, target, opts);
      }
    }, {
      key: "toLinkLabels",
      value: function toLinkLabels(link) {
        var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$importLabels = _ref2.importLabels,
          importLabels = _ref2$importLabels === void 0 ? defaultImportLabels : _ref2$importLabels;
        return importLabels(this.getShape(), link);
      }

      // getSourcePart() {
      //     const source = this._source;
      //     if (!source)
      //         return null;
      //
      //     return this.getPart(source);
      // }

      // getTargetPart() {
      //     const target = this._target;
      //     if (!target)
      //         return null;
      //
      //     return this.getPart(target);
      // }

      // /**
      //  * @param {VisioConnect} connect (target or source definition)
      //  * @returns {VisioShapePart|null}
      //  */
      // getPart(connect) {
      //     const code = connect.part;
      //
      //     if (code === -1)
      //         return null;
      //
      //     const shape = this.getShape(connect.shapeId);
      //
      //     if (code >= 100) {
      //         const rowIndex = code - 100;
      //         return this.getPartFromRow(shape, rowIndex);
      //     }
      //
      //     const shapePartEnum = {
      //         0: VisioShapePart.fromNone,
      //         1: VisioShapePart.leftEdge,
      //         2: VisioShapePart.centerEdge,
      //         3: VisioShapePart.rightEdge,
      //         4: VisioShapePart.bottomEdge,
      //         5: VisioShapePart.middleEdge,
      //         6: VisioShapePart.topEdge,
      //         7: VisioShapePart.beginX,
      //         8: VisioShapePart.beginY,
      //         9: VisioShapePart.begin,
      //         10: VisioShapePart.endX,
      //         11: VisioShapePart.endY,
      //         12: VisioShapePart.end,
      //         13: VisioShapePart.fromPin,
      //         14: VisioShapePart.fromAngle,
      //     }[code];
      //
      //     if (!shapePartEnum) {
      //         debugger;
      //         return null;
      //     }
      //
      //     return this.resolvePartEnum(shape, shapePartEnum);
      // }

      // /**
      //  *
      //  * @param {Shape} shape
      //  * @param {VisioShapePart} partEnum
      //  */
      // resolvePartEnum(shape, shapePartEnum) {
      //
      //     switch (shapePartEnum) {
      //         case [VisioShapePart.rightEdge]: // to part
      //
      //         case [VisioShapePart.begin]: // from part
      //
      //         case [VisioShapePart.end]: // from part
      //             debugger;
      //
      //
      //         // not present in fixture vsdx
      //         case [VisioShapePart.fromNone]:
      //         case [VisioShapePart.leftEdge]:
      //         case [VisioShapePart.centerEdge]:
      //         case [VisioShapePart.bottomEdge]:
      //         case [VisioShapePart.middleEdge]:
      //         case [VisioShapePart.topEdge]:
      //         case [VisioShapePart.beginX]:
      //         case [VisioShapePart.beginY]:
      //         case [VisioShapePart.endX]:
      //         case [VisioShapePart.endY]:
      //         case [VisioShapePart.fromPin]:
      //         case [VisioShapePart.fromAngle]:
      //             debugger;
      //             //TODO miky implement
      //             logAndThrow('implement shape part');
      //             return null;
      //     }
      //
      // }
    }]);
    return VisioConnect;
  }(VisioObject);

  // PART
  /*
  Constant                Value
  visConnectFromError     -1
  visFromNone             0
  visLeftEdge             1
  visCenterEdge           2
  visRightEdge            3
  visBottomEdge           4
  visMiddleEdge           5
  visTopEdge              6
  visBeginX               7
  visBeginY               8
  visBegin                9
  visEndX                 10
  visEndY                 11
  visEnd                  12
  visFromPin              13
  visFromAngle            14
  visControlPoint         100 + zero-based row index (for example, visControlPoint = 100 if the control point is in row 0; visControlPoint = 101 if the control point is in row 1)
   */

  /**
   * @this {Visio}
   * @param {Map<number,VisioConnects>} connects
   * @returns {Map<number, Connect>}
   */
  function instantiateConnects(connects) {
    var _this = this;
    var result = new Map();
    connects.forEach(function (connect, shapeId) {
      return result.set(shapeId, new VisioConnect(_objectSpread2({
        archive: _this
      }, connect)));
    });
    return result;
  }

  /**
   * @this {visio}
   * @param {VisioJxon} connectsJxon
   * @param {VisioStructurePath} structurePath
   * @returns {Array<VisioConnects>}
   */
  function parseConnects(connectsJxon, structurePath) {
    var connects = toArray(connectsJxon[VisioJxonShapeKey.Connect]);
    var parsedConnections = connects.map(function (connectJxon) {
      return getRootAttributes(connectJxon, VisioJxonShapeKey.Connect, structurePath);
    });

    /*
    parsed item
    {
        "fromSheet": 379,
        "fromCell": "EndX",
        "fromPart": 12,
        "toSheet": 347,
        "toCell": "Connections.Float.X",
        "toPart": 104
    }*/

    return getJoinedConnections(parsedConnections);
  }

  /**
   * Normalize grouped source, target and connecting shape
   * @param {Array<VisioParsedConnect>} parsedConnections
   * @returns {Map<number, VisioConnects>}
   */
  function getJoinedConnections(parsedConnections) {
    var result = new Map();
    var groupedByConnectShape = getGroupConnections(parsedConnections);
    groupedByConnectShape.forEach(function (_ref, shapeId) {
      var source = _ref.source,
        target = _ref.target;
      result.set(shapeId, {
        shapeId: shapeId,
        source: source || null,
        target: target || null
      });
    });
    return result;
  }

  /**
   * Group source, target and connecting shape
   * @param {Array<VisioParsedConnect>} parsedConnections
   * @returns {
   *      Map<number, {
   *          source: VisioConnect,
   *          target: VisioConnect
   *      }>
   *  }
   */
  function getGroupConnections(parsedConnections) {
    var groupedByConnectShape = new Map();
    parsedConnections.forEach(function (parsedConnection) {
      var connectionShapeId = parsedConnection.fromSheet;
      if (!groupedByConnectShape.has(connectionShapeId)) groupedByConnectShape.set(connectionShapeId, {
        source: null,
        target: null
      });
      var group = groupedByConnectShape.get(connectionShapeId);
      if (isSource(parsedConnection)) {
        if (group.source) {
          debug.log('source already set');
        }
        group.source = {
          shapeId: parsedConnection.toSheet,
          cell: parsedConnection.toCell,
          part: parsedConnection.toPart
        };
      } else {
        if (group.target) {
          debug.log('target already set');
        }
        group.target = {
          shapeId: parsedConnection.toSheet,
          cell: parsedConnection.toCell,
          part: parsedConnection.toPart
        };
      }
    });
    return groupedByConnectShape;
  }

  /**
   * @param parsedConnection
   * @returns {boolean}
   */
  function isSource(parsedConnection) {
    //TODO miky may be not complete
    /*
    source:
        <Connect FromSheet='379' FromCell='BeginX' FromPart='9' ToSheet='200'
                 ToCell='Connections.Bottom.X' ToPart='103'/>
     target:
        <Connect FromSheet='379' FromCell='EndX' FromPart='12' ToSheet='347'
             ToCell='Connections.Float.X' ToPart='104'/>
     */

    // TODO: this doesn't seem to be right, investigate
    return parsedConnection.fromCell === 'BeginX';
  }

  /***
   * API for setting results - same as VisioObject
   */
  var VisioResult = /*#__PURE__*/function () {
    function VisioResult(init) {
      _classCallCheck(this, VisioResult);
      this._attributes = {};
      if (init !== undefined) this.setAttributes(init);
    }
    _createClass(VisioResult, [{
      key: "set",
      value: function set(attributeName, value) {
        // ignore
        if (attributeName === 'archive') return;
        this._attributes[attributeName] = value;
      }
    }, {
      key: "setAttributes",
      value: function setAttributes(init) {
        var _this = this;
        Object.entries(init).forEach(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
            attributeName = _ref2[0],
            value = _ref2[1];
          return _this.set(attributeName, value);
        });
      }
    }, {
      key: "attributes",
      get: function get() {
        return this._attributes;
      }
    }, {
      key: "isDummyResult",
      get: function get() {
        return true;
      }
    }]);
    return VisioResult;
  }();

  // call something on iterator step with safe closing on error
  var callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {
    try {
      return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
    } catch (error) {
      iteratorClose(iterator, 'throw', error);
    }
  };

  var $Array$3 = Array;

  // `Array.from` method implementation
  // https://tc39.es/ecma262/#sec-array.from
  var arrayFrom = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var IS_CONSTRUCTOR = isConstructor(this);
    var argumentsLength = arguments.length;
    var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    if (mapping) mapfn = functionBindContext(mapfn, argumentsLength > 2 ? arguments[2] : undefined);
    var iteratorMethod = getIteratorMethod(O);
    var index = 0;
    var length, result, step, iterator, next, value;
    // if the target is not iterable or it's an array with the default iterator - use a simple case
    if (iteratorMethod && !(this === $Array$3 && isArrayIteratorMethod(iteratorMethod))) {
      iterator = getIterator(O, iteratorMethod);
      next = iterator.next;
      result = IS_CONSTRUCTOR ? new this() : [];
      for (;!(step = functionCall(next, iterator)).done; index++) {
        value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
        createProperty(result, index, value);
      }
    } else {
      length = lengthOfArrayLike(O);
      result = IS_CONSTRUCTOR ? new this(length) : $Array$3(length);
      for (;length > index; index++) {
        value = mapping ? mapfn(O[index], index) : O[index];
        createProperty(result, index, value);
      }
    }
    result.length = index;
    return result;
  };

  var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
    // eslint-disable-next-line es/no-array-from -- required for testing
    Array.from(iterable);
  });

  // `Array.from` method
  // https://tc39.es/ecma262/#sec-array.from
  _export({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {
    from: arrayFrom
  });

  var $trim = stringTrim.trim;


  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  _export({ target: 'String', proto: true, forced: stringTrimForced('trim') }, {
    trim: function trim() {
      return $trim(this);
    }
  });

  /* eslint-disable es/no-array-prototype-indexof -- required for testing */


  var $indexOf = arrayIncludes.indexOf;


  var nativeIndexOf = functionUncurryThis([].indexOf);

  var NEGATIVE_ZERO = !!nativeIndexOf && 1 / nativeIndexOf([1], 1, -0) < 0;
  var STRICT_METHOD$6 = arrayMethodIsStrict('indexOf');

  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  _export({ target: 'Array', proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD$6 }, {
    indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
      var fromIndex = arguments.length > 1 ? arguments[1] : undefined;
      return NEGATIVE_ZERO
        // convert -0 to +0
        ? nativeIndexOf(this, searchElement, fromIndex) || 0
        : $indexOf(this, searchElement, fromIndex);
    }
  });

  // XML to JSON converter. The resulting JSON resembles the JXON format
  // as described here: https://developer.mozilla.org/en-US/docs/JXON.
  // However, this version works with prefixed tags (namespaced tags), preserves
  // casing of attributes and tag names and does not do smart type conversion.

  var CASE_SENSITIVE_NAMESPACES = {
    'http://schemas.iaresearch.com/JCVGantt': true
  };

  /** @enum {number} NodeType */
  var NodeType = {
    ElementNode: 1,
    // An Element node like <p> or <div>.
    TextNode: 3,
    // The actual Text inside an Element or Attr.
    CdataSectionNode: 4,
    // A CDATASection, such as <!CDATA[[ â¦ ]]>.
    ProcessingInstructionNode: 7,
    // A ProcessingInstruction of an XML document, such as <?xml-stylesheet â¦ ?>.
    CommentNode: 8,
    // A Comment node, such as <!-- â¦ -->.
    DocumentNode: 9,
    // A Document node.
    DocumentTypeNode: 10,
    // A DocumentType node, such as <!DOCTYPE html>.
    DocumentFragmentNode: 11 // A DocumentFragment node.
  };

  function parseText(sValue, attribute) {
    var attributeName = attribute && attribute.name;
    var isCaseSensitive = CASE_SENSITIVE_NAMESPACES[attribute && attribute.namespaceURI];
    if (/^(?:true|false)$/i.test(sValue) && attributeName !== 'PlainText' && !isCaseSensitive) {
      return sValue.toLowerCase() === 'true';
    }
    return sValue;
  }
  function isHtmlElement(node) {
    return typeof HTMLHtmlElement !== 'undefined' /* unit tests */ && node.constructor === HTMLHtmlElement;
  }

  /**
   * @param {Node} node
   * @return {Array | *}
   */
  function getAttributes(node) {
    //TODO miky deprecated
    // @see {https://developer.mozilla.org/en-US/docs/Web/API/Node#Obsolete_methods}

    if (node.hasAttributes && node.hasAttributes()) return node.attributes;
    return [];
  }
  function isSimpleValueNode(node) {
    return node.nodeType === NodeType.TextNode || node.nodeType === NodeType.CdataSectionNode;
  }

  /**
   * @constructor
   * @param {Node} parentNode
   * @param {Array.<string>} keepStructureNodeNames
   */
  function JXONKeepStructureTree(parentNode) {
    var _this = this;
    var keepStructureNodeNames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    if (parentNode.hasChildNodes()) {
      this.orderedNodes = Array.from(parentNode.childNodes)
      // filter ignored nodes (eg. comments)
      .filter(function (node) {
        return [NodeType.TextNode, NodeType.CdataSectionNode, NodeType.ElementNode].includes(node.nodeType);
      }).map(function (node) {
        if (isSimpleValueNode(node)) return node.nodeValue;
        {
          // keep as is
          if (isHtmlElement(node)) return node;

          // keep structure JXONKeepStructureTree
          if (keepStructureNodeNames.includes(node.nodeName))
            // recursion
            return new JXONKeepStructureTree(node);

          // standard JXONTree
          var JXON = new JXONTree(node);
          JXON._tagName = node.tagName;
          return JXON;
        }
      });
    }
    getAttributes(parentNode).forEach(function (attribute) {
      return _this['@' + attribute.name] = parseText(attribute.value, attribute);
    });
  }

  /**
   *
   * @param {Node} oXMLParent
   * @param {Array.<string>} [keepStructureNodeNames]
   * @constructor
   */
  function JXONTree(oXMLParent) {
    var keepStructureNodeNames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    if (keepStructureNodeNames.includes(oXMLParent.nodeName)) {
      this[oXMLParent.nodeName] = new JXONKeepStructureTree(oXMLParent, keepStructureNodeNames);
    } else if (oXMLParent.hasChildNodes()) {
      var sCollectedTxt = '';
      for (var oNode, sProp, vContent, nItem = 0; nItem < oXMLParent.childNodes.length; nItem++) {
        oNode = oXMLParent.childNodes.item(nItem);
        if (oNode.nodeType === NodeType.TextNode) sCollectedTxt += oNode.nodeValue.trim();else if (oNode.nodeType === NodeType.CdataSectionNode) sCollectedTxt += oNode.nodeValue;else if (oNode.nodeType === NodeType.ElementNode) {
          sProp = oNode.nodeName;
          if (keepStructureNodeNames.includes(sProp)) {
            // parse the node into array to keep structure
            this[sProp] = new JXONKeepStructureTree(oNode, keepStructureNodeNames);
          } else if (typeof HTMLHtmlElement !== 'undefined' /* unit tests */ && oNode.constructor === HTMLHtmlElement) {
            // use node as is = stop parsing to JXONTree
            this[sProp] = oNode;
          } else {
            vContent = new JXONTree(oNode, keepStructureNodeNames);
            if (this.hasOwnProperty(sProp)) {
              if (this[sProp].constructor !== Array) {
                this[sProp] = [this[sProp]];
              }
              this[sProp].push(vContent);
            } else {
              this[sProp] = vContent;
            }
          }
        }
      }
      if (sCollectedTxt) {
        this.keyValue = parseText(sCollectedTxt);
      }
    }
    if (oXMLParent.hasAttributes && oXMLParent.hasAttributes()) {
      var oAttrib;
      for (var nAttrib = 0; nAttrib < oXMLParent.attributes.length; nAttrib++) {
        oAttrib = oXMLParent.attributes.item(nAttrib);
        this['@' + oAttrib.name] = parseText(oAttrib.value, oAttrib);
      }
    }
  }

  // const coreSchema = {
  //     //TODO visio one
  // };

  // const applicationSchema = {
  //     //TODO visio one
  // };

  // function sortBySchemaSequence(container, siblings, schema) {
  //     var sequence = schema[container.tagName];

  //     return _.sortBy(siblings, (sibling) => {
  //         // attribute - negative - must be resolved as soon as possible
  //         // xmlns definition before its usage
  //         if (sibling.substring(0, 7) === '@xmlns:') return -2;
  //         if (sibling[0] === '@') return -1;

  //         // child
  //         if (!sequence) return 0;
  //         const index = sequence.indexOf(sibling);
  //         // unknown child on the end
  //         if (index === -1) return sequence.length + 1;
  //         // known child by forced sequence
  //         return index;
  //     });
  // }

  function setAttribute(_ref) {
    var oParentEl = _ref.oParentEl,
      knownNameSpaces = _ref.knownNameSpaces,
      slicedSName = _ref.slicedSName,
      vValue = _ref.vValue;
    // non IE solution
    // if (!mm.browser.isIE) {
    //     oParentEl.setAttribute(slicedSName, vValue);
    //     return;
    // }

    var sNameParts = slicedSName.split(':');

    // basic attribute - no special logic
    if (sNameParts.length < 2) {
      oParentEl.setAttribute(slicedSName, vValue);
      return;
    }
    // "else" attribute in format x:y

    // attribute with url value
    //  - do not use immediately
    //  - save between namespaces
    if (String(vValue).match(/^http/)) {
      saveToNameSpaces({
        knownNameSpaces: knownNameSpaces,
        qualifiedName: slicedSName,
        namespaceURI: vValue
      });
    }

    // apply known napespaces
    var namespacePrefix = sNameParts[0];

    // search in xmlns space
    var prefixCandidates = Object.keys(knownNameSpaces)
    // first part is 'xmlns'
    .filter(function (key) {
      return key.split(':')[0] === 'xmlns';
    })
    // use second part
    .map(function (key) {
      return key.split(':')[1];
    }); // checked earlier

    if (namespacePrefix === 'xmlns') {
      oParentEl.setAttributeNS('http://www.w3.org/2000/xmlns/', slicedSName, vValue);
    } else if (prefixCandidates.includes(namespacePrefix)) {
      var namespaceURI = knownNameSpaces['xmlns:' + namespacePrefix];
      var qualifiedName = slicedSName;
      var value = vValue;
      oParentEl.setAttributeNS(namespaceURI, qualifiedName, value);
    } else if (slicedSName === 'r:id') {
      // todo: this is bad, figure out a way to handle these after a POC stage
      // special visio attribute
      oParentEl.setAttribute(slicedSName, vValue);
    }
  }
  function createElementNS(_ref2) {
    var knownNameSpaces = _ref2.knownNameSpaces,
      element = _ref2.element,
      qualifiedName = _ref2.qualifiedName,
      namespaceURI = _ref2.namespaceURI;
    // IE solution
    // if (mm.browser.isIE)
    saveToNameSpaces({
      knownNameSpaces: knownNameSpaces,
      qualifiedName: qualifiedName,
      namespaceURI: namespaceURI
    });
    return element.createElementNS(namespaceURI, qualifiedName);
  }

  /**
   * @param {Object.<qualifiedName, namespaceURI>} knownNameSpaces
   * @param {'xmlns:cor'|string} qualifiedName
   * @param {'http://schemas.mindjet.com/MindManager/Core/2003'|string} namespaceURI
   */
  function saveToNameSpaces(_ref3) {
    var knownNameSpaces = _ref3.knownNameSpaces,
      qualifiedName = _ref3.qualifiedName,
      namespaceURI = _ref3.namespaceURI;
    knownNameSpaces[qualifiedName] = namespaceURI;
  }

  /**
   * Validate and remove parts which shouldn't be exported
   * @param {JXON} oObjTree
   * @return {JXON}
   */
  function validate(oObjTree) {
    return oObjTree;
  }
  function jxon2Xml(oObjTree, oNewDoc, ns) {
    oObjTree = validate(oObjTree);

    // default (by spec) XML namespaces
    // todo: add r namespace, figure out others
    var knownNameSpaces = {
      'xmlns:xs': 'http://www.w3.org/2001/XMLSchema',
      'xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance'
    };
    function loadObjTree(oParentEl, oParentObj) {
      var vValue, oChild;
      if (oParentObj.constructor === String || oParentObj.constructor === Number || oParentObj.constructor === Boolean) {
        oParentEl.appendChild(oNewDoc.createTextNode(oParentObj.toString())); /* verbosity level is 0 or 1 */
        if (oParentObj === oParentObj.valueOf()) {
          return;
        }
      } else if (oParentObj.constructor === Date) {
        oParentEl.appendChild(oNewDoc.createTextNode(oParentObj.toGMTString()));
      }
      // var oParentObjKeys = sortBySchemaSequence(oParentEl, Object.keys(oParentObj), applicationSchema);
      var oParentObjKeys = Object.keys(oParentObj);
      if (oParentObjKeys.indexOf('@N') > 0) {
        oParentObjKeys.splice(oParentObjKeys.indexOf('@N'), 1);
        oParentObjKeys.unshift('@N');
      }
      for (var i = 0, n = oParentObjKeys.length; i < n; i++) {
        var sName = oParentObjKeys[i];
        if (isFinite(sName)) {
          continue;
        } /* verbosity level is 0 */
        vValue = oParentObj[sName];
        if (sName === 'keyValue') {
          if (vValue !== null && vValue !== true) {
            oParentEl.appendChild(oNewDoc.createTextNode(vValue.constructor === Date ? vValue.toGMTString() : String(vValue)));
          }
        } else if (sName === 'keyAttributes') {
          /* verbosity level is 3 */
          for (var sAttrib in vValue) {
            oParentEl.setAttribute(sAttrib, vValue[sAttrib]);
          }
        } else if (sName.charAt(0) === '@') {
          // prevent namespace declaration duplicates
          if (oParentEl.namespaceURI !== vValue) {
            setAttribute({
              oParentEl: oParentEl,
              knownNameSpaces: knownNameSpaces,
              slicedSName: sName.slice(1),
              // without '@'
              vValue: vValue
            });
          }
        } else if (vValue.constructor === HTMLHtmlElement) {
          oParentEl.appendChild(vValue);
        } else if (vValue.constructor === Array) {
          for (var nItem = 0; nItem < vValue.length; nItem++) {
            var namespaceURI = ns[sName.split(':')[0]];
            if (!namespaceURI) {
              namespaceURI = oParentEl.namespaceURI;
            }
            oChild = createElementNS({
              knownNameSpaces: knownNameSpaces,
              element: oNewDoc,
              namespaceURI: namespaceURI,
              qualifiedName: sName
            });
            loadObjTree(oChild, vValue[nItem]);
            oParentEl.appendChild(oChild);
          }
        } else {
          var _namespaceURI = ns[sName.split(':')[0]];
          if (!_namespaceURI) {
            _namespaceURI = oParentEl.namespaceURI;
          }
          oChild = createElementNS({
            knownNameSpaces: knownNameSpaces,
            element: oNewDoc,
            namespaceURI: _namespaceURI,
            qualifiedName: sName
          });
          if (vValue instanceof Object) {
            loadObjTree(oChild, vValue);
          } else if (vValue !== null && vValue !== true) {
            oChild.appendChild(oNewDoc.createTextNode(vValue.toString()));
          }
          oParentEl.appendChild(oChild);
        }
      }
    }

    //var frag = oNewDoc.createDocumentFragment();
    loadObjTree(oNewDoc.documentElement, oObjTree);
    return oNewDoc;
  }
  function emptyJxon(jxon) {
    return Object.keys(jxon).length === 0;
  }

  /**
   * Parse any general VisioJXON
   *  * all root attributes
   *  * parse specific:
   *      * cells
   *      * rows
   *      * sections
   *      * text
   *      * pageSheet
   *      * icon
   *
   *      * foreignData - relation into another xml "rels"
   *      * _rel - relation into another xml "rels"
   *
   * @this {VisioArchive}
   * @throws
   *
   * @param {
   *      VisioShapeJxon|
   *      VisioMasterJXON|
   *      VisioPageSheetJXON|
   *      VisioIconJXON|
   *      VisioJxon
   *      } jxon
   * @param {VisioJxonType} jxonType
   * @param {VisioStructurePath} [structurePathBase]
   * @param {
   *      VisioSectionParsed|
   *      VisioStyleSheet|
   *      VisioDocumentSheetParsed|
   *      VisioPageParsed
   *      } [base]
   *
   * @returns {
   *      VisioSectionParsed|
   *      VisioStyleSheet|
   *      VisioDocumentSheetParsed|
   *      VisioPageParsed|
   *      VisioMaster
   *      }
   */
  function parseJxon(_x, _x2, _x3) {
    return _parseJxon.apply(this, arguments);
  }

  /**
   * @this {Visio}
   * @param {VisioPageSheetJXON} pageSheetJXON
   * @returns {VisioPageSheet}
   */
  function _parseJxon() {
    _parseJxon = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(jxon, jxonType, structurePathBase) {
      var _ref,
        _ref$base,
        _ref$structurePathEnr,
        structurePathEnrichObject,
        structurePath,
        result,
        cellsArrayOfJXONs,
        rowsArrayOfJXONs,
        sectionJxon,
        textJxon,
        relJxon,
        pageSheetJxon,
        iconJxon,
        foreignDataJxon,
        documentSettingsJxon,
        colorsJxon,
        faceNamesJxon,
        styleSheetsJxon,
        documentSheetJxon,
        shapesJxon,
        parsedShapes,
        nonNullParsedShapes,
        shapeJxon,
        _parsedShapes,
        _nonNullParsedShapes,
        connectsJxon,
        _args = arguments;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _ref = _args.length > 3 && _args[3] !== undefined ? _args[3] : {}, _ref$base = _ref.base, _ref$structurePathEnr = _ref.structurePathEnrichObject, structurePathEnrichObject = _ref$structurePathEnr === void 0 ? null : _ref$structurePathEnr;
              if (!jxon || !jxonType || !structurePathBase) debug.log('Missing required param.');
              structurePath = structurePathBase.slice();
              structurePath.push(getStructurePathFragment(jxonType,
              // import syntax
              jxon, structurePath, {
                structurePathEnrichObject: structurePathEnrichObject
              }));

              // common API `set` single attr, `setAttributes` object with multiple records
              result = new VisioResult();
              result.set('jxon', jxon);
              result.setAttributes(getRootAttributes(jxon, jxonType, structurePath));

              //               ,--.,--.
              //   ,---. ,---. |  ||  | ,---.
              //  | .--'| .-. :|  ||  |(  .-'
              //  \ `--.\   --.|  ||  |.-'  `)
              //   `---' `----'`--'`--'`----'
              if (this) {
                cellsArrayOfJXONs = jxon[VisioJxonKey.Cell] || [];
                result.set(VisioAttribute.cells, new VisioCells(_objectSpread2({
                  archive: this,
                  structurePath: structurePath
                }, parseCellsAttributes.call(this, cellsArrayOfJXONs, structurePath))));
              }

              //
              //
              //  ,--.--. ,---. ,--.   ,--. ,---.
              //  |  .--'| .-. ||  |.'.|  |(  .-'
              //  |  |   ' '-' '|   .'.   |.-'  `)
              //  `--'    `---' '--'   '--'`----'
              //
              rowsArrayOfJXONs = jxon[VisioJxonKey.Row];
              if (!rowsArrayOfJXONs) {
                _context.next = 16;
                break;
              }
              _context.t0 = result;
              _context.t1 = VisioAttribute.rows;
              _context.next = 14;
              return parseRows.call(this, rowsArrayOfJXONs, structurePath);
            case 14:
              _context.t2 = _context.sent;
              _context.t0.set.call(_context.t0, _context.t1, _context.t2);
            case 16:
              //
              //                        ,--.  ,--.
              //   ,---.  ,---.  ,---.,-'  '-.`--' ,---. ,--,--,  ,---.
              //  (  .-' | .-. :| .--''-.  .-',--.| .-. ||      \(  .-'
              //  .-'  `)\   --.\ `--.  |  |  |  |' '-' '|  ||  |.-'  `)
              //  `----'  `----' `---'  `--'  `--' `---' `--''--'`----'
              //
              sectionJxon = jxon[VisioJxonKey.Section];
              if (!sectionJxon) {
                _context.next = 24;
                break;
              }
              _context.t3 = result;
              _context.t4 = VisioAttribute.sections;
              _context.next = 22;
              return parseSection.call(this, sectionJxon, structurePath);
            case 22:
              _context.t5 = _context.sent;
              _context.t3.set.call(_context.t3, _context.t4, _context.t5);
            case 24:
              //    ,--.                     ,--.
              //  ,-'  '-. ,---. ,--.  ,--.,-'  '-.
              //  '-.  .-'| .-. : \  `'  / '-.  .-'
              //    |  |  \   --. /  /.  \   |  |
              //    `--'   `----''--'  '--'  `--'
              textJxon = jxon[VisioJxonKey.Text];
              if (textJxon) result.set(VisioAttribute.text, getParsedText.call(this, textJxon, structurePath));

              //                      ,--.
              //        ,--.--. ,---. |  |
              //        |  .--'| .-. :|  |
              //  ,----.|  |   \   --.|  |
              //  '----'`--'    `----'`--'
              relJxon = jxon[VisioJxonKey.Rel];
              if (relJxon) result.set(VisioAttribute._rel, getParsedRel.call(this, relJxon, structurePath));

              //                                ,---.  ,--.                     ,--.
              //   ,---.  ,--,--. ,---.  ,---. '   .-' |  ,---.  ,---.  ,---. ,-'  '-.
              //  | .-. |' ,-.  || .-. || .-. :`.  `-. |  .-.  || .-. :| .-. :'-.  .-'
              //  | '-' '\ '-'  |' '-' '\   --..-'    ||  | |  |\   --.\   --.  |  |
              //  |  |-'  `--`--'.`-  /  `----'`-----' `--' `--' `----' `----'  `--'
              //  `--'           `---'
              pageSheetJxon = jxon[VisioJxonKey.PageSheet];
              if (!pageSheetJxon) {
                _context.next = 36;
                break;
              }
              _context.t6 = result;
              _context.t7 = VisioAttribute.pageSheet;
              _context.next = 34;
              return getParsedPageSheet.call(this, pageSheetJxon, structurePath);
            case 34:
              _context.t8 = _context.sent;
              _context.t6.set.call(_context.t6, _context.t7, _context.t8);
            case 36:
              //  ,--.
              //  `--' ,---. ,---. ,--,--,
              //  ,--.| .--'| .-. ||      \
              //  |  |\ `--.' '-' '|  ||  |
              //  `--' `---' `---' `--''--'
              //
              iconJxon = jxon[VisioJxonKey.Icon];
              if (!iconJxon) {
                _context.next = 44;
                break;
              }
              _context.t9 = result;
              _context.t10 = VisioAttribute.icon;
              _context.next = 42;
              return getParsedIcon.call(this, iconJxon, structurePath);
            case 42:
              _context.t11 = _context.sent;
              _context.t9.set.call(_context.t9, _context.t10, _context.t11);
            case 44:
              //   ,---.                     ,--.               ,------.            ,--.
              //  /  .-' ,---. ,--.--. ,---. `--' ,---. ,--,--, |  .-.  \  ,--,--.,-'  '-. ,--,--.
              //  |  `-,| .-. ||  .--'| .-. :,--.| .-. ||      \|  |  \  :' ,-.  |'-.  .-'' ,-.  |
              //  |  .-'' '-' '|  |   \   --.|  |' '-' '|  ||  ||  '--'  /\ '-'  |  |  |  \ '-'  |
              //  `--'   `---' `--'    `----'`--'.`-  / `--''--'`-------'  `--`--'  `--'   `--`--'
              //                                 `---'
              foreignDataJxon = jxon[VisioJxonKey.ForeignData];
              if (!foreignDataJxon) {
                _context.next = 52;
                break;
              }
              _context.t12 = result;
              _context.t13 = VisioAttribute.foreignData;
              _context.next = 50;
              return parseForeignDataJxon.call(this, foreignDataJxon, structurePath);
            case 50:
              _context.t14 = _context.sent;
              _context.t12.set.call(_context.t12, _context.t13, _context.t14);
            case 52:
              //     ,--.                                                ,--.   ,---.           ,--.    ,--.  ,--.
              //   ,-|  | ,---.  ,---.,--.,--.,--,--,--. ,---. ,--,--, ,-'  '-.'   .-'  ,---. ,-'  '-.,-'  '-.`--',--,--,  ,---.  ,---.
              //  ' .-. || .-. || .--'|  ||  ||        || .-. :|      \'-.  .-'`.  `-. | .-. :'-.  .-''-.  .-',--.|      \| .-. |(  .-'
              //  \ `-' |' '-' '\ `--.'  ''  '|  |  |  |\   --.|  ||  |  |  |  .-'    |\   --.  |  |    |  |  |  ||  ||  |' '-' '.-'  `)
              //   `---'  `---'  `---' `----' `--`--`--' `----'`--''--'  `--'  `-----'  `----'  `--'    `--'  `--'`--''--'.`-  / `----'
              //                                                                                                          `---'
              documentSettingsJxon = jxon[VisioJxonDocumentKey.DocumentSettings];
              if (documentSettingsJxon) result.set(VisioAttribute.documentSettings, parseDocumentSettings.call(this, documentSettingsJxon, structurePath));

              //               ,--.
              //   ,---. ,---. |  | ,---. ,--.--. ,---.
              //  | .--'| .-. ||  || .-. ||  .--'(  .-'
              //  \ `--.' '-' '|  |' '-' '|  |   .-'  `)
              //   `---' `---' `--' `---' `--'   `----'
              colorsJxon = jxon[VisioJxonDocumentKey.Colors];
              if (colorsJxon) result.set(VisioAttribute.colors, parseColors.call(this, colorsJxon, structurePath));

              //   ,---.                     ,--.  ,--.
              //  /  .-' ,--,--. ,---. ,---. |  ,'.|  | ,--,--.,--,--,--. ,---.  ,---.
              //  |  `-,' ,-.  || .--'| .-. :|  |' '  |' ,-.  ||        || .-. :(  .-'
              //  |  .-'\ '-'  |\ `--.\   --.|  | `   |\ '-'  ||  |  |  |\   --..-'  `)
              //  `--'   `--`--' `---' `----'`--'  `--' `--`--'`--`--`--' `----'`----'
              faceNamesJxon = jxon[VisioJxonDocumentKey.FaceNames];
              if (!faceNamesJxon) {
                _context.next = 64;
                break;
              }
              _context.t15 = result;
              _context.t16 = VisioAttribute.faceNames;
              _context.next = 62;
              return parseFaceNames.call(this, faceNamesJxon, structurePath);
            case 62:
              _context.t17 = _context.sent;
              _context.t15.set.call(_context.t15, _context.t16, _context.t17);
            case 64:
              //          ,--.           ,--.        ,---.  ,--.                     ,--.
              //   ,---.,-'  '-.,--. ,--.|  | ,---. '   .-' |  ,---.  ,---.  ,---. ,-'  '-. ,---.
              //  (  .-''-.  .-' \  '  / |  || .-. :`.  `-. |  .-.  || .-. :| .-. :'-.  .-'(  .-'
              //  .-'  `) |  |    \   '  |  |\   --..-'    ||  | |  |\   --.\   --.  |  |  .-'  `)
              //  `----'  `--'  .-'  /   `--' `----'`-----' `--' `--' `----' `----'  `--'  `----'
              //                `---'
              styleSheetsJxon = jxon[VisioJxonDocumentKey.StyleSheets];
              if (!styleSheetsJxon) {
                _context.next = 72;
                break;
              }
              _context.t18 = result;
              _context.t19 = VisioAttribute.styleSheets;
              _context.next = 70;
              return parseStyleSheets.call(this, styleSheetsJxon, structurePath);
            case 70:
              _context.t20 = _context.sent;
              _context.t18.set.call(_context.t18, _context.t19, _context.t20);
            case 72:
              //     ,--.                                                ,--.   ,---.  ,--.                     ,--.
              //   ,-|  | ,---.  ,---.,--.,--.,--,--,--. ,---. ,--,--, ,-'  '-.'   .-' |  ,---.  ,---.  ,---. ,-'  '-.
              //  ' .-. || .-. || .--'|  ||  ||        || .-. :|      \'-.  .-'`.  `-. |  .-.  || .-. :| .-. :'-.  .-'
              //  \ `-' |' '-' '\ `--.'  ''  '|  |  |  |\   --.|  ||  |  |  |  .-'    ||  | |  |\   --.\   --.  |  |
              //   `---'  `---'  `---' `----' `--`--`--' `----'`--''--'  `--'  `-----' `--' `--' `----' `----'  `--'
              documentSheetJxon = jxon[VisioJxonDocumentKey.DocumentSheet];
              if (documentSheetJxon) result.set(VisioAttribute.documentSheet, parseDocumentSheet.call(this, documentSheetJxon, structurePath));

              //         ,--.
              //   ,---. |  ,---.  ,--,--. ,---.  ,---.  ,---.
              //  (  .-' |  .-.  |' ,-.  || .-. || .-. :(  .-'
              //  .-'  `)|  | |  |\ '-'  || '-' '\   --..-'  `)
              //  `----' `--' `--' `--`--'|  |-'  `----'`----'
              //                          `--'
              shapesJxon = jxon[VisioJxonShapeKey.Shapes];
              if (!shapesJxon) {
                _context.next = 82;
                break;
              }
              _context.next = 78;
              return parseShapes.call(this, shapesJxon, structurePath);
            case 78:
              parsedShapes = _context.sent;
              // //TODO miky no nulls in PRODuction
              nonNullParsedShapes = new Map();
              parsedShapes.forEach(function (value, key) {
                if (value !== null) nonNullParsedShapes.set(key, value);else debug.log('Skipped shape === null', {
                  shapesJxon: shapesJxon
                });
              });
              result.set(VisioAttribute.shapes, nonNullParsedShapes);
            case 82:
              //         ,--.
              //   ,---. |  ,---.  ,--,--. ,---.  ,---.
              //  (  .-' |  .-.  |' ,-.  || .-. || .-. :
              //  .-'  `)|  | |  |\ '-'  || '-' '\   --.
              //  `----' `--' `--' `--`--'|  |-'  `----'
              //                          `--'
              shapeJxon = jxon[VisioJxonShapesKey.Shape];
              if (!shapeJxon) {
                _context.next = 90;
                break;
              }
              _context.next = 86;
              return parseShapes.call(this, shapeJxon, structurePath);
            case 86:
              _parsedShapes = _context.sent;
              // //TODO miky no nulls in PRODuction
              _nonNullParsedShapes = new Map();
              _parsedShapes.forEach(function (value, key) {
                if (value !== null) _nonNullParsedShapes.set(key, value);else debug.log('Skipped shape === null', {
                  shapeJxon: shapeJxon
                });
              });
              result.set(VisioAttribute.shape, _nonNullParsedShapes);
            case 90:
              //                                              ,--.
              //   ,---. ,---. ,--,--, ,--,--,  ,---.  ,---.,-'  '-. ,---.
              //  | .--'| .-. ||      \|      \| .-. :| .--''-.  .-'(  .-'
              //  \ `--.' '-' '|  ||  ||  ||  |\   --.\ `--.  |  |  .-'  `)
              //   `---' `---' `--''--'`--''--' `----' `---'  `--'  `----'
              connectsJxon = jxon[VisioJxonShapeKey.Connects];
              if (connectsJxon && !emptyJxon(connectsJxon)) result.set(VisioAttribute.connects, instantiateConnects.call(this, parseConnects.call(this, connectsJxon, structurePath)));

              // just attributes object
              if (!result.isDummyResult) {
                _context.next = 94;
                break;
              }
              return _context.abrupt("return", result.attributes);
            case 94:
              return _context.abrupt("return", result);
            case 95:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));
    return _parseJxon.apply(this, arguments);
  }
  function getParsedPageSheet(_x4, _x5) {
    return _getParsedPageSheet.apply(this, arguments);
  } /**
     * @param {VisioIconJXON} iconJXON
     * @param {VisioStructurePath} structurePath
     * @returns {}
     */
  function _getParsedPageSheet() {
    _getParsedPageSheet = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(pageSheetJXON, structurePath) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", parseJxon.call(this, pageSheetJXON, VisioJxonType.PageSheet, structurePath));
            case 2:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));
    return _getParsedPageSheet.apply(this, arguments);
  }
  function getParsedIcon(_x6, _x7) {
    return _getParsedIcon.apply(this, arguments);
  }

  /**
   * @this {Visio}
   * @param {VisioJxon} foreignDataJxon
   * @returns {VisioStructurePathFragment}
   */
  function _getParsedIcon() {
    _getParsedIcon = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(iconJXON, structurePath) {
      var icon;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:

              // base - probably empty
              _context3.next = 3;
              return parseJxon.call(this, iconJXON, VisioJxonType.Icon, structurePath);
            case 3:
              icon = _context3.sent;
              if (iconJXON.hasOwnProperty(VisioJxonIconKey.Content)) icon[VisioAttribute.base64] = iconJXON[VisioJxonIconKey.Content];
              return _context3.abrupt("return", icon);
            case 6:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));
    return _getParsedIcon.apply(this, arguments);
  }
  function parseForeignDataJxon(_x8, _x9) {
    return _parseForeignDataJxon.apply(this, arguments);
  }
  /***
   * @see 2.2.5.3.2 Row {http://localhost/MS-VSDX.pdf#page=38&zoom=100,92,450}
   *
   * A row specifies a subset of the properties in a section. A row contains cells.
   * Rows are specified by Row_Type child elements of the Section_Type child elements
   * of the ShapeSheet_Type, PageSheet_Type, StyleSheet_Type, and DocumentSheet_Type
   * elements.
   *
   * The N attribute of a Row_Type element specifies the name of the row that
   * identifies the subset of properties that it pertains to. The properties specified by
   * a row are specified by the Cell_Type child elements of the Row_Type element.
   *
   *
   * The following W3C XML Schema ([XMLSCHEMA1] section 2.1) fragment specifies the
   * contents of this complex type.
   *  <xsd:complexType name="SectionDef_Type">
   *      <xsd:sequence>
   *          <xsd:element name="CellDef" type="CellDef_Type" minOccurs="0"
   *              maxOccurs="unbounded"/>
   *          <xsd:element name="RowDef" type="RowDef_Type" minOccurs="0" maxOccurs="1"/>
   *      </xsd:sequence>
   *      <xsd:attribute name="N" type="xsd:string" use="required"/>
   *      <xsd:attribute name="T" type="xsd:string"/>
   *      <xsd:attribute name="S" type="xsd:unsignedByte"/>
   *  </xsd:complexType>
   *
   *
   * Attributes:
   * N: An xsd:string ([XMLSCHEMA2] section 3.2.1) attribute that specifies the
   * language-independent name of a collection of properties. It MUST be unique amongst all
   * the FunctionDef_Type, CellDef_Type, and SectionDef_Type elements in the Web drawing.
   * It MUST NOT be equal to the name of a function token listed in the Function Token
   * Definitions section of this specification. It MUST NOT be equal to the name of
   * a section listed in the Sections section of this specification. It MUST NOT be
   * equal to the name of a cell listed in the Cells section of this specification.
   *
   * T: An xsd:string ([XMLSCHEMA2] section 3.2.1) attribute that specifies the type of
   * rows contained by the SectionDef_Type element.
   * It MUST be equal to a value from following table:
   * /------------------------------------------------------------------------------\
   * |  Value    |  Description                                                     |
   * |------------------------------------------------------------------------------|
   * |  Indexed  |  Specifies the Row_Type elements in the SectionDef_Type element  |
   * |           |  MUST have an IX attribute and no N attribute.                   |
   * |------------------------------------------------------------------------------|
   * |  Named    |  Specifies the Row_Type elements in the SectionDef_Type element  |
   * |           |  MUST have an N attribute and no IX attribute.                   |
   * \------------------------------------------------------------------------------/
   *
   * S: An xsd:unsignedByte ([XMLSCHEMA2] section 3.3.24) attribute that is unused and
   * MUST be ignored.
   *
   */
  /**
   * @this {Visio}
   * @param {Array.<JXONTree>|JXONTree} rowJXONOrArrayOfJXONs
   * @param {VisioStructurePath} structurePath
   * @return {Array}
   */
  function _parseForeignDataJxon() {
    _parseForeignDataJxon = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(foreignDataJxon, structurePath) {
      var foreignData, allRels, jxonType, page, masterId, master, imageRels, rel;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return parseJxon(foreignDataJxon, VisioJxonType.ForeignData, structurePath);
            case 2:
              foreignData = _context4.sent;
              jxonType = structurePath[0].jxonType;
              if (!(jxonType === VisioJxonType.Page)) {
                _context4.next = 11;
                break;
              }
              // shape (root is a page)
              page = this.document.pages.get(structurePath[0].pageId);
              _context4.next = 8;
              return page.getRelsMapCachedAsync();
            case 8:
              allRels = _context4.sent;
              _context4.next = 20;
              break;
            case 11:
              if (!(jxonType === VisioJxonType.Master)) {
                _context4.next = 19;
                break;
              }
              // master (root is master)
              masterId = structurePath[0].masterId;
              master = this.document.masters.get(masterId);
              _context4.next = 16;
              return master.getRelsMapCachedAsync();
            case 16:
              allRels = _context4.sent;
              _context4.next = 20;
              break;
            case 19:
              debug.log('Unhandled ForeignData Type', foreignDataJxon);
            case 20:
              if (allRels.has(VisioJxonType.Image)) {
                _context4.next = 23;
                break;
              }
              debug.log('missing foreign object relation');
              return _context4.abrupt("return", null);
            case 23:
              imageRels = allRels.get(VisioJxonType.Image);
              if (imageRels.has(foreignData._rel)) {
                _context4.next = 27;
                break;
              }
              debug.log('missing foreign object relation');
              return _context4.abrupt("return", null);
            case 27:
              rel = imageRels.get(foreignData._rel); // image requested asynchronously during rendering in Shape.getImage()
              // const image = this.getImageAsync(rel.targetFile.absolutePath);
              return _context4.abrupt("return", rel);
            case 29:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));
    return _parseForeignDataJxon.apply(this, arguments);
  }
  function parseRows(_x10, _x11) {
    return _parseRows.apply(this, arguments);
  }

  /**
   * @this {Visio}
   * @param {VisioRowJXON} rowJxon
   * @param {VisioStructurePath} structurePathBase
   * @returns {VisioRow}
   */
  function _parseRows() {
    _parseRows = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(rowJXONOrArrayOfJXONs, structurePath) {
      var rowArrayOfJXONs, parsedRows, _iterator, _step, rowJxon, parsedRow;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              rowArrayOfJXONs = toArray(rowJXONOrArrayOfJXONs);
              parsedRows = [];
              _iterator = _createForOfIteratorHelper(rowArrayOfJXONs);
              _context5.prev = 3;
              _iterator.s();
            case 5:
              if ((_step = _iterator.n()).done) {
                _context5.next = 13;
                break;
              }
              rowJxon = _step.value;
              _context5.next = 9;
              return parseRow.call(this, rowJxon, structurePath);
            case 9:
              parsedRow = _context5.sent;
              // null for unexpected behavior - no break later
              if (parsedRow !== null) parsedRows.push(parsedRow);
            case 11:
              _context5.next = 5;
              break;
            case 13:
              _context5.next = 18;
              break;
            case 15:
              _context5.prev = 15;
              _context5.t0 = _context5["catch"](3);
              _iterator.e(_context5.t0);
            case 18:
              _context5.prev = 18;
              _iterator.f();
              return _context5.finish(18);
            case 21:
              return _context5.abrupt("return", parsedRows);
            case 22:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this, [[3, 15, 18, 21]]);
    }));
    return _parseRows.apply(this, arguments);
  }
  function parseRow(_x12, _x13) {
    return _parseRow.apply(this, arguments);
  } /**
     * @this {Visio}
     * @param faceNamesJxon
     * @param structurePath
     */
  function _parseRow() {
    _parseRow = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(rowJxon, structurePathBase) {
      var row;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return parseJxon.call(this, rowJxon, VisioJxonType.Row, structurePathBase, {
                type: name
              });
            case 2:
              row = _context6.sent;
              if (!(row.index === undefined && row.name === undefined)) {
                _context6.next = 6;
                break;
              }
              debug.log('row skipped - invalid XML (no required field)', {
                parsedRow: row,
                rowJxon: rowJxon,
                cellsDebug: row.cells ? row.cells.debug : 'no cells'
              });
              return _context6.abrupt("return", null);
            case 6:
              //TODO miky differentiate VisioRowStructureType.Indexed VS VisioRowStructureType.Named
              row.debugType = row.index !== undefined ? VisioRowStructureType.Indexed : VisioRowStructureType.Named;
              return _context6.abrupt("return", row);
            case 8:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));
    return _parseRow.apply(this, arguments);
  }
  function parseFaceNames(_x14, _x15) {
    return _parseFaceNames.apply(this, arguments);
  }

  /**
   * @this {Visio}
   * @param {VisioJxon} styleSheetsJxon
   * @param structurePath
   * @returns {*}
   */
  function _parseFaceNames() {
    _parseFaceNames = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(faceNamesJxon, structurePath) {
      var faceNameJxonArray, faceNames, _iterator2, _step2, faceNameJxon, faceName;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              faceNameJxonArray = toArray(faceNamesJxon.FaceName);
              faceNames = [];
              _iterator2 = _createForOfIteratorHelper(faceNameJxonArray);
              _context7.prev = 3;
              _iterator2.s();
            case 5:
              if ((_step2 = _iterator2.n()).done) {
                _context7.next = 13;
                break;
              }
              faceNameJxon = _step2.value;
              _context7.next = 9;
              return parseJxon.call(this, faceNameJxon, VisioJxonType.FaceName, structurePath);
            case 9:
              faceName = _context7.sent;
              faceNames.push(faceName);
            case 11:
              _context7.next = 5;
              break;
            case 13:
              _context7.next = 18;
              break;
            case 15:
              _context7.prev = 15;
              _context7.t0 = _context7["catch"](3);
              _iterator2.e(_context7.t0);
            case 18:
              _context7.prev = 18;
              _iterator2.f();
              return _context7.finish(18);
            case 21:
              return _context7.abrupt("return", faceNames);
            case 22:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this, [[3, 15, 18, 21]]);
    }));
    return _parseFaceNames.apply(this, arguments);
  }
  function parseStyleSheets(_x16, _x17) {
    return _parseStyleSheets.apply(this, arguments);
  }
  function _parseStyleSheets() {
    _parseStyleSheets = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(styleSheetsJxon, structurePath) {
      var styleSheetJxonsArray, styleSheetsMap, _iterator3, _step3, styleSheetJxon, styleSheet;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              styleSheetJxonsArray = toArray(styleSheetsJxon.StyleSheet);
              styleSheetsMap = new Map();
              _iterator3 = _createForOfIteratorHelper(styleSheetJxonsArray);
              _context8.prev = 3;
              _iterator3.s();
            case 5:
              if ((_step3 = _iterator3.n()).done) {
                _context8.next = 13;
                break;
              }
              styleSheetJxon = _step3.value;
              _context8.next = 9;
              return parseJxon.call(this, styleSheetJxon, VisioJxonType.StyleSheet, structurePath);
            case 9:
              styleSheet = _context8.sent;
              styleSheetsMap.set(styleSheet.id, styleSheet);
            case 11:
              _context8.next = 5;
              break;
            case 13:
              _context8.next = 18;
              break;
            case 15:
              _context8.prev = 15;
              _context8.t0 = _context8["catch"](3);
              _iterator3.e(_context8.t0);
            case 18:
              _context8.prev = 18;
              _iterator3.f();
              return _context8.finish(18);
            case 21:
              return _context8.abrupt("return", styleSheetsMap);
            case 22:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this, [[3, 15, 18, 21]]);
    }));
    return _parseStyleSheets.apply(this, arguments);
  }
  function parseDocumentSheet(_x18, _x19) {
    return _parseDocumentSheet.apply(this, arguments);
  }

  /**
   * @param {VisioSectionJXON|Array.<VisioSectionJXON>} sectionJXONOrArrayOfJXONs
   * @param {VisioStructurePath} structurePath
   * @returns {VisioSectionParsed}
   */
  function _parseDocumentSheet() {
    _parseDocumentSheet = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(documentSheetJxon, structurePath) {
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              return _context9.abrupt("return", parseJxon.call(this, documentSheetJxon, VisioJxonType.DocumentSheet, structurePath));
            case 1:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, this);
    }));
    return _parseDocumentSheet.apply(this, arguments);
  }
  function parseSection(_x20, _x21) {
    return _parseSection.apply(this, arguments);
  }

  /**
   * sections [{geometry: item1}, {geometry: item1}]
   * ==>
   * sections {geometry: [item1, item2]}
   *
   * @param {Array.<VisioSectionParsed>} arrayOfParsedSections
   * @return {VisioSectionParsed}
   */
  function _parseSection() {
    _parseSection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(sectionJXONOrArrayOfJXONs, structurePath) {
      var sectionArrayOfJxons, sectionsArray, _iterator4, _step4, sectionJxon, section, sectionsArrayNonNull;
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              if (!sectionJXONOrArrayOfJXONs) {
                debug.log('Empty section');
              }
              sectionArrayOfJxons = toArray(sectionJXONOrArrayOfJXONs);
              sectionsArray = [];
              _iterator4 = _createForOfIteratorHelper(sectionArrayOfJxons);
              _context10.prev = 4;
              _iterator4.s();
            case 6:
              if ((_step4 = _iterator4.n()).done) {
                _context10.next = 14;
                break;
              }
              sectionJxon = _step4.value;
              _context10.next = 10;
              return parseJxon.call(this, sectionJxon, VisioJxonType.Section, structurePath);
            case 10:
              section = _context10.sent;
              sectionsArray.push(section);
            case 12:
              _context10.next = 6;
              break;
            case 14:
              _context10.next = 19;
              break;
            case 16:
              _context10.prev = 16;
              _context10.t0 = _context10["catch"](4);
              _iterator4.e(_context10.t0);
            case 19:
              _context10.prev = 19;
              _iterator4.f();
              return _context10.finish(19);
            case 22:
              sectionsArrayNonNull = sectionsArray
              //TODO miky debug only - no null values when solution done
              // clean empty items
              .filter(function (sectionsItem) {
                return sectionsItem !== null;
              });
              return _context10.abrupt("return", groupByType.call(this, sectionsArrayNonNull));
            case 24:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10, this, [[4, 16, 19, 22]]);
    }));
    return _parseSection.apply(this, arguments);
  }
  function groupByType(arrayOfParsedSections) {
    var _this = this;
    return arrayOfParsedSections.reduce(function (groupedSections, section) {
      var vsdSection = VisioSection.from(_objectSpread2(_objectSpread2({}, section), {}, {
        archive: _this
      }));
      var type = vsdSection.type;

      // first occurrence
      if (!groupedSections.has(type)) groupedSections.set(type, []);
      // add item
      groupedSections.get(type).push(vsdSection);
      return groupedSections;
    }, new Map());
  }
  var parseShapeJxonAutoincrement = 0;

  /**
   * @this {Visio}
   * @param {VisioShapeJxon|Array.<VisioShapeJxon>} shapesJxon
   * @param {VisioStructurePath} structurePath
   * @returns {Map.<number, VisioParsedShape>}
   */
  function parseShapes(_x22, _x23) {
    return _parseShapes.apply(this, arguments);
  }

  /**
   * @this {Visio}
   * @param {VisioShapeJxon} shapeJxon
   * @param {VisioStructurePath} structurePath
   * @returns {VisioShape | null}
   */
  function _parseShapes() {
    _parseShapes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(shapesJxon, structurePath) {
      var shapesJxonArray, parsedShapesMap, _iterator5, _step5, shapeJxon, parsedShape;
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              if (!shapesJxon || !structurePath) debug.log('Missing required parameter.');

              //TODO miky remove null defaults (deprecated)
              shapesJxonArray = toArray(shapesJxon[VisioJxonShapesKey.Shape]);
              parsedShapesMap = new Map();
              _iterator5 = _createForOfIteratorHelper(shapesJxonArray);
              _context11.prev = 4;
              _iterator5.s();
            case 6:
              if ((_step5 = _iterator5.n()).done) {
                _context11.next = 14;
                break;
              }
              shapeJxon = _step5.value;
              _context11.next = 10;
              return parseShapeJxon.call(this, shapeJxon, structurePath);
            case 10:
              parsedShape = _context11.sent;
              parsedShapesMap.set(parsedShape.id, _objectSpread2({
                structurePath: structurePath
              }, parsedShape));
            case 12:
              _context11.next = 6;
              break;
            case 14:
              _context11.next = 19;
              break;
            case 16:
              _context11.prev = 16;
              _context11.t0 = _context11["catch"](4);
              _iterator5.e(_context11.t0);
            case 19:
              _context11.prev = 19;
              _iterator5.f();
              return _context11.finish(19);
            case 22:
              return _context11.abrupt("return", parsedShapesMap);
            case 23:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11, this, [[4, 16, 19, 22]]);
    }));
    return _parseShapes.apply(this, arguments);
  }
  function parseShapeJxon(_x24, _x25) {
    return _parseShapeJxon.apply(this, arguments);
  }
  function _parseShapeJxon() {
    _parseShapeJxon = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(shapeJxon, structurePath) {
      var shape, type;
      return _regeneratorRuntime().wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              _context12.next = 3;
              return parseJxon.call(this, shapeJxon, VisioJxonType.Shape, structurePath);
            case 3:
              shape = _context12.sent;
              // 4294967295 - highest int32
              // used for del items
              if (shape.id === 4294967295) shape.id = 'deleted-' + parseShapeJxonAutoincrement++;
              shape.structurePath = structurePath;
              type = shape[VisioAttribute.type]; // simple shape
              if (!(type === VisioShapeType.Shape)) {
                _context12.next = 12;
                break;
              }
              assertIsSimpleShapeJxon(shapeJxon);
              shape.debugType = VisioShapeDebugType.ShapeSimple;
              _context12.next = 33;
              break;
            case 12:
              if (!(type === VisioShapeType.Group)) {
                _context12.next = 18;
                break;
              }
              assertIsGroupedShapeJxon(shapeJxon);
              shape.debugType = VisioShapeDebugType.ShapeGroup;
              if (!shape.shapes) {
                debug.log('property shapes undefined');
              }

              // recursion done inside parse jxon
              _context12.next = 33;
              break;
            case 18:
              if (!(type === VisioShapeType.Foreign)) {
                _context12.next = 22;
                break;
              }
              shape.debugType = VisioShapeDebugType.ShapeForeign;
              // all set during parseJxon
              _context12.next = 33;
              break;
            case 22:
              if (!(type === VisioShapeType.Guide)) {
                _context12.next = 27;
                break;
              }
              shape.debugType = VisioShapeDebugType.ShapeGuide;
              debug.log('VisioShapeType.Guide investigate');
              //TODO miky investigate
              _context12.next = 33;
              break;
            case 27:
              if (!(type === undefined && shape.hasOwnProperty(VisioAttribute.deleted))) {
                _context12.next = 31;
                break;
              }
              //assertIsSimpleShapeJxon(shapeJXON);
              shape.debugType = VisioShapeDebugType.ShapeDeleteOverride;
              _context12.next = 33;
              break;
            case 31:
              debug.log("Implement VisioShapeType \"".concat(type, "\""), {
                shape: shapeJxon
              });
              return _context12.abrupt("return", null);
            case 33:
              return _context12.abrupt("return", shape);
            case 34:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12, this);
    }));
    return _parseShapeJxon.apply(this, arguments);
  }

  var _excluded = ["type", "rows", "index", "cells", "jxon", "_prefixList", "_archive"],
    _excluded2 = ["type", "index", "name", "cells", "deleted", "debugType", "jxon"],
    _excluded3 = ["type", "index", "name", "cells", "debugType", "jxon", "_prefixList", "_archive"];
  function mergeSections(masterSections, sections, shape) {
    // clone
    //TODO miky clone deep
    var mergedSections = sectionsDeepClone(masterSections);

    // merge
    // {VisioSectionType} type - (Geometry, Paragraph, Character etc)
    sections.forEach(function (sectionsOfType, type) {
      // not contained in master, just set and return
      if (!mergedSections.get(type)) return mergedSections.set(type, sectionsOfType);
      var masterSectionsOfType = mergedSections.get(type);
      mergedSections.set(type, mergeSectionsOfType(masterSectionsOfType, sectionsOfType, {
        _type: type,
        shape: shape
      }));
    });
    return mergedSections;
  }
  function mergeSectionsOfType(masterSections) {
    var sections = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var _ref = arguments.length > 2 ? arguments[2] : undefined,
      _type = _ref._type,
      shape = _ref.shape;
    sections.forEach(function (section) {
      var index = section.index,
        deleted = section.deleted;
      // index of same row
      var masterSectionIndex = masterSections.findIndex(function (section) {
        return section.index === index;
      });
      if (deleted) {
        masterSections.splice(masterSectionIndex, 1);
      } else if (masterSectionIndex === -1) masterSections.push(section);else mergeSectionOfType(masterSections[masterSectionIndex], section, {
        _type: _type,
        shape: shape
      });
    });
    return masterSections;
  }
  function mergeSectionOfType(masterSection, section) {
    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _type = _ref2._type,
      shape = _ref2.shape;
    if (assertIsSimpleSection(masterSection) !== assertIsSimpleSection(section)) {
      debug.log();
      debug.log('' + 'Indexes are not same');
    }
    var masterRows = masterSection.rows;
    var rows = section.rows;
    assertIsArrayIfDefined(masterRows);
    assertIsArrayIfDefined(rows);
    var result = {
      type: section.type,
      rows: mergeRows(masterRows, rows, {
        _type: _type,
        shape: shape
      })
    };
    if (masterSection.cells || section.cells) result.cells = mergeCells(masterSection.cells, section.cells);
    return result;
  }
  function assertIsArrayIfDefined(array) {
    if (!Array.isArray(array) && array !== undefined) debug.log('Is not array');
  }
  function assertIsSimpleSection(_ref3) {
    var type = _ref3.type,
      rows = _ref3.rows,
      index = _ref3.index,
      cells = _ref3.cells,
      jxon = _ref3.jxon,
      _prefixList = _ref3._prefixList,
      _archive = _ref3._archive,
      rest = _objectWithoutProperties(_ref3, _excluded);
    if (!VisioSectionType.hasOwnProperty(type)) debug.log('Unknown type', type);
    if (!Array.isArray(rows) && rows !== undefined) debug.log('Unexpected row type');
    if (Object.keys(rest).length) debug.log('Unexpected attribute');
    return index;
  }
  function mergeRows(masterRows) {
    var rows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var _ref4 = arguments.length > 2 ? arguments[2] : undefined,
      _type = _ref4._type,
      shape = _ref4.shape;
    rows.forEach(function (row) {
      var index = row.index,
        name = row.name,
        debugType = row.debugType,
        deleted = row.deleted;
      // index of same row
      var masterRowArrayIndex = masterRows.findIndex(function (row) {
        return debugType === VisioRowStructureType.Indexed ? row.index === index : row.name === name;
      });
      var masterRowExists = Boolean(masterRows[masterRowArrayIndex]);
      if (deleted) {
        if (masterRowExists) masterRows.splice(masterRowArrayIndex, 1);
      } else if (masterRowArrayIndex === -1) masterRows.push(row);else masterRows[masterRowArrayIndex] = mergeRow(masterRows[masterRowArrayIndex], row);
    });
    return masterRows;
  }
  function mergeRow(masterRow, row) {
    assertRowsAreSame(masterRow, row);
    var cells = mergeCells(masterRow.cells, row.cells);

    // override structurePath source of truth (directly set has higher priority)
    cells.setRowType(row.type);
    var jxon;
    if (row.jxon) {
      // keep reference
      jxon = row.jxon;
    } else if (masterRow.jxon) ;
    var result = {
      type: row.type,
      debugType: row.debugType,
      jxon: jxon,
      cells: cells
    };

    // one or both
    if (row.name) result.name = masterRow.name;
    if (row.index !== undefined) result.index = masterRow.index;
    return result;
  }
  function assertRowsAreSame(_ref5, _ref6) {
    var typeMaster = _ref5.type,
      indexMaster = _ref5.index,
      nameMaster = _ref5.name,
      cellsMaster = _ref5.cells,
      deletedMaster = _ref5.deleted,
      debugTypeMaster = _ref5.debugType,
      jxonMaster = _ref5.jxon,
      restMaster = _objectWithoutProperties(_ref5, _excluded2);
    var type = _ref6.type,
      index = _ref6.index,
      name = _ref6.name,
      cells = _ref6.cells,
      debugType = _ref6.debugType,
      jxon = _ref6.jxon,
      _prefixList = _ref6._prefixList,
      _archive = _ref6._archive,
      rest = _objectWithoutProperties(_ref6, _excluded3);
    //TODO miky strange deletedMaster, but present in FIGS

    // allowing rewrite EllipticalArcTo to LineTo - strange, but why not...
    // if (typeMaster !== type)
    //     logAndThrow('Rows are different');

    if (debugTypeMaster !== debugType) debug.log('Rows are different');
    if (Object.keys(restMaster).length) debug.log('Unexpected attribute');
    if (Object.keys(rest).length) debug.log('Unexpected attribute');
    if (indexMaster !== index) debug.log('Rows are different');
    if (nameMaster !== name) debug.log('Rows are different');
    if (indexMaster !== undefined && nameMaster !== undefined) {
      debug.log();
      debug.log('Row name and index can\'t be present together.', {
        indexMaster: indexMaster,
        nameMaster: nameMaster
      });
    }
    if (indexMaster === undefined && nameMaster === undefined) debug.log('A missing index and name of the row. One is required.');
  }
  function mergeCells(parentCells, childCells) {
    if (!parentCells) return childCells.clone();
    if (!childCells) return parentCells;
    var childAttributes = childCells.attributesSet;
    childAttributes.forEach(function (attributeName) {
      return parentCells[attributeName] = childCells.get(attributeName);
    });
    return parentCells;
  }
  function sectionsDeepClone(sectionsMap) {
    var clone = new Map();
    sectionsMap.forEach(function (sectionsArray, sectionType) {
      return clone.set(sectionType, sectionsArray.map(cloneSection));
    });
    return clone;
  }

  /**
   * @param {string} type
   * @param {Array<VisioRow>} rows
   * @param {number} index
   * @param {VisioCells} cells
   */
  function cloneSection(_ref7) {
    var type = _ref7.type,
      rows = _ref7.rows,
      index = _ref7.index,
      cells = _ref7.cells;
    var clone = {};

    // primitives
    if (type) clone.type = type;
    if (index !== undefined) clone.index = index;

    // deep clone
    if (rows) clone.rows = rows.map(cloneRow);

    // deep clone
    if (cells) clone.cells = cells.clone();
    return clone;
  }

  /**
   * @param {VisioRowType} [type] - string enum
   * @param {string} [name]
   * @param {VisioRowStructureType} debugType - string enum
   * @param {number} [index]
   * @param {VisioCells} cells
   */
  function cloneRow(_ref8) {
    var type = _ref8.type,
      index = _ref8.index,
      name = _ref8.name,
      cells = _ref8.cells,
      debugType = _ref8.debugType;
    var clone = {};

    // primitives
    if (type) clone.type = type;
    if (name) clone.name = name;
    if (index !== undefined) clone.index = index;
    if (debugType) clone.debugType = debugType;

    // deep clone
    if (cells) clone.cells = cells.clone();
    return clone;
  }

  /**
   */
  function getTextContent(text, sections) {
    if (!text || !text.structure) return undefined;
    var parts = text.structure;
    var contentArray = parts.reduce(function (contentArray, part) {
      var properties = {};
      [{
        parsedIndexName: 'characterPropertiesIndex',
        sectionType: VisioSectionType.Character,
        propertyName: 'characterProperties'
      }, {
        parsedIndexName: 'paragraphPropertiesIndex',
        sectionType: VisioSectionType.Paragraph,
        propertyName: 'paragraphProperties'
      }, {
        parsedIndexName: 'tabsPropertiesIndex',
        sectionType: VisioSectionType.Tabs,
        propertyName: 'tabsProperties'
      }].forEach(function (_ref) {
        var parsedIndexName = _ref.parsedIndexName,
          sectionType = _ref.sectionType,
          propertyName = _ref.propertyName;
        var rowIndex = part[parsedIndexName];
        if (rowIndex === undefined) return;
        var propertiesCells = getPropertiesCells(rowIndex, sections.get(sectionType)[0]);
        if (propertiesCells !== undefined) properties[propertyName] = {
          cells: propertiesCells,
          values: propertiesCells.directValues // no overriding so "direct"
        };
      });

      var content = part.content;
      var contentParts = content.map(function (contentPart) {
        if (typeof contentPart === 'string') return contentPart;
        var fieldIndex = contentPart.fieldIndex;
        var field = sections.get(VisioSectionType.Field)[0];
        var fieldCells = field.rows[fieldIndex].cells;
        if (fieldCells === undefined) {
          debug.log('fieldCells undefined');
        }
        return fieldCells.value;
      });
      contentParts.filter(function (contentPart) {
        return contentPart !== '';
      }).forEach(function (contentPart) {
        contentArray.push(_objectSpread2({
          content: contentPart
        }, properties));
      });
      return contentArray;
    }, []);
    if (contentArray.some(function (item) {
      return item.content === undefined;
    })) {
      debug.log('contentArray some undefined');
    }
    return contentArray;
  }
  function getPropertiesCells(rowIndex, section) {
    var row = section.rows[rowIndex];

    // if (!row){
    //     console.warn('no row found', {rowIndex, section})
    //     return;
    // }

    return row.cells;
  }

  // `Array.prototype.fill` method implementation
  // https://tc39.es/ecma262/#sec-array.prototype.fill
  var arrayFill = function fill(value /* , start = 0, end = @length */) {
    var O = toObject(this);
    var length = lengthOfArrayLike(O);
    var argumentsLength = arguments.length;
    var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
    var end = argumentsLength > 2 ? arguments[2] : undefined;
    var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
    while (endPos > index) O[index++] = value;
    return O;
  };

  // `Array.prototype.fill` method
  // https://tc39.es/ecma262/#sec-array.prototype.fill
  _export({ target: 'Array', proto: true }, {
    fill: arrayFill
  });

  // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
  addToUnscopables('fill');

  /** @enum {string} GradientType */
  var GradientType = {
    linear: 'linear',
    radial: 'radial',
    rectangle: 'rectangle',
    path: 'path'
  };
  function getFillGradient(_ref) {
    var fillGradientDir = _ref.fillGradientDir,
      fillGradientSection = _ref.fillGradientSection,
      fillGradientAngle = _ref.fillGradientAngle;
    var gradient = getFillGradientDefinition(fillGradientDir);
    var stops = getFillGradientStops(fillGradientSection);
    var type;
    switch (gradient.type) {
      case GradientType.linear:
        type = 'linearGradient';
        break;
      default:
      case GradientType.radial:
        type = 'radialGradient';

      //TODO miky implement
      // @see {https://stackoverflow.com/questions/47166364/svg-rectangular-and-path-gradient}
      // case GradientType.rectangle:
      // case GradientType.path:
    }

    var attrs = {};

    // if (fillGradientAngle) {
    //     //TODO miky solve units mismatch
    //     if (fillGradientAngle > 0 && fillGradientAngle < 2 * Math.PI)
    //         fillGradientAngle = 360 - (fillGradientAngle * 180 / Math.PI);
    //     attrs.gradientTransform = `rotate(${fillGradientAngle})`;
    // }

    return {
      type: type,
      stops: stops,
      attrs: attrs
    };
  }

  /** @enum {string} Side */
  var Side = {
    left: 'left',
    right: 'right',
    top: 'top',
    bottom: 'bottom',
    center: 'center'
  };

  /** @enum {string} Base */
  var Base = {
    Shape: 'Shape',
    BoundingBox: 'BoundingBox'
  };
  function getFillGradientDefinition(gradientDir) {
    switch (gradientDir) {
      case 0:
        // Specifies a linear fill color gradient.
        return {
          type: GradientType.linear
        };
      case 1:
        // Specifies the fill color gradient of the shape is in
        // radial mode from the
        // bottom right corner of the shape.
        return {
          type: GradientType.radial,
          base: Base.Shape,
          vertical: Side.bottom,
          horizontal: Side.right
        };
      case 2:
        //Specifies the fill color gradient of the shape is in
        // radial mode from the
        // bottom left corner of the bounding box of the shape.
        return {
          type: GradientType.radial,
          base: Base.Shape,
          vertical: Side.bottom,
          horizontal: Side.left
        };
      case 3:
        //Specifies the fill color gradient of the shape is in
        // radial mode from the
        // center of the shape.
        return {
          type: GradientType.radial,
          base: Base.Shape,
          vertical: Side.center,
          horizontal: Side.center
        };
      case 4:
        //Specifies the fill color gradient of the shape is in
        // radial mode from the
        // center of the bottom edge of the shape.
        return {
          type: GradientType.radial,
          base: Base.Shape,
          vertical: Side.bottom,
          horizontal: Side.center
        };
      case 5:
        //Specifies the fill color gradient of the shape is in
        // radial mode from the
        // center of the top edge of the shape.
        return {
          type: GradientType.radial,
          base: Base.Shape,
          vertical: Side.top,
          horizontal: Side.center
        };
      case 6:
        //Specifies the fill color gradient of the shape is in
        // radial mode from the
        // top right corner of the bounding box of the shape.
        return {
          type: GradientType.radial,
          base: Base.BoundingBox,
          vertical: Side.bottom,
          horizontal: Side.right
        };
      case 7:
        //Specifies the fill color gradient of the shape is in
        // radial mode from the
        // top left corner of the bounding box of the shape.
        return {
          type: GradientType.radial,
          base: Base.BoundingBox,
          vertical: Side.bottom,
          horizontal: Side.right
        };
      case 8:
        //Specifies the fill color gradient of the shape is in
        // rectangle mode from the
        // bottom right corner of the bounding box of the shape.
        return {
          type: GradientType.rectangle,
          base: Base.Shape,
          vertical: Side.bottom,
          horizontal: Side.right
        };
      case 9:
        //Specifies the fill color gradient of the shape is in
        // rectangle mode from the
        // bottom left corner of the bounding box of the shape.
        return {
          type: GradientType.rectangle,
          base: Base.Shape,
          vertical: Side.bottom,
          horizontal: Side.left
        };
      case 10:
        //Specifies the fill color gradient of the shape is in
        // rectangle mode from the
        // center of the shape.
        return {
          type: GradientType.rectangle,
          base: Base.Shape,
          vertical: Side.center,
          horizontal: Side.center
        };
      case 11:
        //Specifies the fill color gradient of the shape is in
        // rectangle mode from the
        // top right corner of the bounding box of the shape.
        return {
          type: GradientType.rectangle,
          base: Base.Shape,
          vertical: Side.top,
          horizontal: Side.right
        };
      case 12:
        //Specifies the fill color gradient of the shape is in
        // rectangle mode from the
        // top left corner of the bounding box of the shape.
        return {
          type: GradientType.rectangle,
          base: Base.Shape,
          vertical: Side.top,
          horizontal: Side.left
        };
      case 13:
        // not in spec (Visio 2013)
        return {
          type: GradientType.path
        };
    }
  }
  function getFillGradientStops(fillGradientSection) {
    var rows = fillGradientSection.rows;
    return rows.map(function (row) {
      return row.cells;
    }).map(function (cells) {
      return {
        offset: cells.gradientStopPosition,
        color: cells.gradientStopColor,
        opacity: 1 - cells.gradientStopColorTrans
      };
    });
  }

  function getFillPattern(patternId, color, backgroundColor) {
    var patternDefinition = getFillPatternDefinition(patternId);

    //TODO miky no missing patterns
    if (!patternDefinition) return color;

    // defaults
    var d = patternDefinition.d,
      _patternDefinition$st = patternDefinition.strokeWidth,
      strokeWidth = _patternDefinition$st === void 0 ? 1 : _patternDefinition$st,
      _patternDefinition$x = patternDefinition.x,
      x = _patternDefinition$x === void 0 ? 0 : _patternDefinition$x,
      _patternDefinition$y = patternDefinition.y,
      y = _patternDefinition$y === void 0 ? 0 : _patternDefinition$y,
      _patternDefinition$wi = patternDefinition.width,
      width = _patternDefinition$wi === void 0 ? 10 : _patternDefinition$wi,
      _patternDefinition$he = patternDefinition.height,
      height = _patternDefinition$he === void 0 ? 10 : _patternDefinition$he,
      _patternDefinition$pa = patternDefinition.patternUnits,
      patternUnits = _patternDefinition$pa === void 0 ? 'userSpaceOnUse' : _patternDefinition$pa,
      _patternDefinition$st2 = patternDefinition.strokeOpacity,
      strokeOpacity = _patternDefinition$st2 === void 0 ? 1 : _patternDefinition$st2,
      _patternDefinition$fi = patternDefinition.fillOpacity,
      fillOpacity = _patternDefinition$fi === void 0 ? 1 : _patternDefinition$fi,
      _patternDefinition$ro = patternDefinition.rotate,
      rotate = _patternDefinition$ro === void 0 ? 0 : _patternDefinition$ro,
      _patternDefinition$vi = patternDefinition.viewBox,
      viewBox = _patternDefinition$vi === void 0 ? undefined : _patternDefinition$vi,
      _patternDefinition$sc = patternDefinition.scale,
      scale = _patternDefinition$sc === void 0 ? '1 1' : _patternDefinition$sc;

    // output format
    var pattern = {
      type: 'pattern',
      color: color,
      backgroundColor: backgroundColor,
      strokeWidth: strokeWidth,
      d: d,
      x: x,
      y: y,
      width: width,
      height: height,
      patternUnits: patternUnits,
      strokeOpacity: strokeOpacity,
      fillOpacity: fillOpacity,
      rotate: rotate,
      scale: scale,
      viewBox: viewBox
    };

    // optional
    if (viewBox) pattern.viewBox = viewBox;
    return pattern;
  }

  /**
   *
   * @param {number} patternId - visio enum
   * @returns {Object}
   */
  function getFillPatternDefinition(patternId) {
    switch (patternId) {
      case 2:
        return {
          d: 'M 2 0 L 2 2',
          rotate: 315,
          width: 4,
          height: 2,
          scale: '1 1'
        };
      case 3:
        // fillPattDef-0-7
        return {
          d: 'M 0 5 L 10 5 M 5 0 L 5 10'
        };
      case 4:
        // fillPattDef-0-8
        return {
          d: 'M 0 0 L 10 10 M 0 10 L 10 0'
        };
      case 5:
        return {
          d: 'M 2 0 L 2 2',
          rotate: 45,
          width: 4,
          height: 2,
          scale: '1 1'
        };
      case 6:
        // fillPattDef-0-10
        return {
          d: 'M 0 5 L 10 5'
        };
      case 7:
        // fillPattDef-0-11
        return {
          d: 'M 5 0 L 5 10'
        };
      case 8:
        //
        return getDefaultFillPatternDefinition(patternId);
      case 9:
        return getDefaultFillPatternDefinition(patternId);
      case 10:
        return getDefaultFillPatternDefinition(patternId);
      case 11:
        // fillPattDef-0-15
        return {
          d: 'M 0 1 L 2 1 M 2 3 L 4 3',
          width: 3,
          height: 3,
          viewBox: '0 0 4 4'
        };
      case 12:
        return getDefaultFillPatternDefinition(patternId);
      case 13:
        // fillPattDef-0-17
        return {
          d: 'M 0 2.5 L 1 2.5',
          width: 1,
          height: 3
        };
      case 14:
        // fillPattDef-0-18
        return {
          d: 'M 2.5 0 L 2.5 1',
          width: 5,
          height: 1
        };
      case 15:
        // fillPattDef-0-19
        return {
          d: 'M 2.5 0 L 2.5 1',
          rotate: 45,
          width: 5,
          height: 1
        };
      case 16:
        // fillPattDef-0-20
        return {
          d: 'M 2.5 0 L 2.5 1',
          rotate: 315,
          width: 5,
          height: 1
        };
      case 17:
        return getDefaultFillPatternDefinition(patternId);
      case 18:
        return getDefaultFillPatternDefinition(patternId);
      case 19:
        // fillPattDef-0-23
        return {
          d: 'M 0 2.5 L 1 2.5',
          width: 1,
          height: 5
        };
      case 20:
        // fillPattDef-0-24
        return {
          d: 'M 2.5 0 L 2.5 1',
          width: 5,
          height: 1
        };
      case 21:
        // fillPattDef-0-25
        return {
          d: 'M 2 0 L 2 2',
          rotate: 45,
          width: 4,
          height: 2
        };
      case 22:
        // fillPattDef-0-26
        return {
          d: 'M 2 0 L 2 2',
          rotate: 315,
          width: 4,
          height: 2
        };
      case 23:
        // fillPattDef-0-27
        return {
          d: 'M 0 2.5 L 5 2.5 M 2.5 0 L 2.5 5',
          width: 5,
          height: 5
        };
      case 24:
        return getDefaultFillPatternDefinition(patternId);
    }
  }
  function getDefaultFillPatternDefinition(patternId) {
    //TODO miky implement all the patterns (non trivial MS server generated)

    var defaultId = 2;
    debug.log("unimplemented fill pattern ".concat(patternId, ", ") + "using pattern ".concat(defaultId, " instead"));
    return getFillPatternDefinition(defaultId);
  }

  function convertVisioGroupToRappidAttributes(group) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$origin = _ref.origin,
      origin = _ref$origin === void 0 ? {
        x: 0,
        y: 0
      } : _ref$origin,
      _ref$prefix = _ref.prefix,
      prefix = _ref$prefix === void 0 ? 'group' : _ref$prefix,
      _ref$isRoot = _ref.isRoot,
      isRoot = _ref$isRoot === void 0 ? false : _ref$isRoot;
    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    // ignore flagged groups from printing
    if (opts.ignoreNonPrinting && !group.isPrintable()) return null;
    var cells = group.cells,
      shapes = group.shapes;
    var width = cells.width,
      height = cells.height,
      locPinX = cells.locPinX,
      locPinY = cells.locPinY,
      pinX = cells.pinX,
      pinY = cells.pinY,
      angle = cells.angle,
      flipX = cells.flipX,
      flipY = cells.flipY;
    var groupAttributes = convertVisioShapeToRappidAttributes(group, {
      origin: {
        x: 0,
        y: height
      },
      prefix: prefix,
      isRoot: isRoot
    }, opts);
    if (!groupAttributes) return null;
    var geometryMarkup = groupAttributes.markup;
    var textMarkup = [];

    // TODO: rappid attributes should return geometry and text separately
    var textIndex = geometryMarkup.findIndex(function (markup) {
      return markup.text;
    });
    if (textIndex > -1) {
      textMarkup.push.apply(textMarkup, _toConsumableArray(geometryMarkup.splice(textIndex, 1)));
    }
    var groupAttrs = groupAttributes.attrs;

    // TODO: look into group level transformations
    // this is unfortunate but for the group level we still have to calculate the group
    // position using the locPins. The reason is that we do not have an organizational
    // group element for locPin, rotation and flipping implemented. It is a bit problematic
    // to get that working as i.e. we can't scale a group if there's text inside.
    var groupPosition = {
      x: origin.x + pinX - locPinX,
      y: origin.y - pinY + locPinY - height
    };
    var groupMatrix = jointjs.V.createSVGMatrix();
    if (angle) {
      groupMatrix = groupMatrix.translate(locPinX, locPinY).rotate(angle).translate(-locPinX, -locPinY);
    }
    if (flipX) {
      groupMatrix = groupMatrix.flipX().translate(-width, 0);
    }
    if (flipY) {
      groupMatrix = groupMatrix.flipY().translate(0, -height);
    }
    var groupSize = {
      width: width,
      height: height
    };
    shapes.forEach(function (shape, index) {
      // TODO: shapes suppose to be filtered already
      if (!shape) return;
      if (opts.ignoreSubShapeConnects && shape.getConnect()) return;
      var groupSelector = "".concat(prefix).concat(index);
      var attributes;
      if (shape.type === 'Group') {
        attributes = convertVisioGroupToRappidAttributes(shape, {
          origin: {
            x: 0,
            y: height
          },
          prefix: "".concat(groupSelector, "-")
        }, opts);
      } else {
        attributes = convertVisioShapeToRappidAttributes(shape, {
          origin: {
            x: 0,
            y: height
          },
          prefix: "".concat(groupSelector, "-")
        }, opts);
      }
      if (!attributes) return;
      var _attributes = attributes,
        markup = _attributes.markup,
        position = _attributes.position,
        attrs = _attributes.attrs;
      geometryMarkup.push({
        tagName: 'g',
        selector: groupSelector,
        children: markup,
        attributes: {
          'transform': jointjs.V.matrixToTransformString(groupMatrix.translate(position.x, position.y))
        }
      });
      if ('root' in attrs) {
        attrs[groupSelector] = attrs.root;
        delete attrs.root;
      }
      jointjs.util.assign(groupAttrs, attrs);
    });
    return {
      markup: [].concat(_toConsumableArray(geometryMarkup), textMarkup),
      attrs: groupAttrs,
      position: groupPosition,
      size: groupSize
    };
  }
  function convertVisioShapeToRappidAttributes(shape) {
    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$origin = _ref2.origin,
      origin = _ref2$origin === void 0 ? {
        x: 0,
        y: 0
      } : _ref2$origin,
      _ref2$prefix = _ref2.prefix,
      prefix = _ref2$prefix === void 0 ? '' : _ref2$prefix,
      _ref2$isRoot = _ref2.isRoot,
      isRoot = _ref2$isRoot === void 0 ? false : _ref2$isRoot;
    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    // ignore flagged shapes from printing
    if (opts.ignoreNonPrinting && !shape.isPrintable()) return null;
    var text = shape.text,
      _shape$cells = shape.cells,
      cells = _shape$cells === void 0 ? /** @type {VisioCells} */{} : _shape$cells,
      foreignData = shape.foreignData;
    var _cells$angle = cells.angle,
      angle = _cells$angle === void 0 ? 0 : _cells$angle,
      _cells$locPinX = cells.locPinX,
      locPinX = _cells$locPinX === void 0 ? 0 : _cells$locPinX,
      _cells$locPinY = cells.locPinY,
      locPinY = _cells$locPinY === void 0 ? 0 : _cells$locPinY,
      pinX = cells.pinX,
      pinY = cells.pinY,
      width = cells.width,
      height = cells.height,
      flipX = cells.flipX,
      flipY = cells.flipY,
      _cells$fillForegnd = cells.fillForegnd,
      fillForegnd = _cells$fillForegnd === void 0 ? 'white' : _cells$fillForegnd,
      _cells$fillBkgnd = cells.fillBkgnd,
      fillBkgnd = _cells$fillBkgnd === void 0 ? '#ff0000' : _cells$fillBkgnd,
      _cells$lineColor = cells.lineColor,
      lineColor = _cells$lineColor === void 0 ? 'black' : _cells$lineColor,
      lineWeight = cells.lineWeight,
      _cells$lineColorTrans = cells.lineColorTrans,
      lineColorTrans = _cells$lineColorTrans === void 0 ? 0 : _cells$lineColorTrans,
      _cells$fillForegndTra = cells.fillForegndTrans,
      fillForegndTrans = _cells$fillForegndTra === void 0 ? 0 : _cells$fillForegndTra,
      _cells$linePattern = cells.linePattern,
      linePattern = _cells$linePattern === void 0 ? 1 : _cells$linePattern,
      _cells$fillPattern = cells.fillPattern,
      fillPattern = _cells$fillPattern === void 0 ? 1 : _cells$fillPattern,
      _cells$fillGradientDi = cells.fillGradientDir,
      fillGradientDir = _cells$fillGradientDi === void 0 ? 0 : _cells$fillGradientDi,
      fillGradientAngle = cells.fillGradientAngle,
      _cells$fillGradientEn = cells.fillGradientEnabled,
      fillGradientEnabled = _cells$fillGradientEn === void 0 ? false : _cells$fillGradientEn;
    var markup = [];
    var attrs = {};
    if (debug.level & debug.TOOLTIPS) {
      attrs.root = {
        title: "".concat(shape.tooltip)
      };
    }

    // position should always point to top-left corner of shape in JointJS coordinate system
    var position = {
      x: origin.x + pinX,
      y: origin.y - height - pinY
    };
    var size = {
      width: width,
      height: height
    };
    var sx = flipX ? -1 : 1,
      sy = flipY ? -1 : 1,
      tx = -locPinX,
      ty = flipY ? -2 * height + locPinY : locPinY,
      ra = sx * sy * angle,
      rx = locPinX,
      ry = height - locPinY;

    // it's a simplified workaround for group level flipping (rotations are not included here)
    // this is something we should think through - how to organize grouped shapes as Visio allows for
    // groups to be organizational level "thing" that does not contain geometry by itself, but has
    // attributes like pins, rotations etc.
    if (isRoot) {
      tx += flipX ? -width + locPinX : locPinX;
      ty -= flipY ? -height + locPinY : locPinY;
    }

    // leaving transformations in a form of variables and joined array as handling the group level
    // transforms described above might require mixing transforms any way
    var scaling = "scale(".concat(sx, ", ").concat(sy, ")");
    var translation = "translate(".concat(tx, ", ").concat(ty, ")");
    var rotation = "rotate(".concat(ra, ", ").concat(rx, ", ").concat(ry, ")");
    var transform = [scaling, translation, rotation].join(' ');
    var geometries = opts.noGeometry ? [] : shape.getComputedGeometry();
    if (geometries.length > 0) {
      var foregroundSelector = "".concat(prefix, "foreground");
      markup.push({
        tagName: 'g',
        selector: foregroundSelector,
        children: getMarkupFromGeometry(geometries, {
          width: width,
          height: height,
          prefix: prefix
        }),
        attributes: {
          'transform': transform,
          'stroke-width': Math.max(lineWeight, 1)
        }
      });
      var foregroundAttrs = attrs[foregroundSelector] = {};
      if (fillPattern === 0) {
        foregroundAttrs.fill = 'none';
      } else if (fillPattern === 1) {
        foregroundAttrs.fill = fillForegnd;
        foregroundAttrs.fillOpacity = 1 - fillForegndTrans;
      } else {
        foregroundAttrs.fill = getFillPattern(fillPattern, fillForegnd, fillBkgnd);
        foregroundAttrs.fillOpacity = 1 - fillForegndTrans;
      }
      if (fillGradientEnabled) {
        foregroundAttrs.fillOpacity = 1 - fillForegndTrans;
        var fillGradientSection = shape.getComputedSection(VisioSectionType.FillGradient);
        if (fillGradientSection) {
          foregroundAttrs.fill = getFillGradient({
            fillGradientAngle: fillGradientAngle,
            fillGradientDir: fillGradientDir,
            fillGradientSection: fillGradientSection,
            fillBkgnd: fillBkgnd
          });
        }
      }
      if (linePattern > 0) {
        foregroundAttrs.stroke = lineColor;
        foregroundAttrs.strokeOpacity = 1 - lineColorTrans;
        foregroundAttrs.strokeDasharray = getLinePatternStrokeDasharray(linePattern);
      } else {
        foregroundAttrs.stroke = 'none';
      }
      if (shape.isOneDimensional()) jointjs.util.assign(foregroundAttrs, getArrows(cells));
      var shapeShdwType = cells.shapeShdwType,
        shapeShdwOffsetX = cells.shapeShdwOffsetX,
        shapeShdwOffsetY = cells.shapeShdwOffsetY,
        _cells$shapeShdwBlur = cells.shapeShdwBlur,
        shapeShdwBlur = _cells$shapeShdwBlur === void 0 ? 0 : _cells$shapeShdwBlur,
        _cells$shdwForegnd = cells.shdwForegnd,
        shdwForegnd = _cells$shdwForegnd === void 0 ? '#000' : _cells$shdwForegnd,
        _cells$shdwForegndTra = cells.shdwForegndTrans,
        shdwForegndTrans = _cells$shdwForegndTra === void 0 ? 0 : _cells$shdwForegndTra;
      if (shapeShdwType) {
        foregroundAttrs.filter = {
          name: 'dropShadow',
          args: {
            dx: shapeShdwOffsetX,
            dy: -shapeShdwOffsetY,
            color: shdwForegnd,
            opacity: 1 - shdwForegndTrans,
            blur: shapeShdwBlur
          }
        };
      }
    }
    if (foreignData) {
      var imageSelector = "".concat(prefix, "image");
      var imageGroupSelector = "image".concat(foreignData.id);
      var imageMarkup = {
        tagName: 'image',
        selector: imageSelector,
        groupSelector: imageGroupSelector,
        attributes: {
          x: -width / 2,
          y: height / 2,
          'width': width,
          'height': height
        }
      };
      markup.push(imageMarkup);
    }
    if (text && text.length) enrichShapeTextAttributes(shape, {
      // read write
      markup: markup,
      attrs: attrs,
      // read only
      prefix: prefix,
      isRootGroupText: isRoot
    });
    var result = {
      markup: markup,
      attrs: attrs,
      position: position,
      size: size
    };

    // links
    if (shape.cells.objType === 2) {
      jointjs.util.setByPath(result, ['attrs', 'foreground', 'fill'], 'none');
    }
    return result;
  }
  function getMarkupFromGeometry(geometries, _ref3) {
    var width = _ref3.width,
      height = _ref3.height,
      _ref3$prefix = _ref3.prefix,
      prefix = _ref3$prefix === void 0 ? '' : _ref3$prefix;
    // geometry != Visio shape. Single Visio shape may consist of multiple geometries (i.e. line with arrow-heads)
    return geometries
    // considered a JointJS shape
    .map(function (geometry, index) {
      // single geometry
      var attributes = {
        'd': geometry.toPath(width, height).toString(),
        'stroke-linecap': 'round',
        'stroke-linejoin': 'round'
      };
      var _geometry$cells = geometry.cells,
        cells = _geometry$cells === void 0 ? {} : _geometry$cells;
      if (cells.noFill) {
        attributes.fill = 'none';
      }
      if (cells.noLine) {
        attributes.stroke = 'none';
      }
      if (cells.noShow) {
        attributes.visibility = 'hidden';
      }
      return {
        tagName: 'path',
        selector: "".concat(prefix, "geometry-").concat(index),
        attributes: attributes
      };
    });
  }

  var _excluded$1 = ["shapes"];
  var autoincrement = 0;
  var VisioShape = /*#__PURE__*/function (_VisioSheetObject) {
    _inherits(VisioShape, _VisioSheetObject);
    var _super = _createSuper(VisioShape);
    function VisioShape(_ref) {
      var _this;
      var shapes = _ref.shapes,
        init = _objectWithoutProperties(_ref, _excluded$1);
      _classCallCheck(this, VisioShape);
      if (!init.type && init.deleted !== true) {
        debug.log('Missing type, could not instantiate a VisioShape.');
      }
      _this = _super.call(this, init, new Set([VisioAttribute.name, VisioAttribute.type, VisioAttribute.cells, VisioAttribute.sections, VisioAttribute.master, VisioAttribute.shapes, VisioAttribute.textStyle]));
      if (_this.masterId !== undefined) {
        _this._master = _this.masters.get(_this.masterId);
      }
      if (shapes) {
        _this.initShapes(shapes);
      }
      _this.pageContent.referenceShape(_assertThisInitialized(_this));
      return _this;
    }
    _createClass(VisioShape, [{
      key: "getDefaultAttributes",
      value: function getDefaultAttributes() {
        return _objectSpread2(_objectSpread2({}, _get(_getPrototypeOf(VisioShape.prototype), "getDefaultAttributes", this).call(this)), {}, {
          name: null,
          type: null,
          cells: null,
          sections: new Map(),
          shapes: [],
          // subShapes
          pageContent: null
        });
      }
    }, {
      key: "initShapes",
      value: function initShapes(shapes) {
        var master = this._master;
        var parentMaster = this.masters && this.masters.get(this.parentMasterId);

        // custom shape without reference to master
        if (!master && !parentMaster) {
          this.shapes = this.instantiateShapes(shapes);
          return;
        }

        // root shape with reference to master
        if (master) {
          this.shapes = this.traverseShapes(shapes, master.masterShapes);
          return;
        }

        // child shape (or dummy shape)
        if (parentMaster) {
          var masterShape = parentMaster.masterShapesMap.get(this.masterShapeId);
          this.shapes = this.traverseShapes(shapes, masterShape.masterShapes);
        }
      }

      /**
       * recursion
       * @param {Map<number, VisioShape>} shapes
       * @param {Map<number, MasterShape>} masterShapes
       * @return {Map<number|string, VisioShape>}
       */
    }, {
      key: "traverseShapes",
      value: function traverseShapes(shapes) {
        var _this2 = this;
        var masterShapes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Map();
        var masterId = this.masterId !== undefined ? this.masterId : this.parentMasterId;
        var shapesByMasterShapeId = this.shapesByMasterShapeId(shapes);
        var groupOrderCounter = 0;
        var shapesResult = new Map();
        masterShapes.forEach(function (masterShape, masterShapeId) {
          var shape = shapesByMasterShapeId.get(masterShapeId);
          if (!shape) shape = {
            id: 'dummy-' + autoincrement++,
            type: masterShape.type
          };
          if (shape.deleted) return;
          shapesResult.set(shape.id, _this2.factory(_objectSpread2({
            masterShape: masterShape,
            parentMasterId: masterId,
            xmlGroupOrder: groupOrderCounter++
          }, shape)));
        });
        return shapesResult;
      }

      /**
       * Create subshape instance
       * @param init
       * @returns {Shape}
       */
    }, {
      key: "factory",
      value: function factory(init) {
        return new VisioShape(_objectSpread2({
          archive: this.archive,
          parent: this,
          pageContent: this.pageContent,
          masters: this.masters
        }, init));
      }
    }, {
      key: "getRootShape",
      value: function getRootShape() {
        var root = this;
        var parent = root.parent;
        while (parent) {
          root = parent;
          parent = root.parent;
        }
        return root;
      }
    }, {
      key: "isRootShape",
      value: function isRootShape() {
        return !this.parent;
      }
    }, {
      key: "shapesByMasterShapeId",
      value: function shapesByMasterShapeId(shapes) {
        var shapesByMasterShapeId = new Map();
        shapes.forEach(function (shape) {
          if (!shape.masterShapeId) {
            debug.log('masterShapeId undefined');
          }
          shapesByMasterShapeId.set(shape.masterShapeId, shape);
        });
        return shapesByMasterShapeId;
      }
    }, {
      key: "getComputedForeignData",
      value: function getComputedForeignData() {
        var foreignData = this.foreignData,
          masterShape = this.masterShape;
        if (foreignData) return foreignData;
        if (masterShape && masterShape.foreignData) return masterShape.foreignData;
        return null;
      }
    }, {
      key: "hasImage",
      value: function hasImage() {
        return Boolean(this.getComputedForeignData());
      }
    }, {
      key: "getImage",
      value: function () {
        var _getImage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          var foreignData, targetFile, id, image;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  foreignData = this.getComputedForeignData();
                  if (foreignData) {
                    _context.next = 3;
                    break;
                  }
                  return _context.abrupt("return", null);
                case 3:
                  targetFile = foreignData.targetFile, id = foreignData.id;
                  _context.next = 6;
                  return this.archive.getImageAsync(targetFile.absolutePath);
                case 6:
                  image = _context.sent;
                  return _context.abrupt("return", _objectSpread2(_objectSpread2({}, image), {}, {
                    selector: "image".concat(id)
                  }));
                case 8:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));
        function getImage() {
          return _getImage.apply(this, arguments);
        }
        return getImage;
      }()
    }, {
      key: "referenceMasters",
      value: function referenceMasters() {
        // if (!this.structurePath)
        //     logAndThrow('no structure path in shape');

        var masterId = this.masterId !== undefined ? this.masterId : this.parentMasterId;
        if (masterId === undefined) return;
        var masters = this.archive.document.masters;
        this.master = masters.get(masterId);
        if (this.masterShapeId) {
          var masterShapesMap = this.master.masterShapesMap;
          this._masterShape = masterShapesMap.get(this.masterShapeId);
        } else {
          this._masterSubShape = masters.getSubShape(masterId);
        }
      }

      /**
       * @returns {MasterShape|Master}
       */
    }, {
      key: "masterShape",
      get: function get() {
        return this._masterShape || this._master;
      },
      set: function set(masterShape) {
        this._masterShape = masterShape;
      }

      /**
       * Converts anonymous objects into instances of VisioShape
       * - works recursively
       */
    }, {
      key: "instantiateShapes",
      value: function instantiateShapes(shapes) {
        var _this3 = this;
        var parentMasterId = this.masterId !== undefined ? this.masterId : this.parentMasterId;
        var instantiatedShapesMap = new Map();
        shapes.forEach(function (parsedShape, id) {
          return instantiatedShapesMap.set(id, _this3.factory(_objectSpread2({
            parentMasterId: parentMasterId
          }, parsedShape)));
        });
        return instantiatedShapesMap;
      }
    }, {
      key: "x",
      get: function get() {
        return this.cells.pinX - this.cells.locPinX;
      }
    }, {
      key: "y",
      get: function get() {
        return this.cells.pinY - this.cells.locPinY;
      }
    }, {
      key: "angle",
      get: function get() {
        return this.cells.angle;
      }
    }, {
      key: "height",
      get: function get() {
        return this.cells.height;
      }
    }, {
      key: "width",
      get: function get() {
        return this.cells.width;
      }
    }, {
      key: "matrix",
      get: function get() {
        var x = this.x,
          y = this.y,
          angle = this.angle;
        var matrix = jointjs.V.createSVGMatrix().translate(x, y);
        if (angle) {
          matrix = matrix.rotate(angle);
        }
        // const { flipX, flipY } = this.cells;
        // if (flipX) {
        //     matrix = matrix.flipX();
        // }
        // if (flipY) {
        //     matrix = matrix.flipY();
        // }
        return matrix;
      }
    }, {
      key: "getPageMatrix",
      value: function getPageMatrix() {
        var matrix = jointjs.V.createSVGMatrix();
        [].concat(_toConsumableArray(this.getAncestorShapes()), [this]).forEach(function (shape) {
          matrix = matrix.multiply(shape.matrix);
        });
        return matrix;
      }
    }, {
      key: "getPageOrigin",
      value: function getPageOrigin() {
        var parent = this.parent,
          pageContent = this.pageContent;
        var origin = new jointjs.g.Point(0, pageContent.page.height);
        if (parent) {
          var matrix = parent.getPageMatrix();
          origin.offset(matrix.e, -matrix.f);
        }
        return origin;
      }
    }, {
      key: "getPageZIndex",
      value: function getPageZIndex() {
        return this.getRootShape().xmlOrder;
      }
    }, {
      key: "getPageAngle",
      value: function getPageAngle() {
        return this.getAncestorShapes().reduce(function (angle, shape) {
          return angle + shape.angle;
        }, this.angle);
      }
    }, {
      key: "getPagePosition",
      value: function getPagePosition() {
        // width & height can have negative values and affect the position
        return this.getPageBBox().origin();
      }
    }, {
      key: "getPageBBox",
      value: function getPageBBox() {
        var matrix = this.getPageMatrix();
        var width = this.width,
          height = this.height,
          pageContent = this.pageContent;
        var x = matrix.e;
        var y = pageContent.page.height - matrix.f - height;
        // `width`, `height` can be negative for connect shapes
        return new jointjs.g.Rect(x, y, width, height).normalize();
      }
    }, {
      key: "name",
      get: function get() {
        var name = this.archive.document.languageDependent ? this._name : this.nameU;
        return typeof name === 'string' ? name : null;
      }
    }, {
      key: "type",
      get: function get() {
        return this._type;
      },
      set: function set(type) {
        this._type = type;
      }
    }, {
      key: "cells",
      get: function get() {
        if (!this._cells) {
          var masterShape = this.masterShape;
          if (masterShape && masterShape.cells) return masterShape.cells;
        }
        return this._cells;
      },
      set: function set(cells) {
        this._cells = cells;
      }

      /**
       * @returns {Map<VisioSectionType, (VisioIndexedSection|VisioNamedSection)[]>|undefined}
       */
    }, {
      key: "sections",
      get: function get() {
        if (!this._cachedSections) {
          this.cacheSections();
        }
        return this._cachedSections;
      },
      set: function set(sections) {
        this._sections = sections;
      }
    }, {
      key: "cacheSections",
      value: function cacheSections() {
        var _this4 = this;
        var vsdSectionMap = new Map();
        this.mergeSections().forEach(function (section, name) {
          var vsdSections = section.map(function (sectionEntry) {
            var vsdSection = VisioSection.from(_objectSpread2(_objectSpread2({}, sectionEntry), {}, {
              archive: _this4.archive
            }));
            if (_this4._sections.has(name)) {
              vsdSection.jxon = _this4._sections.get(name)[0].jxon;
            }
            return vsdSection;
          });
          vsdSectionMap.set(name, vsdSections);
        });
        this._cachedSections = vsdSectionMap;
      }

      /**
       * @returns {Map<VisioSectionType, [VisioSectionParsed]>|undefined}
       */
    }, {
      key: "mergeSections",
      value: function mergeSections$1() {
        var defaultSections = this.getDefaultSections();
        var hasSections = Boolean(this._sections);
        var hasMasterWithSections = Boolean(this.masterShape && this.masterShape.sections);

        // no sections at all
        if (!hasSections && !hasMasterWithSections) {
          return defaultSections;
        }

        // no master sections
        if (hasSections && !hasMasterWithSections) {
          return mergeSections(defaultSections, this._sections, this);
        }

        // only master sections
        if (!hasSections && hasMasterWithSections) {
          return mergeSections(defaultSections, this.masterShape.sections, this);
        }

        // merge
        var sections = this._sections;
        var masterSections = this.masterShape.sections;
        var mergedDefaultAndMasterSections = mergeSections(defaultSections, masterSections, this);
        //TODO no need to clone again (inside mergeSections)
        var mergedSections = mergeSections(mergedDefaultAndMasterSections, sections, this);
        return mergedSections;
      }
    }, {
      key: "shapes",
      get: function get() {
        return this._shapes;
      },
      set: function set(shapes) {
        this._shapes = shapes;
      }
    }, {
      key: "text",
      get: function get() {
        // no content (null by calculateTextContent)
        if (this._cachedText === null) return undefined;
        if (!this._cachedText) this._cachedText = this.calculateTextContent();
        return this._cachedText;
      },
      set: function set(text) {
        this._text = text;
      }
    }, {
      key: "getSubShapes",
      value: function getSubShapes() {
        return _toConsumableArray(this._shapes.values());
      }
    }, {
      key: "getAncestorShapes",
      value: function getAncestorShapes() {
        var ancestors = [];
        var parent = this.parent;
        while (parent) {
          ancestors.unshift(parent);
          parent = parent.parent;
        }
        return ancestors;
      }
    }, {
      key: "getSectionNames",
      value: function getSectionNames() {
        return _toConsumableArray(this.sections.keys());
      }
    }, {
      key: "getOwnSectionNames",
      value: function getOwnSectionNames() {
        return _toConsumableArray(this._sections.keys());
      }

      // return own section
    }, {
      key: "getSection",
      value: function getSection(name) {
        if (name === VisioSectionType.Geometry) {
          throw new Error('Use getGeometry instead.');
        }
        if (!VisioSectionType[name]) {
          throw new Error("Wrong section name: ".concat(name));
        }
        var sections = this._sections.get(name);
        if (!Array.isArray(sections) || sections.length === 0) return null;
        return sections[0];
      }

      // return merged section
    }, {
      key: "getComputedSection",
      value: function getComputedSection(name) {
        if (name === VisioSectionType.Geometry) {
          throw new Error('Use getGeometry instead.');
        }
        if (!VisioSectionType[name]) {
          throw new Error("Wrong section name: ".concat(name));
        }
        var sections = this.sections.get(name);
        if (!Array.isArray(sections) || sections.length === 0) return null;
        return sections[0];
      }

      // return own geometry
    }, {
      key: "getGeometry",
      value: function getGeometry() {
        var geometryArray = this._sections.get(VisioSectionType.Geometry);
        if (!geometryArray) return [];
        return geometryArray;
      }

      // return merged geometry
    }, {
      key: "getComputedGeometry",
      value: function getComputedGeometry() {
        var geometryArray = this.sections.get(VisioSectionType.Geometry);
        if (!geometryArray) return [];
        return geometryArray;
      }

      // add own section
    }, {
      key: "addSection",
      value: function addSection(name) {
        var _sectionJxon;
        var sectionStructureType = VisioSectionStructureType[name];
        if (sectionStructureType === undefined) {
          debug.log("Unhandled section name: ".concat(name));
          return null;
        }

        // own section exists, disallow duplicates and return existing section
        if (this.getSection(name) && sectionStructureType !== VisioSectionStructureType.Geometry) {
          debug.log("Can not add a section \"".concat(name, "\" as it already exists."));
          return this.getSection(name);
        }
        var sectionJxon = (_sectionJxon = {}, _defineProperty(_sectionJxon, VisioJxonSectionKey.Name, name), _defineProperty(_sectionJxon, "Row", []), _sectionJxon);
        var section = VisioSection.from({
          type: name,
          jxon: sectionJxon,
          archive: this.archive
        });
        if (name === VisioSectionType.Geometry) {
          var geometryArray = this.getComputedGeometry();

          // ensure proper indexing
          var lastIndex = geometryArray.map(function (section) {
            return section.index;
          }).sort().pop();
          section.index = Number.isInteger(lastIndex) ? lastIndex + 1 : 0;
          this._sections.set(name, [].concat(_toConsumableArray(geometryArray), [section]));
          sectionJxon[VisioJxonSectionKey.Id] = section.index.toString();
        } else {
          this._sections.set(name, [section]);
        }
        this.jxon.Section.push(sectionJxon);
        this.cacheSections();
        return section;
      }
    }, {
      key: "removeSection",
      value: function removeSection(name) {
        var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var sectionStructureType = VisioSectionStructureType[name];
        if (sectionStructureType === undefined) {
          return;
        }
        if (sectionStructureType === VisioRowStructureType.Named) {
          // remove from struct
          this.sections["delete"](name);

          // remove from jxon
          var toRemoveIndex = this.jxon.Section.findIndex(function (section) {
            return section[VisioJxonSectionKey.Name] === name;
          });
          if (this.jxon.Section[toRemoveIndex]) {
            this.jxon.Section.splice(toRemoveIndex, 1);
          }
        } else {
          if (!Number.isInteger(index)) {
            throw new Error('Index has to be an integer.');
          }
          var sections = this.sections.get(name) || [];
          if (Array.isArray(sections) && !sections[index]) {
            throw new Error('Index out of range.');
          }

          // remove from struct
          sections.splice(index, 1);
          this.sections.set(name, sections);

          // remove from jxon
          var _toRemoveIndex = this.jxon.Section.findIndex(function (section) {
            return section[VisioJxonSectionKey.Name] === name && section[VisioJxonSectionKey.Id] === index.toString();
          });
          if (this.jxon.Section[_toRemoveIndex]) {
            this.jxon.Section.splice(_toRemoveIndex, 1);
          }
        }
      }
    }, {
      key: "getText",
      value: function getText() {
        var text = this.text;
        if (!Array.isArray(text) || text.length === 0) return '';
        return text[0].content.trim();
      }

      // todo: very simplified way of doing it, enhance
    }, {
      key: "setText",
      value: function setText(text) {
        if (text && text.length > 0) {
          this.text = [{
            content: text
          }];
          this.jxon.Text = [{
            cp: {
              '@IX': '0'
            }
          }, text];
        }
      }
    }, {
      key: "calculateTextContent",
      value: function calculateTextContent() {
        var sections = this.sections;

        // even empty text override master
        var shapeTextContent = getTextContent(this._text, sections);
        if (shapeTextContent) return shapeTextContent;
        var masterShape = this.masterShape;
        if (masterShape) return getTextContent(masterShape.text, sections);

        // no content
        return null;
      }
    }, {
      key: "getDefaultSections",
      value: function getDefaultSections() {
        var textStyleSheetIndex = this.textStyle;
        var styleSheets = this.archive.document.styleSheets;
        var styleSheet = styleSheets.get(textStyleSheetIndex);
        if (styleSheet === undefined) {
          debug.log('styleSheet undefined');
        }
        var defaultSections = styleSheet.sections || new Map();
        if (textStyleSheetIndex === 0) return defaultSections;
        var superDefaultSections = styleSheets.get(0).sections;
        return mergeSections(superDefaultSections, defaultSections, this);
      }
    }, {
      key: "master",
      get: function get() {
        if (this._master) return this._master;
        if (this._masterShape) return this._masterShape.master;
        return null;
      }
    }, {
      key: "getMaster",
      value: function getMaster() {
        return this.getRootShape().master;
      }
    }, {
      key: "tooltip",
      get: function get() {
        var string = "shapeId: ".concat(this.id) + "\nwidth: ".concat(this.cells.width) + "\nheight: ".concat(this.cells.height) + "\ntype: ".concat(this.type);
        var masterShape = this.masterShape;
        if (masterShape) {
          string += "\nmasterShapeId: ".concat(masterShape.id);
          if (masterShape.shapeId) string += " (shapeId: ".concat(masterShape.shapeId, ")");
        }
        var master = this.master;
        if (master) string += "\nmasterXml: ".concat(master.xmlPath.split('/').pop());
        string += "\nshapeXml: ".concat(this.pageContent.page.xmlPath.split('/').pop());
        if (this.isOneDimensional()) string += '\nisOneDimensional';
        return string;
      }
    }, {
      key: "textStyle",
      get: function get() {
        if (this._textStyle !== undefined) return this._textStyle;
        if (this.masterShape && this.masterShape.textStyle !== undefined) return this.masterShape.textStyle;
        var defaultTextStyle = this.archive.document.documentSettings.defaultTextStyle;
        if (defaultTextStyle === undefined) {
          debug.log('defaultTextStyle undefined');
        }
        return defaultTextStyle;
      },
      set: function set(textStyle) {
        this._textStyle = textStyle;
      }
    }, {
      key: "fillStyle",
      get: function get() {
        if (this._fillStyle !== undefined) return this._fillStyle;
        if (this.masterShape && this.masterShape.fillStyle !== undefined) return this.masterShape.fillStyle;
        var defaultFillStyle = this.archive.document.documentSettings.defaultFillStyle;
        if (defaultFillStyle === undefined) {
          debug.log('defaultFillStyle undefined');
        }
        return defaultFillStyle;
      },
      set: function set(fillStyle) {
        this._fillStyle = fillStyle;
      }
    }, {
      key: "lineStyle",
      get: function get() {
        if (this._lineStyle !== undefined) return this._lineStyle;
        if (this.masterShape && this.masterShape.lineStyle !== undefined) return this.masterShape.lineStyle;
        var defaultLineStyle = this.archive.document.documentSettings.defaultLineStyle;
        if (defaultLineStyle === undefined) {
          debug.log('defaultLineStyle undefined');
        }
        return defaultLineStyle;
      },
      set: function set(lineStyle) {
        this._lineStyle = lineStyle;
      }
    }, {
      key: "isOneDimensional",
      value: function isOneDimensional() {
        return this.cells.hasEvery([VisioAttribute.beginX, VisioAttribute.beginY, VisioAttribute.endX, VisioAttribute.endY]);
      }
    }, {
      key: "isPrintable",
      value: function isPrintable() {
        return !this.cells.nonPrinting;
      }

      /**
       * @returns {Connect|null}
       */
    }, {
      key: "getConnect",
      value: function getConnect() {
        return this.pageContent.connects.get(this.id) || null;
      }
    }, {
      key: "toElementAttributes",
      value: function toElementAttributes(opts) {
        var origin = this.getPageOrigin();
        var attributes;
        switch (this.type) {
          case VisioShapeType.Group:
            {
              attributes = convertVisioGroupToRappidAttributes(this, {
                origin: origin,
                isRoot: true
              }, opts);
              break;
            }
          case VisioShapeType.Shape:
          case VisioShapeType.Foreign:
            {
              attributes = convertVisioShapeToRappidAttributes(this, {
                origin: origin
              }, opts);
              break;
            }
          default:
            {
              return null;
            }
        }
        attributes.z = this.getPageZIndex();
        return attributes;
      }
    }, {
      key: "toElement",
      value: function toElement() {
        var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$importShape = _ref2.importShape,
          importShape = _ref2$importShape === void 0 ? defaultImportShape : _ref2$importShape,
          _ref2$ignoreNonPrinti = _ref2.ignoreNonPrinting,
          ignoreNonPrinting = _ref2$ignoreNonPrinti === void 0 ? true : _ref2$ignoreNonPrinti,
          _ref2$ignoreSubShapeC = _ref2.ignoreSubShapeConnects,
          ignoreSubShapeConnects = _ref2$ignoreSubShapeC === void 0 ? true : _ref2$ignoreSubShapeC;
        if (typeof importShape !== 'function') return null;
        // in case entire top level Visio shape is marked as nonPrinting, exit early
        if (ignoreNonPrinting && !this.isPrintable()) {
          return null;
        }
        return importShape(this, {
          ignoreNonPrinting: ignoreNonPrinting,
          ignoreSubShapeConnects: ignoreSubShapeConnects
        });
      }
    }], [{
      key: "fromMaster",
      value: function () {
        var _fromMaster = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(master, page) {
          var archive, masterJXON, shapeJXON, parsedShape, pageContent;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  archive = master.archive;
                  _context2.next = 3;
                  return archive.getJxonAsync(master.xmlPath);
                case 3:
                  masterJXON = _context2.sent;
                  shapeJXON = jointjs.util.cloneDeep(masterJXON.Shapes.Shape);
                  prepareStructure(shapeJXON, master);
                  _context2.next = 8;
                  return parseJxon.call(archive, shapeJXON, VisioJxonType.Master, []);
                case 8:
                  parsedShape = _context2.sent;
                  _context2.next = 11;
                  return page.getContent({
                    overrideRels: true
                  });
                case 11:
                  pageContent = _context2.sent;
                  // todo: jxon requires int index while parser requires a master object
                  parsedShape.master = master;
                  return _context2.abrupt("return", new VisioShape(_objectSpread2({
                    archive: archive,
                    pageContent: pageContent
                  }, parsedShape)));
                case 14:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));
        function fromMaster(_x, _x2) {
          return _fromMaster.apply(this, arguments);
        }
        return fromMaster;
      }() // TODO: To be implemented
      // static async fromJXON(jxon, page) {
      //     return { jxon };
      // }
    }]);
    return VisioShape;
  }(VisioSheetObject);
  function prepareStructure(shape, master) {
    if (!shape) return;

    // assign Master attribute to root element and MasterShape to children
    if (master) {
      shape[VisioJxonShapeKey.MasterId] = master.id.toString();
      shape[VisioJxonMasterKey.NameU] = master.nameU;
    } else {
      // nested shapes have to point to proper local master via MasterShape attribute
      shape[VisioJxonShapeKey.MasterShapeId] = shape[VisioJxonShapeKey.Id];
    }

    // assign a unique int ID
    shape[VisioJxonKey.Id] = jointjs.util.uniqueId();

    // remove cells that contain references
    // In cloned cell, reference string stays the same, but context changes.
    shape.Cell = removeReferencedCells(shape.Cell);
    shape.Section = stripSections(shape.Section);

    // execute recurrently
    if (shape.Shapes) {
      if (Array.isArray(shape.Shapes.Shape)) {
        shape.Shapes.Shape.forEach(function (shape) {
          return prepareStructure(shape);
        });
      } else {
        prepareStructure(shape.Shapes.Shape);
      }
    }
  }
  function stripSections(sections) {
    if (Array.isArray(sections)) {
      return sections.map(function (section) {
        section.Cell = removeReferencedCells(section.Cell);
        section.Row = stripRows(section.Row);
        return section;
      });
    } else if (sections !== undefined) {
      return [sections];
    } else {
      return [];
    }
  }
  function stripRows(rows) {
    if (Array.isArray(rows)) {
      return rows.map(function (row) {
        row.Cell = removeReferencedCells(row.Cell);
        return row;
      });
    } else if (rows !== undefined) {
      return [rows];
    } else {
      return [];
    }
  }
  function removeReferencedCells(cells) {
    if (Array.isArray(cells)) {
      return cells.filter(function (cell) {
        return cell[VisioJxonCellKey.Formula] && cell[VisioJxonCellKey.Formula].indexOf('!') === -1;
      });
    } else if (cells !== undefined) {
      // todo: which single cell to keep?
      return [cells];
    } else {
      return [];
    }
  }

  // https://gist.github.com/goblindegook/506781

  function isFontAvailable(font) {
    var testString = '~iomwIOMW';
    var fontArray = font instanceof Array;
    if (!fontArray) {
      font = [font];
    }
    var familySansSerif = 'sans-serif';
    var familyMonospace = 'monospace, monospace';
    // Why monospace twice? It's a bug in the Mozilla and Webkit rendering engines:
    // http://www.undermyhat.org/blog/2009/09/css-font-family-monospace-renders-inconsistently-in-firefox-and-chrome/

    // DOM:
    var container = document.createElement('div');
    var span = document.createElement('span');

    // CSS:
    container.style.visibility = 'hidden';
    container.style.position = 'absolute';
    container.style.left = '-9999px';
    container.style.top = '0px';
    container.style.fontWeight = 'bold';
    container.style.fontSize = '200px !important';
    span.appendChild(document.createTextNode(testString));
    container.appendChild(span);
    document.body.appendChild(container);
    var fontAvailability = [];
    font.forEach(function (f, index) {
      span.style.fontFamily = "".concat(f, ",").concat(familyMonospace);
      var monospaceFallbackWidth = span.offsetWidth;
      var monospaceFallbackHeight = span.offsetHeight;
      span.style.fontFamily = "".concat(f, ",").concat(familySansSerif);
      var sansSerifFallbackWidth = span.offsetWidth;
      var sansSerifFallbackHeight = span.offsetHeight;
      fontAvailability[index] =  monospaceFallbackWidth == sansSerifFallbackWidth && monospaceFallbackHeight == sansSerifFallbackHeight;
    });
    document.body.removeChild(container);
    if (!fontArray && fontAvailability.length == 1) {
      fontAvailability = fontAvailability[0];
    }
    return fontAvailability;
  }

  var VisioPageContent = /*#__PURE__*/function () {
    function VisioPageContent(page) {
      _classCallCheck(this, VisioPageContent);
      if (!page) {
        debug.log('VisioPageContent can only be created using an instance of a Page.', {
          page: page
        });
      }
      this.page = page;

      // only root level shapes
      this.rootShapes = new Map();

      // all shapes flattened (includes root and child shapes)
      this.shapes = new Map();

      // connect objects (not shapes)
      this.connects = new Map();

      // foreign shapes, i.e. images
      this.foreignShapes = new Map();

      // shapes with connect object rel in this.connects
      this.linkShapes = new Map();

      // element shapes (shapes that are not connects)
      this.elementShapes = new Map();
    }

    // private API
    _createClass(VisioPageContent, [{
      key: "loadAsync",
      value: function () {
        var _loadAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(opts) {
          var _this = this;
          var page, pageJxon, parsedPage, _parsedPage$shapes, parsedShapes, _parsedPage$connects, connects, shapes;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  page = this.page;
                  _context.next = 3;
                  return page.archive.getJxonAsync(page.xmlPath);
                case 3:
                  pageJxon = _context.sent;
                  _context.next = 6;
                  return parseJxon.call(page.archive, pageJxon, VisioJxonType.Page, [], {
                    structurePathEnrichObject: {
                      pageId: page.id
                    }
                  });
                case 6:
                  parsedPage = _context.sent;
                  _parsedPage$shapes = parsedPage.shapes, parsedShapes = _parsedPage$shapes === void 0 ? [] : _parsedPage$shapes, _parsedPage$connects = parsedPage.connects, connects = _parsedPage$connects === void 0 ? [] : _parsedPage$connects; // relations (if any) to masters, foreignObjects, backgroundPage
                  _context.next = 10;
                  return page.getRelsMapCachedAsync(opts);
                case 10:
                  _context.next = 12;
                  return page.getMastersFromRelsAsync();
                case 12:
                  connects.forEach(function (connect) {
                    connect.referencePageContent(_this);
                    _this.connects.set(connect.shapeId, connect);
                  });
                  shapes = _toConsumableArray(parsedShapes.values());
                  shapes.forEach(function (parsedShape, index) {
                    var shape = new VisioShape(_objectSpread2({
                      archive: page.archive,
                      masters: page.archive.document.masters,
                      pageContent: _this,
                      xmlOrder: index
                    }, parsedShape));
                    _this.rootShapes.set(parsedShape.id, shape);
                    if (!shape.getConnect()) {
                      _this.elementShapes.set(parsedShape.id, shape);
                    }
                  });
                  this.connects.forEach(function (connect) {
                    var shape = connect.getShape();
                    if (!shape) return; // observed in draw.io/hr.vsdx
                    _this.linkShapes.set(shape.id, shape);
                  });
                case 16:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));
        function loadAsync(_x) {
          return _loadAsync.apply(this, arguments);
        }
        return loadAsync;
      }()
    }, {
      key: "referenceShape",
      value: function referenceShape(shape) {
        // reference in all shapes map
        this.shapes.set(shape.id, shape);

        // reference foreign shape
        if (shape.foreignData) {
          this.setForeignShape(shape.foreignData, shape);
        }

        // reference master foreign data
        if (shape.masterShape && shape.masterShape.foreignData) {
          var master = shape.masterShape;
          this.setForeignShape(master.foreignData, shape, master);
        }

        // reference shape inside cells deep
        this.referenceShapeInsideCellsDeep(shape);
      }
    }, {
      key: "setForeignShape",
      value: function setForeignShape(foreignData, shape, master) {
        var absolutePath = foreignData.targetFile.absolutePath;
        if (!this.foreignShapes.has(absolutePath)) {
          this.foreignShapes.set(absolutePath, []);
        }
        var foreignShapes = this.foreignShapes.get(absolutePath);
        foreignShapes.push({
          foreignData: foreignData,
          shape: shape,
          master: master
        });
      }
    }, {
      key: "referenceShapeInsideCellsDeep",
      value: function referenceShapeInsideCellsDeep(shape) {
        var _this2 = this;
        this.referenceShapeInsideCells(shape._cells, shape);
        shape._sections.forEach(function (sectionsArray) {
          sectionsArray.forEach(function (section) {
            if (!section || !section.rows) {
              return;
            }
            section.rows.forEach(function (row) {
              _this2.referenceShapeInsideCells(row.cells, shape);
            });
          });
        });
      }
    }, {
      key: "referenceShapeInsideCells",
      value: function referenceShapeInsideCells(cells, shape) {
        if (!cells) return;
        if (!(shape instanceof VisioShape)) {
          debug.log('shape must be instance of Shape');
        }
        cells.shape = shape;
        if (shape.masterShape) {
          cells.parent = shape.masterShape;
        }
      }

      // public API
    }, {
      key: "toGraphCells",
      value: function toGraphCells() {
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$importShape = _ref.importShape,
          importShape = _ref$importShape === void 0 ? defaultImportShape : _ref$importShape,
          _ref$importConnect = _ref.importConnect,
          importConnect = _ref$importConnect === void 0 ? defaultImportConnect : _ref$importConnect,
          _ref$importLabels = _ref.importLabels,
          importLabels = _ref$importLabels === void 0 ? defaultImportLabels : _ref$importLabels,
          _ref$importImage = _ref.importImage,
          importImage = _ref$importImage === void 0 ? defaultImportImage : _ref$importImage,
          _ref$ignoreNonPrintin = _ref.ignoreNonPrinting,
          ignoreNonPrinting = _ref$ignoreNonPrintin === void 0 ? true : _ref$ignoreNonPrintin,
          _ref$ignoreSubShapeCo = _ref.ignoreSubShapeConnects,
          ignoreSubShapeConnects = _ref$ignoreSubShapeCo === void 0 ? true : _ref$ignoreSubShapeCo,
          _ref$onImagesLoad = _ref.onImagesLoad,
          onImagesLoad = _ref$onImagesLoad === void 0 ? null : _ref$onImagesLoad;
        var elementsMap = new Map();
        var linksMap = new Map();
        var labelsMap = new Map();

        // ELEMENTS / NON-CONNECTS
        // create a map of Rappid Elements from Visio shapes that are not Connects
        this.getElementShapes().forEach(function (shape) {
          var element = shape.toElement({
            importShape: importShape,
            ignoreNonPrinting: ignoreNonPrinting,
            ignoreSubShapeConnects: ignoreSubShapeConnects
          });
          if (element) {
            elementsMap.set(shape.id, element);
          }
        });

        // LINKS / CONNECTS
        // elementsMap is used to properly set source and target on links
        this.getLinkShapes().forEach(function (shape) {
          var link = shape.getConnect().toLink(elementsMap, {
            importShape: importShape,
            importConnect: importConnect,
            ignoreNonPrinting: ignoreNonPrinting
          });
          if (link) {
            linksMap.set(shape.id, link);
            if (link.isLink()) {
              // Link Labels
              var labels = shape.getConnect().toLinkLabels(link, {
                importLabels: importLabels
              });
              if (labels) {
                labelsMap.set(shape.id, labels);
              }
            }
          }
        });

        // IMAGES
        // elements map is used to load foreign objects as well,
        // images are loaded async
        var vImages = this.getForeignShapes().map(function (image) {
          return image.map(function (usedImage) {
            return usedImage.shape;
          });
        }).flat();
        var imagesAsync = vImages.map(function (vsdShape) {
          return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
            var element, vsdImage;
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    element = elementsMap.get(vsdShape.getRootShape().id); // todo: implement nested images
                    if (element) {
                      _context2.next = 3;
                      break;
                    }
                    return _context2.abrupt("return", null);
                  case 3:
                    _context2.next = 5;
                    return vsdShape.getImage();
                  case 5:
                    vsdImage = _context2.sent;
                    if (vsdImage) {
                      _context2.next = 8;
                      break;
                    }
                    return _context2.abrupt("return", null);
                  case 8:
                    return _context2.abrupt("return", importImage(vsdShape, element, vsdImage));
                  case 9:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));
        });
        Promise.all(imagesAsync.map(function (fn) {
          return fn();
        })).then(function (images) {
          if (typeof onImagesLoad !== 'function') return;
          onImagesLoad(images.filter(function (image) {
            return image !== null;
          }));
        });
        return [].concat(_toConsumableArray(elementsMap.values()), _toConsumableArray(linksMap.values()), _toConsumableArray(labelsMap.values())).flat();
      }
    }, {
      key: "getRootShapes",
      value: function getRootShapes() {
        return _toConsumableArray(this.rootShapes.values());
      }
    }, {
      key: "getRootShape",
      value: function getRootShape(id) {
        return this.rootShapes.get(id) || null;
      }
    }, {
      key: "getShapes",
      value: function getShapes() {
        return _toConsumableArray(this.shapes.values());
      }
    }, {
      key: "getShape",
      value: function getShape(id) {
        return this.shapes.get(id) || null;
      }
    }, {
      key: "getConnects",
      value: function getConnects() {
        return _toConsumableArray(this.connects.values());
      }
    }, {
      key: "getConnect",
      value: function getConnect(shapeId) {
        return this.connects.get(shapeId) || null;
      }
    }, {
      key: "getForeignShapes",
      value: function getForeignShapes() {
        return _toConsumableArray(this.foreignShapes.values());
      }
    }, {
      key: "getForeignShape",
      value: function getForeignShape(path) {
        return this.foreignShapes.get(path) || null;
      }
    }, {
      key: "getLinkShapes",
      value: function getLinkShapes() {
        return _toConsumableArray(this.linkShapes.values());
      }
    }, {
      key: "getElementShapes",
      value: function getElementShapes() {
        return _toConsumableArray(this.elementShapes.values());
      }
    }, {
      key: "getFonts",
      value: function getFonts() {
        var fonts = new Set();
        this.shapes.forEach(function (shape) {
          var _char = shape.getComputedSection(VisioSectionType.Character);
          if (!_char) return;
          var row = _char.getRow(0);
          if (!row) return;
          var _row$getCell = row.getCell(VisioCellName.Font),
            value = _row$getCell.value;
          if (value !== undefined && value !== 'Themed' && !fonts.has(value)) {
            fonts.add(value);
          }
        });
        return _toConsumableArray(fonts.values());
      }
    }, {
      key: "getUnsupportedFonts",
      value: function getUnsupportedFonts() {
        return this.getFonts().filter(function (font) {
          return !isFontAvailable(font);
        });
      }
    }]);
    return VisioPageContent;
  }();

  // eslint-disable-next-line es/no-typed-arrays -- safe
  var arrayBufferBasicDetection = typeof ArrayBuffer != 'undefined' && typeof DataView != 'undefined';

  var $RangeError = RangeError;

  // `ToIndex` abstract operation
  // https://tc39.es/ecma262/#sec-toindex
  var toIndex = function (it) {
    if (it === undefined) return 0;
    var number = toIntegerOrInfinity(it);
    var length = toLength(number);
    if (number !== length) throw $RangeError('Wrong length or index');
    return length;
  };

  // IEEE754 conversions based on https://github.com/feross/ieee754
  var $Array$4 = Array;
  var abs$1 = Math.abs;
  var pow = Math.pow;
  var floor$4 = Math.floor;
  var log$1 = Math.log;
  var LN2 = Math.LN2;

  var pack = function (number, mantissaLength, bytes) {
    var buffer = $Array$4(bytes);
    var exponentLength = bytes * 8 - mantissaLength - 1;
    var eMax = (1 << exponentLength) - 1;
    var eBias = eMax >> 1;
    var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
    var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
    var index = 0;
    var exponent, mantissa, c;
    number = abs$1(number);
    // eslint-disable-next-line no-self-compare -- NaN check
    if (number != number || number === Infinity) {
      // eslint-disable-next-line no-self-compare -- NaN check
      mantissa = number != number ? 1 : 0;
      exponent = eMax;
    } else {
      exponent = floor$4(log$1(number) / LN2);
      c = pow(2, -exponent);
      if (number * c < 1) {
        exponent--;
        c *= 2;
      }
      if (exponent + eBias >= 1) {
        number += rt / c;
      } else {
        number += rt * pow(2, 1 - eBias);
      }
      if (number * c >= 2) {
        exponent++;
        c /= 2;
      }
      if (exponent + eBias >= eMax) {
        mantissa = 0;
        exponent = eMax;
      } else if (exponent + eBias >= 1) {
        mantissa = (number * c - 1) * pow(2, mantissaLength);
        exponent = exponent + eBias;
      } else {
        mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
        exponent = 0;
      }
    }
    while (mantissaLength >= 8) {
      buffer[index++] = mantissa & 255;
      mantissa /= 256;
      mantissaLength -= 8;
    }
    exponent = exponent << mantissaLength | mantissa;
    exponentLength += mantissaLength;
    while (exponentLength > 0) {
      buffer[index++] = exponent & 255;
      exponent /= 256;
      exponentLength -= 8;
    }
    buffer[--index] |= sign * 128;
    return buffer;
  };

  var unpack = function (buffer, mantissaLength) {
    var bytes = buffer.length;
    var exponentLength = bytes * 8 - mantissaLength - 1;
    var eMax = (1 << exponentLength) - 1;
    var eBias = eMax >> 1;
    var nBits = exponentLength - 7;
    var index = bytes - 1;
    var sign = buffer[index--];
    var exponent = sign & 127;
    var mantissa;
    sign >>= 7;
    while (nBits > 0) {
      exponent = exponent * 256 + buffer[index--];
      nBits -= 8;
    }
    mantissa = exponent & (1 << -nBits) - 1;
    exponent >>= -nBits;
    nBits += mantissaLength;
    while (nBits > 0) {
      mantissa = mantissa * 256 + buffer[index--];
      nBits -= 8;
    }
    if (exponent === 0) {
      exponent = 1 - eBias;
    } else if (exponent === eMax) {
      return mantissa ? NaN : sign ? -Infinity : Infinity;
    } else {
      mantissa = mantissa + pow(2, mantissaLength);
      exponent = exponent - eBias;
    } return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
  };

  var ieee754 = {
    pack: pack,
    unpack: unpack
  };

  var getOwnPropertyNames$2 = objectGetOwnPropertyNames.f;
  var defineProperty$9 = objectDefineProperty.f;





  var PROPER_FUNCTION_NAME$3 = functionName.PROPER;
  var CONFIGURABLE_FUNCTION_NAME$1 = functionName.CONFIGURABLE;
  var getInternalState$3 = internalState.get;
  var setInternalState$4 = internalState.set;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var DATA_VIEW = 'DataView';
  var PROTOTYPE$1 = 'prototype';
  var WRONG_LENGTH = 'Wrong length';
  var WRONG_INDEX = 'Wrong index';
  var NativeArrayBuffer = global_1[ARRAY_BUFFER];
  var $ArrayBuffer = NativeArrayBuffer;
  var ArrayBufferPrototype = $ArrayBuffer && $ArrayBuffer[PROTOTYPE$1];
  var $DataView = global_1[DATA_VIEW];
  var DataViewPrototype = $DataView && $DataView[PROTOTYPE$1];
  var ObjectPrototype$1 = Object.prototype;
  var Array$1 = global_1.Array;
  var RangeError$1 = global_1.RangeError;
  var fill = functionUncurryThis(arrayFill);
  var reverse = functionUncurryThis([].reverse);

  var packIEEE754 = ieee754.pack;
  var unpackIEEE754 = ieee754.unpack;

  var packInt8 = function (number) {
    return [number & 0xFF];
  };

  var packInt16 = function (number) {
    return [number & 0xFF, number >> 8 & 0xFF];
  };

  var packInt32 = function (number) {
    return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
  };

  var unpackInt32 = function (buffer) {
    return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
  };

  var packFloat32 = function (number) {
    return packIEEE754(number, 23, 4);
  };

  var packFloat64 = function (number) {
    return packIEEE754(number, 52, 8);
  };

  var addGetter = function (Constructor, key) {
    defineProperty$9(Constructor[PROTOTYPE$1], key, { get: function () { return getInternalState$3(this)[key]; } });
  };

  var get$1 = function (view, count, index, isLittleEndian) {
    var intIndex = toIndex(index);
    var store = getInternalState$3(view);
    if (intIndex + count > store.byteLength) throw RangeError$1(WRONG_INDEX);
    var bytes = getInternalState$3(store.buffer).bytes;
    var start = intIndex + store.byteOffset;
    var pack = arraySliceSimple(bytes, start, start + count);
    return isLittleEndian ? pack : reverse(pack);
  };

  var set$2 = function (view, count, index, conversion, value, isLittleEndian) {
    var intIndex = toIndex(index);
    var store = getInternalState$3(view);
    if (intIndex + count > store.byteLength) throw RangeError$1(WRONG_INDEX);
    var bytes = getInternalState$3(store.buffer).bytes;
    var start = intIndex + store.byteOffset;
    var pack = conversion(+value);
    for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
  };

  if (!arrayBufferBasicDetection) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, ArrayBufferPrototype);
      var byteLength = toIndex(length);
      setInternalState$4(this, {
        bytes: fill(Array$1(byteLength), 0),
        byteLength: byteLength
      });
      if (!descriptors) this.byteLength = byteLength;
    };

    ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE$1];

    $DataView = function DataView(buffer, byteOffset, byteLength) {
      anInstance(this, DataViewPrototype);
      anInstance(buffer, ArrayBufferPrototype);
      var bufferLength = getInternalState$3(buffer).byteLength;
      var offset = toIntegerOrInfinity(byteOffset);
      if (offset < 0 || offset > bufferLength) throw RangeError$1('Wrong offset');
      byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
      if (offset + byteLength > bufferLength) throw RangeError$1(WRONG_LENGTH);
      setInternalState$4(this, {
        buffer: buffer,
        byteLength: byteLength,
        byteOffset: offset
      });
      if (!descriptors) {
        this.buffer = buffer;
        this.byteLength = byteLength;
        this.byteOffset = offset;
      }
    };

    DataViewPrototype = $DataView[PROTOTYPE$1];

    if (descriptors) {
      addGetter($ArrayBuffer, 'byteLength');
      addGetter($DataView, 'buffer');
      addGetter($DataView, 'byteLength');
      addGetter($DataView, 'byteOffset');
    }

    defineBuiltIns(DataViewPrototype, {
      getInt8: function getInt8(byteOffset) {
        return get$1(this, 1, byteOffset)[0] << 24 >> 24;
      },
      getUint8: function getUint8(byteOffset) {
        return get$1(this, 1, byteOffset)[0];
      },
      getInt16: function getInt16(byteOffset /* , littleEndian */) {
        var bytes = get$1(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
        return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
      },
      getUint16: function getUint16(byteOffset /* , littleEndian */) {
        var bytes = get$1(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
        return bytes[1] << 8 | bytes[0];
      },
      getInt32: function getInt32(byteOffset /* , littleEndian */) {
        return unpackInt32(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
      },
      getUint32: function getUint32(byteOffset /* , littleEndian */) {
        return unpackInt32(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
      },
      getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
        return unpackIEEE754(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
      },
      getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
        return unpackIEEE754(get$1(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
      },
      setInt8: function setInt8(byteOffset, value) {
        set$2(this, 1, byteOffset, packInt8, value);
      },
      setUint8: function setUint8(byteOffset, value) {
        set$2(this, 1, byteOffset, packInt8, value);
      },
      setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
        set$2(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
      },
      setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
        set$2(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
      },
      setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
        set$2(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
      },
      setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
        set$2(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
      },
      setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
        set$2(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
      },
      setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
        set$2(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
      }
    });
  } else {
    var INCORRECT_ARRAY_BUFFER_NAME = PROPER_FUNCTION_NAME$3 && NativeArrayBuffer.name !== ARRAY_BUFFER;
    /* eslint-disable no-new -- required for testing */
    if (!fails(function () {
      NativeArrayBuffer(1);
    }) || !fails(function () {
      new NativeArrayBuffer(-1);
    }) || fails(function () {
      new NativeArrayBuffer();
      new NativeArrayBuffer(1.5);
      new NativeArrayBuffer(NaN);
      return NativeArrayBuffer.length != 1 || INCORRECT_ARRAY_BUFFER_NAME && !CONFIGURABLE_FUNCTION_NAME$1;
    })) {
      /* eslint-enable no-new -- required for testing */
      $ArrayBuffer = function ArrayBuffer(length) {
        anInstance(this, ArrayBufferPrototype);
        return new NativeArrayBuffer(toIndex(length));
      };

      $ArrayBuffer[PROTOTYPE$1] = ArrayBufferPrototype;

      for (var keys$3 = getOwnPropertyNames$2(NativeArrayBuffer), j$1 = 0, key$1; keys$3.length > j$1;) {
        if (!((key$1 = keys$3[j$1++]) in $ArrayBuffer)) {
          createNonEnumerableProperty($ArrayBuffer, key$1, NativeArrayBuffer[key$1]);
        }
      }

      ArrayBufferPrototype.constructor = $ArrayBuffer;
    } else if (INCORRECT_ARRAY_BUFFER_NAME && CONFIGURABLE_FUNCTION_NAME$1) {
      createNonEnumerableProperty(NativeArrayBuffer, 'name', ARRAY_BUFFER);
    }

    // WebKit bug - the same parent prototype for typed arrays and data view
    if (objectSetPrototypeOf && objectGetPrototypeOf(DataViewPrototype) !== ObjectPrototype$1) {
      objectSetPrototypeOf(DataViewPrototype, ObjectPrototype$1);
    }

    // iOS Safari 7.x bug
    var testView = new $DataView(new $ArrayBuffer(2));
    var $setInt8 = functionUncurryThis(DataViewPrototype.setInt8);
    testView.setInt8(0, 2147483648);
    testView.setInt8(1, 2147483649);
    if (testView.getInt8(0) || !testView.getInt8(1)) defineBuiltIns(DataViewPrototype, {
      setInt8: function setInt8(byteOffset, value) {
        $setInt8(this, byteOffset, value << 24 >> 24);
      },
      setUint8: function setUint8(byteOffset, value) {
        $setInt8(this, byteOffset, value << 24 >> 24);
      }
    }, { unsafe: true });
  }

  setToStringTag($ArrayBuffer, ARRAY_BUFFER);
  setToStringTag($DataView, DATA_VIEW);

  var arrayBuffer = {
    ArrayBuffer: $ArrayBuffer,
    DataView: $DataView
  };

  var ARRAY_BUFFER$1 = 'ArrayBuffer';
  var ArrayBuffer$1 = arrayBuffer[ARRAY_BUFFER$1];
  var NativeArrayBuffer$1 = global_1[ARRAY_BUFFER$1];

  // `ArrayBuffer` constructor
  // https://tc39.es/ecma262/#sec-arraybuffer-constructor
  _export({ global: true, constructor: true, forced: NativeArrayBuffer$1 !== ArrayBuffer$1 }, {
    ArrayBuffer: ArrayBuffer$1
  });

  setSpecies(ARRAY_BUFFER$1);

  var ArrayBuffer$2 = arrayBuffer.ArrayBuffer;
  var DataView$1 = arrayBuffer.DataView;
  var DataViewPrototype$1 = DataView$1.prototype;
  var nativeArrayBufferSlice = functionUncurryThis(ArrayBuffer$2.prototype.slice);
  var getUint8 = functionUncurryThis(DataViewPrototype$1.getUint8);
  var setUint8 = functionUncurryThis(DataViewPrototype$1.setUint8);

  var INCORRECT_SLICE = fails(function () {
    return !new ArrayBuffer$2(2).slice(1, undefined).byteLength;
  });

  // `ArrayBuffer.prototype.slice` method
  // https://tc39.es/ecma262/#sec-arraybuffer.prototype.slice
  _export({ target: 'ArrayBuffer', proto: true, unsafe: true, forced: INCORRECT_SLICE }, {
    slice: function slice(start, end) {
      if (nativeArrayBufferSlice && end === undefined) {
        return nativeArrayBufferSlice(anObject(this), start); // FF fix
      }
      var length = anObject(this).byteLength;
      var first = toAbsoluteIndex(start, length);
      var fin = toAbsoluteIndex(end === undefined ? length : end, length);
      var result = new (speciesConstructor(this, ArrayBuffer$2))(toLength(fin - first));
      var viewSource = new DataView$1(this);
      var viewTarget = new DataView$1(result);
      var index = 0;
      while (first < fin) {
        setUint8(viewTarget, index++, getUint8(viewSource, first++));
      } return result;
    }
  });

  var defineProperty$a = objectDefineProperty.f;







  var enforceInternalState$1 = internalState.enforce;
  var getInternalState$4 = internalState.get;
  var Int8Array$1 = global_1.Int8Array;
  var Int8ArrayPrototype = Int8Array$1 && Int8Array$1.prototype;
  var Uint8ClampedArray$1 = global_1.Uint8ClampedArray;
  var Uint8ClampedArrayPrototype = Uint8ClampedArray$1 && Uint8ClampedArray$1.prototype;
  var TypedArray = Int8Array$1 && objectGetPrototypeOf(Int8Array$1);
  var TypedArrayPrototype = Int8ArrayPrototype && objectGetPrototypeOf(Int8ArrayPrototype);
  var ObjectPrototype$2 = Object.prototype;
  var TypeError$4 = global_1.TypeError;

  var TO_STRING_TAG$4 = wellKnownSymbol('toStringTag');
  var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
  var TYPED_ARRAY_CONSTRUCTOR = 'TypedArrayConstructor';
  // Fixing native typed arrays in Opera Presto crashes the browser, see #595
  var NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferBasicDetection && !!objectSetPrototypeOf && classof(global_1.opera) !== 'Opera';
  var TYPED_ARRAY_TAG_REQUIRED = false;
  var NAME$1, Constructor, Prototype;

  var TypedArrayConstructorsList = {
    Int8Array: 1,
    Uint8Array: 1,
    Uint8ClampedArray: 1,
    Int16Array: 2,
    Uint16Array: 2,
    Int32Array: 4,
    Uint32Array: 4,
    Float32Array: 4,
    Float64Array: 8
  };

  var BigIntArrayConstructorsList = {
    BigInt64Array: 8,
    BigUint64Array: 8
  };

  var isView = function isView(it) {
    if (!isObject(it)) return false;
    var klass = classof(it);
    return klass === 'DataView'
      || hasOwnProperty_1(TypedArrayConstructorsList, klass)
      || hasOwnProperty_1(BigIntArrayConstructorsList, klass);
  };

  var getTypedArrayConstructor = function (it) {
    var proto = objectGetPrototypeOf(it);
    if (!isObject(proto)) return;
    var state = getInternalState$4(proto);
    return (state && hasOwnProperty_1(state, TYPED_ARRAY_CONSTRUCTOR)) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);
  };

  var isTypedArray = function (it) {
    if (!isObject(it)) return false;
    var klass = classof(it);
    return hasOwnProperty_1(TypedArrayConstructorsList, klass)
      || hasOwnProperty_1(BigIntArrayConstructorsList, klass);
  };

  var aTypedArray = function (it) {
    if (isTypedArray(it)) return it;
    throw TypeError$4('Target is not a typed array');
  };

  var aTypedArrayConstructor = function (C) {
    if (isCallable(C) && (!objectSetPrototypeOf || objectIsPrototypeOf(TypedArray, C))) return C;
    throw TypeError$4(tryToString(C) + ' is not a typed array constructor');
  };

  var exportTypedArrayMethod = function (KEY, property, forced, options) {
    if (!descriptors) return;
    if (forced) for (var ARRAY in TypedArrayConstructorsList) {
      var TypedArrayConstructor = global_1[ARRAY];
      if (TypedArrayConstructor && hasOwnProperty_1(TypedArrayConstructor.prototype, KEY)) try {
        delete TypedArrayConstructor.prototype[KEY];
      } catch (error) {
        // old WebKit bug - some methods are non-configurable
        try {
          TypedArrayConstructor.prototype[KEY] = property;
        } catch (error2) { /* empty */ }
      }
    }
    if (!TypedArrayPrototype[KEY] || forced) {
      defineBuiltIn(TypedArrayPrototype, KEY, forced ? property
        : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);
    }
  };

  var exportTypedArrayStaticMethod = function (KEY, property, forced) {
    var ARRAY, TypedArrayConstructor;
    if (!descriptors) return;
    if (objectSetPrototypeOf) {
      if (forced) for (ARRAY in TypedArrayConstructorsList) {
        TypedArrayConstructor = global_1[ARRAY];
        if (TypedArrayConstructor && hasOwnProperty_1(TypedArrayConstructor, KEY)) try {
          delete TypedArrayConstructor[KEY];
        } catch (error) { /* empty */ }
      }
      if (!TypedArray[KEY] || forced) {
        // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
        try {
          return defineBuiltIn(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
        } catch (error) { /* empty */ }
      } else return;
    }
    for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = global_1[ARRAY];
      if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
        defineBuiltIn(TypedArrayConstructor, KEY, property);
      }
    }
  };

  for (NAME$1 in TypedArrayConstructorsList) {
    Constructor = global_1[NAME$1];
    Prototype = Constructor && Constructor.prototype;
    if (Prototype) enforceInternalState$1(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
    else NATIVE_ARRAY_BUFFER_VIEWS = false;
  }

  for (NAME$1 in BigIntArrayConstructorsList) {
    Constructor = global_1[NAME$1];
    Prototype = Constructor && Constructor.prototype;
    if (Prototype) enforceInternalState$1(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
  }

  // WebKit bug - typed arrays constructors prototype is Object.prototype
  if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
    // eslint-disable-next-line no-shadow -- safe
    TypedArray = function TypedArray() {
      throw TypeError$4('Incorrect invocation');
    };
    if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME$1 in TypedArrayConstructorsList) {
      if (global_1[NAME$1]) objectSetPrototypeOf(global_1[NAME$1], TypedArray);
    }
  }

  if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype$2) {
    TypedArrayPrototype = TypedArray.prototype;
    if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME$1 in TypedArrayConstructorsList) {
      if (global_1[NAME$1]) objectSetPrototypeOf(global_1[NAME$1].prototype, TypedArrayPrototype);
    }
  }

  // WebKit bug - one more object in Uint8ClampedArray prototype chain
  if (NATIVE_ARRAY_BUFFER_VIEWS && objectGetPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
    objectSetPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
  }

  if (descriptors && !hasOwnProperty_1(TypedArrayPrototype, TO_STRING_TAG$4)) {
    TYPED_ARRAY_TAG_REQUIRED = true;
    defineProperty$a(TypedArrayPrototype, TO_STRING_TAG$4, { get: function () {
      return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
    } });
    for (NAME$1 in TypedArrayConstructorsList) if (global_1[NAME$1]) {
      createNonEnumerableProperty(global_1[NAME$1], TYPED_ARRAY_TAG, NAME$1);
    }
  }

  var arrayBufferViewCore = {
    NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
    TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,
    aTypedArray: aTypedArray,
    aTypedArrayConstructor: aTypedArrayConstructor,
    exportTypedArrayMethod: exportTypedArrayMethod,
    exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
    getTypedArrayConstructor: getTypedArrayConstructor,
    isView: isView,
    isTypedArray: isTypedArray,
    TypedArray: TypedArray,
    TypedArrayPrototype: TypedArrayPrototype
  };

  /* eslint-disable no-new -- required for testing */



  var NATIVE_ARRAY_BUFFER_VIEWS$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;

  var ArrayBuffer$3 = global_1.ArrayBuffer;
  var Int8Array$2 = global_1.Int8Array;

  var typedArrayConstructorsRequireWrappers = !NATIVE_ARRAY_BUFFER_VIEWS$1 || !fails(function () {
    Int8Array$2(1);
  }) || !fails(function () {
    new Int8Array$2(-1);
  }) || !checkCorrectnessOfIteration(function (iterable) {
    new Int8Array$2();
    new Int8Array$2(null);
    new Int8Array$2(1.5);
    new Int8Array$2(iterable);
  }, true) || fails(function () {
    // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
    return new Int8Array$2(new ArrayBuffer$3(2), 1, undefined).length !== 1;
  });

  var $RangeError$1 = RangeError;

  var toPositiveInteger = function (it) {
    var result = toIntegerOrInfinity(it);
    if (result < 0) throw $RangeError$1("The argument can't be less than 0");
    return result;
  };

  var $RangeError$2 = RangeError;

  var toOffset = function (it, BYTES) {
    var offset = toPositiveInteger(it);
    if (offset % BYTES) throw $RangeError$2('Wrong offset');
    return offset;
  };

  var slice = functionUncurryThis(''.slice);

  var isBigIntArray = function (it) {
    return slice(classof(it), 0, 3) === 'Big';
  };

  var $TypeError$j = TypeError;

  // `ToBigInt` abstract operation
  // https://tc39.es/ecma262/#sec-tobigint
  var toBigInt = function (argument) {
    var prim = toPrimitive(argument, 'number');
    if (typeof prim == 'number') throw $TypeError$j("Can't convert number to bigint");
    // eslint-disable-next-line es/no-bigint -- safe
    return BigInt(prim);
  };

  var aTypedArrayConstructor$1 = arrayBufferViewCore.aTypedArrayConstructor;


  var typedArrayFrom = function from(source /* , mapfn, thisArg */) {
    var C = aConstructor(this);
    var O = toObject(source);
    var argumentsLength = arguments.length;
    var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iteratorMethod = getIteratorMethod(O);
    var i, length, result, thisIsBigIntArray, value, step, iterator, next;
    if (iteratorMethod && !isArrayIteratorMethod(iteratorMethod)) {
      iterator = getIterator(O, iteratorMethod);
      next = iterator.next;
      O = [];
      while (!(step = functionCall(next, iterator)).done) {
        O.push(step.value);
      }
    }
    if (mapping && argumentsLength > 2) {
      mapfn = functionBindContext(mapfn, arguments[2]);
    }
    length = lengthOfArrayLike(O);
    result = new (aTypedArrayConstructor$1(C))(length);
    thisIsBigIntArray = isBigIntArray(result);
    for (i = 0; length > i; i++) {
      value = mapping ? mapfn(O[i], i) : O[i];
      // FF30- typed arrays doesn't properly convert objects to typed array values
      result[i] = thisIsBigIntArray ? toBigInt(value) : +value;
    }
    return result;
  };

  var typedArrayConstructor = createCommonjsModule(function (module) {






















  var getOwnPropertyNames = objectGetOwnPropertyNames.f;

  var forEach = arrayIteration.forEach;






  var getInternalState = internalState.get;
  var setInternalState = internalState.set;
  var enforceInternalState = internalState.enforce;
  var nativeDefineProperty = objectDefineProperty.f;
  var nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
  var round = Math.round;
  var RangeError = global_1.RangeError;
  var ArrayBuffer = arrayBuffer.ArrayBuffer;
  var ArrayBufferPrototype = ArrayBuffer.prototype;
  var DataView = arrayBuffer.DataView;
  var NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
  var TYPED_ARRAY_TAG = arrayBufferViewCore.TYPED_ARRAY_TAG;
  var TypedArray = arrayBufferViewCore.TypedArray;
  var TypedArrayPrototype = arrayBufferViewCore.TypedArrayPrototype;
  var aTypedArrayConstructor = arrayBufferViewCore.aTypedArrayConstructor;
  var isTypedArray = arrayBufferViewCore.isTypedArray;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var WRONG_LENGTH = 'Wrong length';

  var fromList = function (C, list) {
    aTypedArrayConstructor(C);
    var index = 0;
    var length = list.length;
    var result = new C(length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key) {
    nativeDefineProperty(it, key, { get: function () {
      return getInternalState(this)[key];
    } });
  };

  var isArrayBuffer = function (it) {
    var klass;
    return objectIsPrototypeOf(ArrayBufferPrototype, it) || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
  };

  var isTypedArrayIndex = function (target, key) {
    return isTypedArray(target)
      && !isSymbol(key)
      && key in target
      && isIntegralNumber(+key)
      && key >= 0;
  };

  var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
    key = toPropertyKey(key);
    return isTypedArrayIndex(target, key)
      ? createPropertyDescriptor(2, target[key])
      : nativeGetOwnPropertyDescriptor(target, key);
  };

  var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
    key = toPropertyKey(key);
    if (isTypedArrayIndex(target, key)
      && isObject(descriptor)
      && hasOwnProperty_1(descriptor, 'value')
      && !hasOwnProperty_1(descriptor, 'get')
      && !hasOwnProperty_1(descriptor, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !descriptor.configurable
      && (!hasOwnProperty_1(descriptor, 'writable') || descriptor.writable)
      && (!hasOwnProperty_1(descriptor, 'enumerable') || descriptor.enumerable)
    ) {
      target[key] = descriptor.value;
      return target;
    } return nativeDefineProperty(target, key, descriptor);
  };

  if (descriptors) {
    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
      objectGetOwnPropertyDescriptor.f = wrappedGetOwnPropertyDescriptor;
      objectDefineProperty.f = wrappedDefineProperty;
      addGetter(TypedArrayPrototype, 'buffer');
      addGetter(TypedArrayPrototype, 'byteOffset');
      addGetter(TypedArrayPrototype, 'byteLength');
      addGetter(TypedArrayPrototype, 'length');
    }

    _export({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
      getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
      defineProperty: wrappedDefineProperty
    });

    module.exports = function (TYPE, wrapper, CLAMPED) {
      var BYTES = TYPE.match(/\d+$/)[0] / 8;
      var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
      var GETTER = 'get' + TYPE;
      var SETTER = 'set' + TYPE;
      var NativeTypedArrayConstructor = global_1[CONSTRUCTOR_NAME];
      var TypedArrayConstructor = NativeTypedArrayConstructor;
      var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
      var exported = {};

      var getter = function (that, index) {
        var data = getInternalState(that);
        return data.view[GETTER](index * BYTES + data.byteOffset, true);
      };

      var setter = function (that, index, value) {
        var data = getInternalState(that);
        if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
        data.view[SETTER](index * BYTES + data.byteOffset, value, true);
      };

      var addElement = function (that, index) {
        nativeDefineProperty(that, index, {
          get: function () {
            return getter(this, index);
          },
          set: function (value) {
            return setter(this, index, value);
          },
          enumerable: true
        });
      };

      if (!NATIVE_ARRAY_BUFFER_VIEWS) {
        TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
          anInstance(that, TypedArrayConstructorPrototype);
          var index = 0;
          var byteOffset = 0;
          var buffer, byteLength, length;
          if (!isObject(data)) {
            length = toIndex(data);
            byteLength = length * BYTES;
            buffer = new ArrayBuffer(byteLength);
          } else if (isArrayBuffer(data)) {
            buffer = data;
            byteOffset = toOffset(offset, BYTES);
            var $len = data.byteLength;
            if ($length === undefined) {
              if ($len % BYTES) throw RangeError(WRONG_LENGTH);
              byteLength = $len - byteOffset;
              if (byteLength < 0) throw RangeError(WRONG_LENGTH);
            } else {
              byteLength = toLength($length) * BYTES;
              if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
            }
            length = byteLength / BYTES;
          } else if (isTypedArray(data)) {
            return fromList(TypedArrayConstructor, data);
          } else {
            return functionCall(typedArrayFrom, TypedArrayConstructor, data);
          }
          setInternalState(that, {
            buffer: buffer,
            byteOffset: byteOffset,
            byteLength: byteLength,
            length: length,
            view: new DataView(buffer)
          });
          while (index < length) addElement(that, index++);
        });

        if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
        TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = objectCreate(TypedArrayPrototype);
      } else if (typedArrayConstructorsRequireWrappers) {
        TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
          anInstance(dummy, TypedArrayConstructorPrototype);
          return inheritIfRequired(function () {
            if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
            if (isArrayBuffer(data)) return $length !== undefined
              ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length)
              : typedArrayOffset !== undefined
                ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES))
                : new NativeTypedArrayConstructor(data);
            if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
            return functionCall(typedArrayFrom, TypedArrayConstructor, data);
          }(), dummy, TypedArrayConstructor);
        });

        if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
        forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
          if (!(key in TypedArrayConstructor)) {
            createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
          }
        });
        TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
      }

      if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
        createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
      }

      enforceInternalState(TypedArrayConstructorPrototype).TypedArrayConstructor = TypedArrayConstructor;

      if (TYPED_ARRAY_TAG) {
        createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
      }

      var FORCED = TypedArrayConstructor != NativeTypedArrayConstructor;

      exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;

      _export({ global: true, constructor: true, forced: FORCED, sham: !NATIVE_ARRAY_BUFFER_VIEWS }, exported);

      if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
        createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
      }

      if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
        createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
      }

      setSpecies(CONSTRUCTOR_NAME);
    };
  } else module.exports = function () { /* empty */ };
  });

  // `Uint8Array` constructor
  // https://tc39.es/ecma262/#sec-typedarray-objects
  typedArrayConstructor('Uint8', function (init) {
    return function Uint8Array(data, byteOffset, length) {
      return init(this, data, byteOffset, length);
    };
  });

  var min$5 = Math.min;

  // `Array.prototype.copyWithin` method implementation
  // https://tc39.es/ecma262/#sec-array.prototype.copywithin
  // eslint-disable-next-line es/no-array-prototype-copywithin -- safe
  var arrayCopyWithin = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
    var O = toObject(this);
    var len = lengthOfArrayLike(O);
    var to = toAbsoluteIndex(target, len);
    var from = toAbsoluteIndex(start, len);
    var end = arguments.length > 2 ? arguments[2] : undefined;
    var count = min$5((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
    var inc = 1;
    if (from < to && to < from + count) {
      inc = -1;
      from += count - 1;
      to += count - 1;
    }
    while (count-- > 0) {
      if (from in O) O[to] = O[from];
      else deletePropertyOrThrow(O, to);
      to += inc;
      from += inc;
    } return O;
  };

  var u$ArrayCopyWithin = functionUncurryThis(arrayCopyWithin);
  var aTypedArray$1 = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$1 = arrayBufferViewCore.exportTypedArrayMethod;

  // `%TypedArray%.prototype.copyWithin` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.copywithin
  exportTypedArrayMethod$1('copyWithin', function copyWithin(target, start /* , end */) {
    return u$ArrayCopyWithin(aTypedArray$1(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
  });

  var $every$1 = arrayIteration.every;

  var aTypedArray$2 = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$2 = arrayBufferViewCore.exportTypedArrayMethod;

  // `%TypedArray%.prototype.every` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.every
  exportTypedArrayMethod$2('every', function every(callbackfn /* , thisArg */) {
    return $every$1(aTypedArray$2(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  });

  var aTypedArray$3 = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$3 = arrayBufferViewCore.exportTypedArrayMethod;
  var slice$1 = functionUncurryThis(''.slice);

  // V8 ~ Chrome < 59, Safari < 14.1, FF < 55, Edge <=18
  var CONVERSION_BUG = fails(function () {
    var count = 0;
    // eslint-disable-next-line es/no-typed-arrays -- safe
    new Int8Array(2).fill({ valueOf: function () { return count++; } });
    return count !== 1;
  });

  // `%TypedArray%.prototype.fill` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill
  exportTypedArrayMethod$3('fill', function fill(value /* , start, end */) {
    var length = arguments.length;
    aTypedArray$3(this);
    var actualValue = slice$1(classof(this), 0, 3) === 'Big' ? toBigInt(value) : +value;
    return functionCall(arrayFill, this, actualValue, length > 1 ? arguments[1] : undefined, length > 2 ? arguments[2] : undefined);
  }, CONVERSION_BUG);

  var arrayFromConstructorAndList = function (Constructor, list) {
    var index = 0;
    var length = lengthOfArrayLike(list);
    var result = new Constructor(length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var aTypedArrayConstructor$2 = arrayBufferViewCore.aTypedArrayConstructor;
  var getTypedArrayConstructor$1 = arrayBufferViewCore.getTypedArrayConstructor;

  // a part of `TypedArraySpeciesCreate` abstract operation
  // https://tc39.es/ecma262/#typedarray-species-create
  var typedArraySpeciesConstructor = function (originalArray) {
    return aTypedArrayConstructor$2(speciesConstructor(originalArray, getTypedArrayConstructor$1(originalArray)));
  };

  var typedArrayFromSpeciesAndList = function (instance, list) {
    return arrayFromConstructorAndList(typedArraySpeciesConstructor(instance), list);
  };

  var $filter$1 = arrayIteration.filter;


  var aTypedArray$4 = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$4 = arrayBufferViewCore.exportTypedArrayMethod;

  // `%TypedArray%.prototype.filter` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.filter
  exportTypedArrayMethod$4('filter', function filter(callbackfn /* , thisArg */) {
    var list = $filter$1(aTypedArray$4(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return typedArrayFromSpeciesAndList(this, list);
  });

  var $find$1 = arrayIteration.find;

  var aTypedArray$5 = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$5 = arrayBufferViewCore.exportTypedArrayMethod;

  // `%TypedArray%.prototype.find` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.find
  exportTypedArrayMethod$5('find', function find(predicate /* , thisArg */) {
    return $find$1(aTypedArray$5(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
  });

  var $findIndex$1 = arrayIteration.findIndex;

  var aTypedArray$6 = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$6 = arrayBufferViewCore.exportTypedArrayMethod;

  // `%TypedArray%.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.findindex
  exportTypedArrayMethod$6('findIndex', function findIndex(predicate /* , thisArg */) {
    return $findIndex$1(aTypedArray$6(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
  });

  var $forEach$1 = arrayIteration.forEach;

  var aTypedArray$7 = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$7 = arrayBufferViewCore.exportTypedArrayMethod;

  // `%TypedArray%.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.foreach
  exportTypedArrayMethod$7('forEach', function forEach(callbackfn /* , thisArg */) {
    $forEach$1(aTypedArray$7(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  });

  var $includes$1 = arrayIncludes.includes;

  var aTypedArray$8 = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$8 = arrayBufferViewCore.exportTypedArrayMethod;

  // `%TypedArray%.prototype.includes` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.includes
  exportTypedArrayMethod$8('includes', function includes(searchElement /* , fromIndex */) {
    return $includes$1(aTypedArray$8(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
  });

  var $indexOf$1 = arrayIncludes.indexOf;

  var aTypedArray$9 = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$9 = arrayBufferViewCore.exportTypedArrayMethod;

  // `%TypedArray%.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.indexof
  exportTypedArrayMethod$9('indexOf', function indexOf(searchElement /* , fromIndex */) {
    return $indexOf$1(aTypedArray$9(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
  });

  var ITERATOR$8 = wellKnownSymbol('iterator');
  var Uint8Array$1 = global_1.Uint8Array;
  var arrayValues = functionUncurryThis(es_array_iterator.values);
  var arrayKeys = functionUncurryThis(es_array_iterator.keys);
  var arrayEntries = functionUncurryThis(es_array_iterator.entries);
  var aTypedArray$a = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$a = arrayBufferViewCore.exportTypedArrayMethod;
  var TypedArrayPrototype$1 = Uint8Array$1 && Uint8Array$1.prototype;

  var GENERIC = !fails(function () {
    TypedArrayPrototype$1[ITERATOR$8].call([1]);
  });

  var ITERATOR_IS_VALUES = !!TypedArrayPrototype$1
    && TypedArrayPrototype$1.values
    && TypedArrayPrototype$1[ITERATOR$8] === TypedArrayPrototype$1.values
    && TypedArrayPrototype$1.values.name === 'values';

  var typedArrayValues = function values() {
    return arrayValues(aTypedArray$a(this));
  };

  // `%TypedArray%.prototype.entries` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.entries
  exportTypedArrayMethod$a('entries', function entries() {
    return arrayEntries(aTypedArray$a(this));
  }, GENERIC);
  // `%TypedArray%.prototype.keys` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.keys
  exportTypedArrayMethod$a('keys', function keys() {
    return arrayKeys(aTypedArray$a(this));
  }, GENERIC);
  // `%TypedArray%.prototype.values` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.values
  exportTypedArrayMethod$a('values', typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: 'values' });
  // `%TypedArray%.prototype[@@iterator]` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype-@@iterator
  exportTypedArrayMethod$a(ITERATOR$8, typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: 'values' });

  var aTypedArray$b = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$b = arrayBufferViewCore.exportTypedArrayMethod;
  var $join = functionUncurryThis([].join);

  // `%TypedArray%.prototype.join` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.join
  exportTypedArrayMethod$b('join', function join(separator) {
    return $join(aTypedArray$b(this), separator);
  });

  /* eslint-disable es/no-array-prototype-lastindexof -- safe */






  var min$6 = Math.min;
  var $lastIndexOf = [].lastIndexOf;
  var NEGATIVE_ZERO$1 = !!$lastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
  var STRICT_METHOD$7 = arrayMethodIsStrict('lastIndexOf');
  var FORCED$5 = NEGATIVE_ZERO$1 || !STRICT_METHOD$7;

  // `Array.prototype.lastIndexOf` method implementation
  // https://tc39.es/ecma262/#sec-array.prototype.lastindexof
  var arrayLastIndexOf = FORCED$5 ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
    // convert -0 to +0
    if (NEGATIVE_ZERO$1) return functionApply($lastIndexOf, this, arguments) || 0;
    var O = toIndexedObject(this);
    var length = lengthOfArrayLike(O);
    var index = length - 1;
    if (arguments.length > 1) index = min$6(index, toIntegerOrInfinity(arguments[1]));
    if (index < 0) index = length + index;
    for (;index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
    return -1;
  } : $lastIndexOf;

  var aTypedArray$c = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$c = arrayBufferViewCore.exportTypedArrayMethod;

  // `%TypedArray%.prototype.lastIndexOf` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.lastindexof
  exportTypedArrayMethod$c('lastIndexOf', function lastIndexOf(searchElement /* , fromIndex */) {
    var length = arguments.length;
    return functionApply(arrayLastIndexOf, aTypedArray$c(this), length > 1 ? [searchElement, arguments[1]] : [searchElement]);
  });

  var $map$1 = arrayIteration.map;


  var aTypedArray$d = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$d = arrayBufferViewCore.exportTypedArrayMethod;

  // `%TypedArray%.prototype.map` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.map
  exportTypedArrayMethod$d('map', function map(mapfn /* , thisArg */) {
    return $map$1(aTypedArray$d(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {
      return new (typedArraySpeciesConstructor(O))(length);
    });
  });

  var $reduce$1 = arrayReduce.left;

  var aTypedArray$e = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$e = arrayBufferViewCore.exportTypedArrayMethod;

  // `%TypedArray%.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduce
  exportTypedArrayMethod$e('reduce', function reduce(callbackfn /* , initialValue */) {
    var length = arguments.length;
    return $reduce$1(aTypedArray$e(this), callbackfn, length, length > 1 ? arguments[1] : undefined);
  });

  var $reduceRight = arrayReduce.right;

  var aTypedArray$f = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$f = arrayBufferViewCore.exportTypedArrayMethod;

  // `%TypedArray%.prototype.reduceRight` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduceright
  exportTypedArrayMethod$f('reduceRight', function reduceRight(callbackfn /* , initialValue */) {
    var length = arguments.length;
    return $reduceRight(aTypedArray$f(this), callbackfn, length, length > 1 ? arguments[1] : undefined);
  });

  var aTypedArray$g = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$g = arrayBufferViewCore.exportTypedArrayMethod;
  var floor$5 = Math.floor;

  // `%TypedArray%.prototype.reverse` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.reverse
  exportTypedArrayMethod$g('reverse', function reverse() {
    var that = this;
    var length = aTypedArray$g(that).length;
    var middle = floor$5(length / 2);
    var index = 0;
    var value;
    while (index < middle) {
      value = that[index];
      that[index++] = that[--length];
      that[length] = value;
    } return that;
  });

  var RangeError$2 = global_1.RangeError;
  var Int8Array$3 = global_1.Int8Array;
  var Int8ArrayPrototype$1 = Int8Array$3 && Int8Array$3.prototype;
  var $set = Int8ArrayPrototype$1 && Int8ArrayPrototype$1.set;
  var aTypedArray$h = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$h = arrayBufferViewCore.exportTypedArrayMethod;

  var WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS = !fails(function () {
    // eslint-disable-next-line es/no-typed-arrays -- required for testing
    var array = new Uint8ClampedArray(2);
    functionCall($set, array, { length: 1, 0: 3 }, 1);
    return array[1] !== 3;
  });

  // https://bugs.chromium.org/p/v8/issues/detail?id=11294 and other
  var TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS && arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS && fails(function () {
    var array = new Int8Array$3(2);
    array.set(1);
    array.set('2', 1);
    return array[0] !== 0 || array[1] !== 2;
  });

  // `%TypedArray%.prototype.set` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.set
  exportTypedArrayMethod$h('set', function set(arrayLike /* , offset */) {
    aTypedArray$h(this);
    var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
    var src = toObject(arrayLike);
    if (WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS) return functionCall($set, this, src, offset);
    var length = this.length;
    var len = lengthOfArrayLike(src);
    var index = 0;
    if (len + offset > length) throw RangeError$2('Wrong length');
    while (index < len) this[offset + index] = src[index++];
  }, !WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);

  var aTypedArray$i = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$i = arrayBufferViewCore.exportTypedArrayMethod;

  var FORCED$6 = fails(function () {
    // eslint-disable-next-line es/no-typed-arrays -- required for testing
    new Int8Array(1).slice();
  });

  // `%TypedArray%.prototype.slice` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice
  exportTypedArrayMethod$i('slice', function slice(start, end) {
    var list = arraySlice$1(aTypedArray$i(this), start, end);
    var C = typedArraySpeciesConstructor(this);
    var index = 0;
    var length = list.length;
    var result = new C(length);
    while (length > index) result[index] = list[index++];
    return result;
  }, FORCED$6);

  var $some$1 = arrayIteration.some;

  var aTypedArray$j = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$j = arrayBufferViewCore.exportTypedArrayMethod;

  // `%TypedArray%.prototype.some` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.some
  exportTypedArrayMethod$j('some', function some(callbackfn /* , thisArg */) {
    return $some$1(aTypedArray$j(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  });

  var aTypedArray$k = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$k = arrayBufferViewCore.exportTypedArrayMethod;
  var Uint16Array = global_1.Uint16Array;
  var nativeSort$1 = Uint16Array && functionUncurryThis(Uint16Array.prototype.sort);

  // WebKit
  var ACCEPT_INCORRECT_ARGUMENTS = !!nativeSort$1 && !(fails(function () {
    nativeSort$1(new Uint16Array(2), null);
  }) && fails(function () {
    nativeSort$1(new Uint16Array(2), {});
  }));

  var STABLE_SORT$1 = !!nativeSort$1 && !fails(function () {
    // feature detection can be too slow, so check engines versions
    if (engineV8Version) return engineV8Version < 74;
    if (engineFfVersion) return engineFfVersion < 67;
    if (engineIsIeOrEdge) return true;
    if (engineWebkitVersion) return engineWebkitVersion < 602;

    var array = new Uint16Array(516);
    var expected = Array(516);
    var index, mod;

    for (index = 0; index < 516; index++) {
      mod = index % 4;
      array[index] = 515 - index;
      expected[index] = index - 2 * mod + 3;
    }

    nativeSort$1(array, function (a, b) {
      return (a / 4 | 0) - (b / 4 | 0);
    });

    for (index = 0; index < 516; index++) {
      if (array[index] !== expected[index]) return true;
    }
  });

  var getSortCompare$1 = function (comparefn) {
    return function (x, y) {
      if (comparefn !== undefined) return +comparefn(x, y) || 0;
      // eslint-disable-next-line no-self-compare -- NaN check
      if (y !== y) return -1;
      // eslint-disable-next-line no-self-compare -- NaN check
      if (x !== x) return 1;
      if (x === 0 && y === 0) return 1 / x > 0 && 1 / y < 0 ? 1 : -1;
      return x > y;
    };
  };

  // `%TypedArray%.prototype.sort` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort
  exportTypedArrayMethod$k('sort', function sort(comparefn) {
    if (comparefn !== undefined) aCallable(comparefn);
    if (STABLE_SORT$1) return nativeSort$1(this, comparefn);

    return arraySort(aTypedArray$k(this), getSortCompare$1(comparefn));
  }, !STABLE_SORT$1 || ACCEPT_INCORRECT_ARGUMENTS);

  var aTypedArray$l = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$l = arrayBufferViewCore.exportTypedArrayMethod;

  // `%TypedArray%.prototype.subarray` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.subarray
  exportTypedArrayMethod$l('subarray', function subarray(begin, end) {
    var O = aTypedArray$l(this);
    var length = O.length;
    var beginIndex = toAbsoluteIndex(begin, length);
    var C = typedArraySpeciesConstructor(O);
    return new C(
      O.buffer,
      O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
      toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex)
    );
  });

  var Int8Array$4 = global_1.Int8Array;
  var aTypedArray$m = arrayBufferViewCore.aTypedArray;
  var exportTypedArrayMethod$m = arrayBufferViewCore.exportTypedArrayMethod;
  var $toLocaleString = [].toLocaleString;

  // iOS Safari 6.x fails here
  var TO_LOCALE_STRING_BUG = !!Int8Array$4 && fails(function () {
    $toLocaleString.call(new Int8Array$4(1));
  });

  var FORCED$7 = fails(function () {
    return [1, 2].toLocaleString() != new Int8Array$4([1, 2]).toLocaleString();
  }) || !fails(function () {
    Int8Array$4.prototype.toLocaleString.call([1, 2]);
  });

  // `%TypedArray%.prototype.toLocaleString` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring
  exportTypedArrayMethod$m('toLocaleString', function toLocaleString() {
    return functionApply(
      $toLocaleString,
      TO_LOCALE_STRING_BUG ? arraySlice$1(aTypedArray$m(this)) : aTypedArray$m(this),
      arraySlice$1(arguments)
    );
  }, FORCED$7);

  var exportTypedArrayMethod$n = arrayBufferViewCore.exportTypedArrayMethod;




  var Uint8Array$2 = global_1.Uint8Array;
  var Uint8ArrayPrototype = Uint8Array$2 && Uint8Array$2.prototype || {};
  var arrayToString = [].toString;
  var join$1 = functionUncurryThis([].join);

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = function toString() {
      return join$1(this);
    };
  }

  var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString;

  // `%TypedArray%.prototype.toString` method
  // https://tc39.es/ecma262/#sec-%typedarray%.prototype.tostring
  exportTypedArrayMethod$n('toString', arrayToString, IS_NOT_ARRAY_METHOD);

  var JxonAsync = /*#__PURE__*/function () {
    function JxonAsync(_zipApi) {
      _classCallCheck(this, JxonAsync);
      /** @type {JSZip} */
      this._zipApi = _zipApi;
      /** @type {Map} - path -> xmlFileReference */
      this._index = Object.entries(this._zipApi.files).reduce(function (index, _ref) {
        var _ref2 = _slicedToArray(_ref, 2),
          path = _ref2[0],
          fileReference = _ref2[1];
        return index.set(path, fileReference);
      }, new Map());
      /** @type {{
       *          jxons: Map.<string,VisioJxon>,
       *          images: Map.<string,VisioImage>,
       *     }} */
      this.cache = {
        jxons: new Map(),
        images: new Map()
      };
    }
    _createClass(JxonAsync, [{
      key: "getFileReference",
      value: function getFileReference(absolutePath) {
        return this._index.get(absolutePath);
      }

      /**
       * @throws
       * @param {string} absolutePath
       * @returns {Promise<VisioJxon>}
       */
    }, {
      key: "getJxonAsync",
      value: function () {
        var _getJxonAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(absolutePath) {
          var cachedValue, startTime, fileReference, xmlString, jxon;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  cachedValue = this.cache.jxons.get(absolutePath);
                  if (!cachedValue) {
                    _context.next = 4;
                    break;
                  }
                  debug.log('used cached copy of JXON: ' + "%c".concat(absolutePath, " "), 'color: orange;');
                  return _context.abrupt("return", cachedValue);
                case 4:
                  startTime = new Date().getTime(); // extension
                  assertSupportedFile(absolutePath);

                  // // file exists on ZipApi
                  // if (!this._index.has(absolutePath))
                  //     logAndThrow('404 File not found.', { absolutePath });
                  fileReference = this.getFileReference(absolutePath);
                  if (fileReference) {
                    _context.next = 9;
                    break;
                  }
                  return _context.abrupt("return", null);
                case 9:
                  _context.next = 11;
                  return fileReference.async('string');
                case 11:
                  xmlString = _context.sent;
                  jxon = jxonFromXmlString(xmlString);
                  this.cache.jxons.set(absolutePath, jxon);
                  debug.log('read XML and parse to JXON took: ' + "".concat(new Date().getTime() - startTime, "ms %c").concat(absolutePath, " "), 'color: orange;');
                  return _context.abrupt("return", jxon);
                case 16:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));
        function getJxonAsync(_x) {
          return _getJxonAsync.apply(this, arguments);
        }
        return getJxonAsync;
      }() /**
           * @param {string} absolutePath
           * @returns {Promise<VisioImage>}
           */
    }, {
      key: "getImageAsync",
      value: function () {
        var _getImageAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(absolutePath) {
          var cachedValue, startTime, fileReference, base64, imagePattern, _absolutePath$match, _absolutePath$match2, file, extension, dataBase64, image;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  cachedValue = this.cache.images.get(absolutePath);
                  if (!cachedValue) {
                    _context2.next = 4;
                    break;
                  }
                  debug.log('used cached copy of image: ' + "%c".concat(absolutePath, " "), 'color: orange;');
                  return _context2.abrupt("return", cachedValue);
                case 4:
                  startTime = new Date().getTime();
                  fileReference = this.getFileReference(absolutePath);
                  if (fileReference) {
                    _context2.next = 8;
                    break;
                  }
                  return _context2.abrupt("return", null);
                case 8:
                  _context2.next = 10;
                  return fileReference.async('base64');
                case 10:
                  base64 = _context2.sent;
                  //TODO miky ignore some extensions from parsing?
                  imagePattern = /([^/]+\.(jpeg|png|[a-zA-Z]*))$/;
                  _absolutePath$match = absolutePath.match(imagePattern), _absolutePath$match2 = _slicedToArray(_absolutePath$match, 3), file = _absolutePath$match2[1], extension = _absolutePath$match2[2];
                  dataBase64 = "data:image/".concat(extension, ";base64,") + base64;
                  image = {
                    absolutePath: absolutePath,
                    file: file,
                    extension: extension,
                    base64: dataBase64
                  };
                  this.cache.images.set(absolutePath, image);
                  debug.log('read image and encode to base64 took: ' + "".concat(new Date().getTime() - startTime, "ms %c").concat(absolutePath, " "), 'color: orange;');
                  return _context2.abrupt("return", image);
                case 18:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));
        function getImageAsync(_x2) {
          return _getImageAsync.apply(this, arguments);
        }
        return getImageAsync;
      }()
    }]);
    return JxonAsync;
  }();

  /**
   * @param {string} xmlString
   * @returns {JXONTree}
   */
  function jxonFromXmlString(xmlString) {
    var parser = new DOMParser(); // only available in some newer browsers
    var doc = parser.parseFromString(xmlString, 'application/xml');
    return new JXONTree(doc.documentElement, [VisioJxonShapeKey.Text]);
  }

  /**
   * @throws
   * @param {string} path
   * @returns {boolean}
   */
  function assertSupportedFile(path) {
    var parsablePattern = /(\.xml|\.rels)$/;
    if (!path || !parsablePattern.test(path)) debug.log('Can\'t convert to JXON (file extension doesn\'t match)', path);
  }

  /**
   *
   * @param {string} relativePath
   * @param {string} referencePath
   * @param {number} [levelUp]
   * @returns {string}
   */
  function getTargetAbsolutePath(relativePath, referencePath) {
    var levelUp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var toLastSlashPattern = /^(.*\/)[^/]?/;
    var oneLevelUp = /^(.*\/)(.*\/)[^/]+$/;
    var twoLevelsUp = /^(.*\/)(.*\/)(.*\/)[^/]+$/;
    var pattern = {
      0: toLastSlashPattern,
      1: oneLevelUp,
      2: twoLevelsUp
    }[levelUp];
    var candidate = referencePath === '/' ? relativePath : referencePath.match(pattern)[1] + relativePath;
    // path normalizer
    var normalized = normalizePath(candidate);
    return normalized;
  }

  /**
   * example:
   * from: visio/pages/../media/image1.jpeg
   * to: visio/media/image1.jpeg
   * @param {string} path
   * @returns {string}
   */
  function normalizePath(path) {
    var parts = path.split('/');
    for (var i = parts.length - 1; i >= 0; i--) {
      var actual = parts[i];
      if (actual === '..') {
        // remove two items and continue
        parts.splice(i - 1, 2);
        i--;
      }
    }
    return parts.join('/');
  }

  /**
   * @param {VisioJxon} relationshipOrArrayOfJxons
   * @param {string} basePath
   * @returns {*}
   */
  function getRelationShipsMap(_ref) {
    var relationshipOrArrayOfJxons = _ref.relationshipOrArrayOfJxons,
      basePath = _ref.basePath;
    var arrayOfRelationshipJxons = toArray(relationshipOrArrayOfJxons);
    arrayOfRelationshipJxons.forEach(function (relationshipJxon) {
      return assertIsRelationshipJxon();
    });
    return arrayOfRelationshipJxons.reduce(function (relationshipsMap, relationshipJxon) {
      // type
      var type = relationshipJxon[VisioJxonRelationKey.Type];
      if (!VisioRelationSchemaToType.hasOwnProperty(type)) {
        debug.log("Unknown Relation Type \"".concat(type, "\""), {
          relationshipJxon: relationshipJxon
        });
        return relationshipsMap;
      }

      // targetFileRelativePath
      var targetFileRelativePath = relationshipJxon[VisioJxonRelationKey.Target];
      var targetFileAbsolutePath = getTargetAbsolutePath(targetFileRelativePath, basePath);
      var id = relationshipJxon[VisioJxonRelationKey.Id];
      var idNumber = relationshipToNumber(id);
      var debugType = VisioRelationSchemaToType[type];
      var item = {
        id: idNumber,
        targetFile: {
          relativePath: targetFileRelativePath,
          absolutePath: targetFileAbsolutePath
          // jxon: JXONMap[targetFileAbsolutePath],
        },

        debugType: debugType
      };

      // first of type
      if (!relationshipsMap.has(debugType)) relationshipsMap.set(debugType, new Map());
      // add item
      relationshipsMap.get(debugType).set(idNumber, item);
      return relationshipsMap;
    }, new Map());
  }

  /**
   * @this {Visio}
   * @param {Map} documentRelationsMap
   * @param {VisioRelationType} relationType
   * @return {string|null}
   */
  function getSingleRecordPath(documentRelationsMap, relationType) {
    var singleRecordRelationMapItem = documentRelationsMap.get(relationType);
    if (!singleRecordRelationMapItem) return null;
    var documentRelation = getSingleRecord(singleRecordRelationMapItem);
    return documentRelation.targetFile.absolutePath;
  }
  function getRelsPath(absolutePath) {
    return absolutePath.replace( /*#__PURE__*/_wrapRegExp(/^(.*?)([^/]*?)$/, {
      basePath: 1,
      filename: 2
    }), '$<basePath>_rels/$<filename>.rels');
  }

  /**
   * @throws
   * @param {VisioRelationMap} singleRecordRelationMap
   * @returns {VisioRelation}
   */
  function getSingleRecord(singleRecordRelationMap) {
    if (singleRecordRelationMap.size !== 1) debug.log('Is not single record JXON', {
      singleRecordRelationMap: singleRecordRelationMap
    });
    return singleRecordRelationMap.values().next().value;
  }

  // /**
  //  * @param {JXONTree} relationJxon
  //  * @param {VisioRelationType} type
  //  * @returns {VisioRelationMap}
  //  */
  // export function getParsedRelation(relationJxon, { type = null }) {
  //     assertIsRelationshipJxon(relationJxon, { type });
  //
  //
  //     return relationJxon;
  // }

  /**
   * @this {Visio}
   * @returns {Promise<void>}
   */
  function getTopRelationsMap() {
    return _getTopRelationsMap.apply(this, arguments);
  }

  /**
   * @this {Visio}
   * @returns {Promise<void>}
   */
  function _getTopRelationsMap() {
    _getTopRelationsMap = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var topRelations;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.getJxonAsync('_rels/.rels');
            case 2:
              topRelations = _context.sent;
              return _context.abrupt("return", getRelationShipsMap({
                relationshipOrArrayOfJxons: topRelations.Relationship,
                basePath: '/'
              }));
            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));
    return _getTopRelationsMap.apply(this, arguments);
  }
  function getDocumentRelationsMap() {
    return _getDocumentRelationsMap.apply(this, arguments);
  }
  function _getDocumentRelationsMap() {
    _getDocumentRelationsMap = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var documentRelations;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.getJxonAsync('visio/_rels/document.xml.rels');
            case 2:
              documentRelations = _context2.sent;
              return _context2.abrupt("return", getRelationShipsMap({
                relationshipOrArrayOfJxons: documentRelations.Relationship,
                basePath: 'visio/'
              }));
            case 4:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));
    return _getDocumentRelationsMap.apply(this, arguments);
  }

  // `Object.fromEntries` method
  // https://github.com/tc39/proposal-object-from-entries
  _export({ target: 'Object', stat: true }, {
    fromEntries: function fromEntries(iterable) {
      var obj = {};
      iterate(iterable, function (k, v) {
        createProperty(obj, k, v);
      }, { AS_ENTRIES: true });
      return obj;
    }
  });

  /**
   * @property {Visio} _visio
   * @property {string} _xmlPath
   * @property {VisioRelationMap} _rels
   */
  var VisioRelObject = /*#__PURE__*/function (_VisioObject) {
    _inherits(VisioRelObject, _VisioObject);
    var _super = _createSuper(VisioRelObject);
    function VisioRelObject(init) {
      var prefixList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();
      _classCallCheck(this, VisioRelObject);
      prefixList.add(VisioAttribute.rels);
      prefixList.add(VisioAttribute.xmlPath);
      return _super.call(this, init, prefixList);
    }

    /**
     * @returns {Promise<VisioRelation>}
     */
    _createClass(VisioRelObject, [{
      key: "getDefaultAttributes",
      value: function getDefaultAttributes() {
        return _objectSpread2(_objectSpread2({}, _get(_getPrototypeOf(VisioRelObject.prototype), "getDefaultAttributes", this).call(this)), {}, {
          rels: null,
          xmlPath: null
        });
      }
    }, {
      key: "getRelsMapCachedAsync",
      value: function () {
        var _getRelsMapCachedAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          var opt,
            _args = arguments;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  opt = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};
                  // no path
                  if (!this.xmlPath) debug.log('no xml path');

                  // cached
                  if (!this.rels) {
                    _context.next = 4;
                    break;
                  }
                  return _context.abrupt("return", /** @type {VisioRelation} */this.rels);
                case 4:
                  _context.next = 6;
                  return this.getRelsMapAsync.call(this.archive, this.xmlPath, opt);
                case 6:
                  this.rels = _context.sent;
                  return _context.abrupt("return", this.rels);
                case 8:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));
        function getRelsMapCachedAsync() {
          return _getRelsMapCachedAsync.apply(this, arguments);
        }
        return getRelsMapCachedAsync;
      }() /**
           * @param baseAbsolutePath
           * @returns {Promise<VisioRelationMap>}
           */
    }, {
      key: "getRelsMapAsync",
      value: function () {
        var _getRelsMapAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(baseAbsolutePath) {
          var opt,
            overrideRels,
            relsPath,
            pagesRelsJxon,
            doc,
            _args2 = arguments;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  opt = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};
                  overrideRels = opt.overrideRels;
                  relsPath = getRelsPath(baseAbsolutePath);
                  if (!overrideRels) {
                    _context2.next = 11;
                    break;
                  }
                  doc = this.document; // failsafe but this should never happen
                  if (!(!doc || !doc.masters || !doc.masters.map)) {
                    _context2.next = 7;
                    break;
                  }
                  return _context2.abrupt("return", null);
                case 7:
                  pagesRelsJxon = {
                    '@xmlns': XmlSchema.Relationships,
                    Relationship: []
                  };

                  // rebuild relationships from scratch, push all existing masters
                  doc.masters.map.forEach(function (master, index) {
                    pagesRelsJxon.Relationship.push({
                      '@Id': "rId".concat(index + 1),
                      '@Type': XmlSchema.VisioMasterRelationship,
                      '@Target': master._xmlPath.replace('visio', '..')
                    });
                  });
                  _context2.next = 14;
                  break;
                case 11:
                  _context2.next = 13;
                  return this.getJxonAsync(relsPath);
                case 13:
                  pagesRelsJxon = _context2.sent;
                case 14:
                  if (pagesRelsJxon) {
                    _context2.next = 16;
                    break;
                  }
                  return _context2.abrupt("return", null);
                case 16:
                  return _context2.abrupt("return", getRelationShipsMap({
                    relationshipOrArrayOfJxons: pagesRelsJxon.Relationship,
                    basePath: baseAbsolutePath
                  }));
                case 17:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));
        function getRelsMapAsync(_x) {
          return _getRelsMapAsync.apply(this, arguments);
        }
        return getRelsMapAsync;
      }()
    }, {
      key: "rels",
      get: function get() {
        return this._rels;
      },
      set: function set(rels) {
        this._rels = rels;
      }
    }, {
      key: "xmlPath",
      get: function get() {
        return this._xmlPath;
      },
      set: function set(rels) {
        this._xmlPath = rels;
      }
    }]);
    return VisioRelObject;
  }(VisioObject);

  /**
   * @property {Map} _colors
   * @property {Promise<VisioRelations>} _relations
   * @property {Pages} _pages
   * @property {VisioDocumentSettings} documentSettings
   * @property {VisioFaceNames} faceNames
   * @property {VisioStyleSheets} styleSheets
   * @property {VisioDocumentSheet} documentSheet
   * @property {boolean} languageDependent
   */
  var VisioDocument = /*#__PURE__*/function (_VisioRelObject) {
    _inherits(VisioDocument, _VisioRelObject);
    var _super = _createSuper(VisioDocument);
    function VisioDocument() {
      var init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, VisioDocument);
      return _super.call(this, init, new Set([VisioAttribute.colors, VisioAttribute.relations, VisioAttribute.pages]));
    }

    // Methods
    _createClass(VisioDocument, [{
      key: "getDefaultAttributes",
      value: function getDefaultAttributes() {
        return _objectSpread2(_objectSpread2({}, _get(_getPrototypeOf(VisioDocument.prototype), "getDefaultAttributes", this).call(this)), {}, {
          _colors: null,
          _relations: null,
          _pages: null,
          documentSettings: null,
          faceNames: null,
          styleSheets: null,
          documentSheet: null,
          languageDependent: true,
          masterShapesMap: new Map()
        });
      }
    }, {
      key: "getMasters",
      value: function getMasters() {
        return _toConsumableArray(this.masters.map.values());
      }
    }, {
      key: "getMastersIdMap",
      value: function getMastersIdMap() {
        return Object.fromEntries(this.masters.map);
      }
    }, {
      key: "getMastersNameMap",
      value: function getMastersNameMap() {
        var masters = this.getMasters();
        return masters.reduce(function (acc, master) {
          acc[master.name] = master;
          return acc;
        }, {});
      }
    }, {
      key: "getPages",
      value: function getPages() {
        return this.pages.toArray();
      }
    }, {
      key: "getPage",
      value: function getPage(pageId) {
        return this.pages.get(pageId);
      }

      // Properties
    }, {
      key: "name",
      get: function get() {
        var documentSheet = this.documentSheet,
          languageDependent = this.languageDependent;
        return languageDependent ? documentSheet.name :
        // language-dependent name
        documentSheet.nameU; // language-independent name
      }
    }, {
      key: "colors",
      get: function get() {
        return this._colors;
      },
      set: function set(colors) {
        this._colors = colors;
      }
    }, {
      key: "pages",
      get: function get() {
        return this._pages;
      },
      set: function set(pages) {
        this._pages = pages;
      }
    }, {
      key: "documentSettings",
      get: function get() {
        return this._documentSettings;
      },
      set: function set(documentSettings) {
        this._documentSettings = documentSettings;
      }
    }, {
      key: "faceNames",
      set: function set(faceNames) {
        this._faceNames = faceNames;
      }
    }, {
      key: "styleSheets",
      get: function get() {
        return this._styleSheets;
      },
      set: function set(styleSheets) {
        this._styleSheets = styleSheets;
      }
    }, {
      key: "documentSheet",
      get: function get() {
        return this._documentSheet;
      },
      set: function set(documentSheet) {
        this._documentSheet = documentSheet;
      }
    }]);
    return VisioDocument;
  }(VisioRelObject);

  /**
   * @property {Array.<Page>} _pages
   */
  var VisioPages = /*#__PURE__*/function (_VisioRelObject) {
    _inherits(VisioPages, _VisioRelObject);
    var _super = _createSuper(VisioPages);
    function VisioPages(init) {
      var _this;
      _classCallCheck(this, VisioPages);
      _this = _super.call(this, init, new Set([
      // underscore prefixed (later)
      VisioAttribute.pages]));

      // all prefixed "_"
      Object.entries(init).forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
          key = _ref2[0],
          value = _ref2[1];
        // prefix
        key = "_".concat(key);
        return _this[key] = value;
      });
      return _this;
    }
    _createClass(VisioPages, [{
      key: "getDefaultAttributes",
      value: function getDefaultAttributes() {
        return _objectSpread2(_objectSpread2({}, _get(_getPrototypeOf(VisioPages.prototype), "getDefaultAttributes", this).call(this)), {}, {
          pages: new Map()
        });
      }
    }, {
      key: "get",
      value: function get(id) {
        return this._pages.get(id) || null;
      }
    }, {
      key: "add",
      value: function add(page) {
        var nextIndex = this._pages.size;
        page.index = nextIndex;
        this._pages.set(page.id, page);
      }
    }, {
      key: "toArray",
      value: function toArray() {
        return _toConsumableArray(this._pages.values());
      }
    }]);
    return VisioPages;
  }(VisioRelObject);

  // `Number.parseInt` method
  // https://tc39.es/ecma262/#sec-number.parseint
  // eslint-disable-next-line es/no-number-parseint -- required for testing
  _export({ target: 'Number', stat: true, forced: Number.parseInt != numberParseInt }, {
    parseInt: numberParseInt
  });

  // `parseFloat` method
  // https://tc39.es/ecma262/#sec-parsefloat-string
  _export({ global: true, forced: parseFloat != numberParseFloat }, {
    parseFloat: numberParseFloat
  });

  function fetchImage(_x) {
    return _fetchImage.apply(this, arguments);
  }
  function _fetchImage() {
    _fetchImage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(url) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", new Promise(function (resolve, reject) {
                var img = new Image();
                img.onload = function () {
                  resolve(img);
                };
                img.onerror = function () {
                  reject('Could not load image with given URL.', url);
                };
                img.src = url;
              }));
            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _fetchImage.apply(this, arguments);
  }

  function normalizeColor(color) {
    if (color === 'none' || color === 'transparent') return color;
    var ctx = document.createElement('canvas').getContext('2d');
    ctx.fillStyle = color;
    return ctx.fillStyle;
  }
  var ALPHA_REGEX = /^rgba\(.*,(.+)\)/;
  function isColorTransparent(color) {
    if (typeof color !== 'string') return false;
    if (color === 'transparent') return true;
    var match = ALPHA_REGEX.exec(color);
    if (!match) return false;
    var _match = _slicedToArray(match, 2),
      alpha = _match[1];
    if (parseFloat(alpha) === 0) return true;
    return false;
  }

  function pathToGeometryRows(path, matrix) {
    var rows = [];
    path.segments.forEach(function (segment) {
      var type;
      var points = [jointjs.V.transformPoint(segment.end, matrix)];
      switch (segment.type) {
        case 'M':
          type = 'MoveTo';
          break;
        case 'L':
        case 'Z':
          type = 'LineTo';
          break;
        case 'C':
          type = 'LineTo';
          points = segment.toPoints();
          points.forEach(function (point, index) {
            points[index] = jointjs.V.transformPoint(point, matrix);
          });
          break;
      }

      // TODO: extract this
      // creating a Visio cell can be a helper function
      points.forEach(function (point) {
        rows.push({
          '@IX': (rows.length + 1).toString(),
          '@T': type,
          Cell: [{
            '@N': VisioCellName.X,
            '@V': pixelsToInches(point.x).toString()
          }, {
            '@N': VisioCellName.Y,
            '@V': pixelsToInches(point.y).toString()
          }]
        });
      });
    });
    return rows;
  }

  var skipGeometry = {
    G: true,
    TITLE: true,
    TSPAN: true,
    TEXTPATH: true
  };
  function exportNode(_x, _x2, _x3, _x4, _x5) {
    return _exportNode.apply(this, arguments);
  }
  function _exportNode() {
    _exportNode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(vNode, jxon, cellView, transformation, pageRels) {
      var tagName;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              tagName = vNode.tagName();
              if (!(tagName === 'TEXT')) {
                _context.next = 5;
                break;
              }
              exportSVGText(vNode, jxon);
              _context.next = 11;
              break;
            case 5:
              if (!(tagName === 'IMAGE')) {
                _context.next = 10;
                break;
              }
              _context.next = 8;
              return exportSVGImage(vNode, jxon, pageRels);
            case 8:
              _context.next = 11;
              break;
            case 10:
              if (!(tagName in skipGeometry)) {
                // Visio Geometry section is created only for certain types of tags
                exportSVGGeometryElement(vNode, jxon, cellView, transformation);
              }
            case 11:
              // map element attributes to Visio style Cells
              enrichShapeJXONWithStyles(vNode, jxon);
              return _context.abrupt("return", jxon);
            case 13:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _exportNode.apply(this, arguments);
  }
  function isNodeExportable(vNode) {
    var _vNode$node$getBoundi = vNode.node.getBoundingClientRect(),
      width = _vNode$node$getBoundi.width,
      height = _vNode$node$getBoundi.height;
    if (width === 0 && height === 0) {
      return false;
    }
    return true;
  }
  function exportSVGText(vNode, jxon) {
    var node = vNode.node;
    var text = Array.from(node.childNodes).map(function (node) {
      return node.textContent;
    }).join('\n');
    if (text.length === 0) return;
    jxon.Text = {
      cp: {
        '@IX': '0',
        '@textPlaceholder': text
      }
    };
    var character = {
      '@N': VisioSectionType.Character,
      Row: [{
        '@IX': '0',
        Cell: []
      }]
    };
    var cells = character.Row[0].Cell;

    // add text styling attributes
    var fontSize = vNode.attr('font-size');
    if (fontSize) {
      cells.push({
        '@N': VisioCellName.Size,
        '@V': pixelsToInches(fontSize).toString()
      });
    }
    var fontFamily = vNode.attr('font-family');
    if (fontFamily) {
      cells.push({
        '@N': VisioCellName.Font,
        '@V': fontFamily
      });
    }
    var fill = vNode.attr('fill');
    if (fill) {
      if (fill === 'transparent') ; else {
        cells.push({
          '@N': VisioCellName.Color,
          '@V': normalizeColor(fill)
        });
      }
    }
    jxon.Section.push(character);

    // zero out margins
    // TODO: candidate for default page settings
    jxon.Cell.push({
      '@N': VisioCellName.LeftMargin,
      '@V': '0'
    }, {
      '@N': VisioCellName.RightMargin,
      '@V': '0'
    }, {
      '@N': VisioCellName.TopMargin,
      '@V': '0'
    }, {
      '@N': VisioCellName.BottomMargin,
      '@V': '0'
    });
  }
  function exportSVGImage(_x6, _x7, _x8) {
    return _exportSVGImage.apply(this, arguments);
  }
  function _exportSVGImage() {
    _exportSVGImage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(vNode, jxon, pageRels) {
      var url, dataUrl, extension, img, canvas, ctx, isDataURL, mimeType, id, name, bbox, widthRatio, heightRatio, aspectRatio, width, height;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              url = vNode.attr('xlink:href') || vNode.attr('href');
              if (url) {
                _context2.next = 3;
                break;
              }
              return _context2.abrupt("return");
            case 3:
              dataUrl = url;
              extension = 'png'; // todo: make it work async
              _context2.next = 7;
              return fetchImage(url);
            case 7:
              img = _context2.sent;
              canvas = document.createElement('canvas');
              canvas.width = img.width;
              canvas.height = img.height;
              ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0, img.width, img.height);
              _context2.prev = 13;
              dataUrl = canvas.toDataURL('image/png');
              _context2.next = 25;
              break;
            case 17:
              _context2.prev = 17;
              _context2.t0 = _context2["catch"](13);
              // e.g. Tainted Image
              debug.log("Can not convert an image (".concat(url, ") to data URI:"), _context2.t0);
              isDataURL = /^data:((?:\w+\/(?:(?!;).)+)?)((?:;[\w\W]*?[^;])*),(.+)$/.test(url);
              if (isDataURL) {
                _context2.next = 23;
                break;
              }
              return _context2.abrupt("return", jxon);
            case 23:
              mimeType = url.split(',')[0].split(':')[1].split(';')[0];
              if (mimeType === 'image/svg+xml') {
                extension = 'svg';
              }
            case 25:
              id = pageRels.jxon.Relationship.length + 1;
              name = "image".concat(id, ".").concat(extension); // Visio images are inserted on Page as ForeignData element with a relationship ID
              jxon.ForeignData = {
                '@ForeignType': 'Bitmap',
                '@CompressionType': extension.toUpperCase(),
                Rel: {
                  '@r:id': "rId".concat(id.toString())
                }
              };

              // todo: find better place for this
              // override Shape type to foreign
              jxon['@Type'] = VisioShapeType.Foreign;

              // todo: handle image size as it's not necessarily same as container size
              // add image specific cells
              bbox = vNode.getBBox();
              if (vNode.attr('preserveAspectRatio') !== 'none') {
                // todo: handle other preserveAspectRatio values
                // for now assuming anything other then explicit `none` is xMidYMid
                widthRatio = bbox.width / img.width;
                heightRatio = bbox.height / img.height;
                aspectRatio = widthRatio <= heightRatio ? widthRatio : heightRatio;
                width = img.width * aspectRatio;
                height = img.height * aspectRatio;
                bbox = new jointjs.g.Rect({
                  x: (bbox.width - width) / 2,
                  y: (bbox.height - height) / 2,
                  width: width,
                  height: height
                });
              }
              jxon.Cell.push({
                '@N': VisioCellName.ImgOffsetX,
                '@V': pixelsToInches(bbox.x).toString()
              }, {
                '@N': VisioCellName.ImgOffsetY,
                '@V': pixelsToInches(bbox.y).toString()
              }, {
                '@N': VisioCellName.ImgWidth,
                '@V': pixelsToInches(bbox.width).toString()
              }, {
                '@N': VisioCellName.ImgHeight,
                '@V': pixelsToInches(bbox.height).toString()
              });

              // page relationship XML file contains info about all relationships
              // these are referenced by ID and point to a relationship by Type and Target
              pageRels.jxon.Relationship.push({
                '@Id': "rId".concat(id),
                '@Type': XmlSchema.DocumentImageRelationships,
                '@Target': "../media/".concat(name)
              });

              // data collection holds information about image urls
              // for later conversion to dataURI
              pageRels.data.push({
                name: name,
                url: dataUrl
              });
            case 34:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[13, 17]]);
    }));
    return _exportSVGImage.apply(this, arguments);
  }
  function exportSVGGeometryElement(vNode, jxon, view, transformation) {
    var model = view.model;
    var node = vNode.node;
    var isElementRootNode = model.isElement() && view.el === node;
    var bbox = isElementRootNode ? new jointjs.g.Rect(model.attributes.size) : view.getNodeBoundingRect(node);
    var scaleX = transformation.scaleX,
      scaleY = transformation.scaleY;
    var pathMatrix = jointjs.V.createSVGMatrix().scale(scaleX, scaleY).translate(0, bbox.height).flipY();
    if (!isElementRootNode) {
      pathMatrix = pathMatrix.translate(-bbox.x, -bbox.y);
    }
    var d = jointjs.V.normalizePathData(vNode.convertToPathData());
    var path = new jointjs.g.Path(d);

    // TODO: what is the correct ID here?
    var geometryIX = 1;
    var geometryJXON = {
      '@IX': geometryIX.toString(),
      '@N': VisioSectionType.Geometry,
      'Cell': [],
      'Row': pathToGeometryRows(path, pathMatrix)
    };
    geometryIX++;

    // add Geometry section specific styles
    enrichGeometryJXONWithStyles(vNode, geometryJXON);
    jxon.Section.push(geometryJXON);
  }
  function enrichShapeJXONWithStyles(vNode, jxon) {
    var _window$getComputedSt = window.getComputedStyle(vNode.node),
      stroke = _window$getComputedSt.stroke,
      fill = _window$getComputedSt.fill,
      strokeWidth = _window$getComputedSt.strokeWidth;
    var cells = jxon.Cell;

    // Support `fill-opacity`, `stroke-opacity`, rgba color with alpha

    // FillForegnd
    if (fill === 'none' || fill === isColorTransparent(fill)) {
      cells.push({
        '@N': 'FillForegndTrans',
        '@V': '1'
      });
    } else {
      cells.push({
        '@N': 'FillForegnd',
        '@V': normalizeColor(fill)
      });
    }

    // LineColor
    if (stroke === 'none' || isColorTransparent(stroke)) {
      cells.push({
        '@N': 'LineColorTrans',
        '@V': '1'
      });
    } else {
      cells.push({
        '@N': 'LineColor',
        '@V': normalizeColor(stroke)
      });
    }

    // LineWeight
    if (strokeWidth) {
      cells.push({
        '@N': 'LineWeight',
        '@V': String(pixelsToInches(parseFloat(strokeWidth)))
      });
    }
  }
  function enrichGeometryJXONWithStyles(vNode, jxon) {
    var _window$getComputedSt2 = window.getComputedStyle(vNode.node),
      stroke = _window$getComputedSt2.stroke,
      fill = _window$getComputedSt2.fill;
    var cells = jxon.Cell;
    if (fill) {
      cells.push({
        '@N': 'NoFill',
        '@V': fill === 'none' ? '1' : '0'
      });
    }
    if (stroke) {
      cells.push({
        '@N': 'NoLine',
        '@V': '0'
      });
    }
  }

  function forEachDescendant(_x, _x2) {
    return _forEachDescendant.apply(this, arguments);
  }
  function _forEachDescendant() {
    _forEachDescendant = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(vel, fn) {
      var descendants, descendant;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              descendants = vel.children();
            case 1:
              if (!(descendants.length > 0)) {
                _context.next = 9;
                break;
              }
              descendant = descendants.shift();
              _context.next = 5;
              return fn(descendant);
            case 5:
              if (!_context.sent) {
                _context.next = 7;
                break;
              }
              // use `push` for breadth-first search
              // use `unshift` for depth-first search
              descendants.unshift.apply(descendants, _toConsumableArray(descendant.children()));
            case 7:
              _context.next = 1;
              break;
            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _forEachDescendant.apply(this, arguments);
  }

  function exportCellViewAsShape(_x, _x2) {
    return _exportCellViewAsShape.apply(this, arguments);
  }
  function _exportCellViewAsShape() {
    _exportCellViewAsShape = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(cellView, pageRels) {
      var isLink;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (isNodeExportable(cellView.vel)) {
                _context.next = 2;
                break;
              }
              return _context.abrupt("return", null);
            case 2:
              isLink = cellView.model.isLink();
              if (!isLink) {
                _context.next = 9;
                break;
              }
              _context.next = 6;
              return exportLinkViewAsShape(cellView, pageRels);
            case 6:
              return _context.abrupt("return", _context.sent);
            case 9:
              _context.next = 11;
              return exportElementViewAsShape(cellView, pageRels);
            case 11:
              return _context.abrupt("return", _context.sent);
            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _exportCellViewAsShape.apply(this, arguments);
  }
  function exportElementViewAsShape(_x3, _x4) {
    return _exportElementViewAsShape.apply(this, arguments);
  }
  function _exportElementViewAsShape() {
    _exportElementViewAsShape = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(elementView, pageRels) {
      var model, bbox, origin, angle, matrix;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              model = elementView.model;
              bbox = model.getBBox();
              origin = bbox.center();
              angle = elementView.rotatableNode ? 0 : model.angle();
              matrix = jointjs.V.createSVGMatrix().rotate(angle);
              return _context2.abrupt("return", exportCellViewNodes(elementView, pageRels, bbox, matrix, origin));
            case 6:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _exportElementViewAsShape.apply(this, arguments);
  }
  function exportLinkViewAsShape(_x5, _x6) {
    return _exportLinkViewAsShape.apply(this, arguments);
  }
  function _exportLinkViewAsShape() {
    _exportLinkViewAsShape = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(linkView, pageRels) {
      var bbox, matrix;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              bbox = linkView.getConnection().bbox();
              matrix = jointjs.V.createSVGMatrix().translate(-bbox.x, -bbox.y);
              return _context3.abrupt("return", exportCellViewNodes(linkView, pageRels, bbox, matrix));
            case 3:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _exportLinkViewAsShape.apply(this, arguments);
  }
  function exportCellViewNodes(_x7, _x8, _x9, _x10, _x11) {
    return _exportCellViewNodes.apply(this, arguments);
  }
  function _exportCellViewNodes() {
    _exportCellViewNodes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(cellView, pageRels, bbox, matrix, origin) {
      var paper, vRoot, paperBBox, transformation, baseShapeJXON, rootShapeJXON, rootId, JXONCache, bboxCache, matrixCache;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              paper = cellView.paper, vRoot = cellView.vel;
              paperBBox = paper.getArea();
              transformation = jointjs.V.decomposeMatrix(matrix);
              baseShapeJXON = getBaseShapeFromNode(vRoot, bbox, paperBBox, {
                transformation: transformation,
                origin: origin
              }); // enrich rootNode
              _context5.next = 6;
              return exportNode(vRoot, baseShapeJXON, cellView, transformation, pageRels);
            case 6:
              rootShapeJXON = _context5.sent;
              // cache
              rootId = vRoot.id;
              JXONCache = _defineProperty({}, rootId, rootShapeJXON);
              bboxCache = _defineProperty({}, rootId, bbox);
              matrixCache = {}; // create grouped Shapes for each root Child
              _context5.next = 13;
              return forEachDescendant(vRoot, /*#__PURE__*/function () {
                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(vChild) {
                  var childNode, childId, parentNode, parentId, parentBBox, parentJXON, parentMatrix, childMatrix, isEmpty, tagName, childBBox, childTransformation, childShapeJXON;
                  return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                    while (1) {
                      switch (_context4.prev = _context4.next) {
                        case 0:
                          if (isNodeExportable(vChild)) {
                            _context4.next = 2;
                            break;
                          }
                          return _context4.abrupt("return", false);
                        case 2:
                          childNode = vChild.node;
                          childId = jointjs.V.ensureId(vChild);
                          parentNode = childNode.parentNode;
                          parentId = parentNode.id;
                          parentBBox = bboxCache[parentId];
                          parentJXON = JXONCache[parentId];
                          parentMatrix = matrixCache[parentId];
                          childMatrix = vChild.getTransformToElement(parentNode);
                          if (parentMatrix) {
                            childMatrix = parentMatrix.multiply(childMatrix);
                          }
                          isEmpty = vChild.children().length === 0;
                          tagName = vChild.tagName();
                          if (!(tagName === 'G')) {
                            _context4.next = 20;
                            break;
                          }
                          if (!isEmpty) {
                            _context4.next = 16;
                            break;
                          }
                          return _context4.abrupt("return", false);
                        case 16:
                          bboxCache[childId] = parentBBox;
                          JXONCache[childId] = parentJXON;
                          matrixCache[childId] = childMatrix;
                          return _context4.abrupt("return", true);
                        case 20:
                          childBBox = bboxCache[childNode.id] = cellView.getNodeBoundingRect(childNode); // create Visio Shape from a node
                          childTransformation = jointjs.V.decomposeMatrix(childMatrix);
                          childShapeJXON = getBaseShapeFromNode(vChild, childBBox, parentBBox, {
                            transformation: childTransformation
                          });
                          _context4.next = 25;
                          return exportNode(vChild, childShapeJXON, cellView, childTransformation, pageRels);
                        case 25:
                          // add Visio Shape to it's immediate parent
                          parentJXON.Shapes.Shape.push(childShapeJXON);
                          // this Visio Shape can become parent shape of others
                          if (!isEmpty) {
                            JXONCache[childId] = childShapeJXON;
                          }
                          // execute recursively if there are more children nested
                          return _context4.abrupt("return", isEmpty);
                        case 28:
                        case "end":
                          return _context4.stop();
                      }
                    }
                  }, _callee4);
                }));
                return function (_x12) {
                  return _ref2.apply(this, arguments);
                };
              }());
            case 13:
              return _context5.abrupt("return", rootShapeJXON);
            case 14:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));
    return _exportCellViewNodes.apply(this, arguments);
  }
  function exportLinkViewAsConnectShape(linkView) {
    var model = linkView.model,
      paper = linkView.paper;
    if (!model.isLink()) {
      throw new Error('Can not export dia.Element as a connection.');
    }
    if (!isNodeExportable(linkView.vel)) {
      return null;
    }
    var path = linkView.getConnection();
    if (!path) return null;
    var paperBBox = paper.getArea();
    var bbox = path.bbox();
    var jxon = getBaseShapeFromConnection(linkView, bbox);
    var matrix = jointjs.V.createSVGMatrix().translate(0, bbox.height).flipY().translate(-bbox.x, -bbox.y);

    // todo: loads of duplicates
    var geometryJXON = {
      '@IX': '0',
      '@N': VisioSectionType.Geometry,
      Cell: [{
        '@N': VisioCellName.NoFill,
        '@V': '1'
      }, {
        '@N': VisioCellName.NoLine,
        '@V': '0'
      }, {
        '@N': VisioCellName.NoShow,
        '@V': '0'
      }, {
        '@N': VisioCellName.NoSnap,
        '@V': '0'
      }, {
        '@N': VisioCellName.NoQuickDrag,
        '@V': '0'
      }],
      Row: pathToGeometryRows(path, matrix)
    };

    // todo: what to do with this?
    // add Geometry section specific styles
    // enrichGeometryJXONWithStyles(vNode, geometryJXON);

    jxon.Section.push(geometryJXON);
    return jxon;
  }

  // todo: new Connect();
  // todo: implement values: https://docs.microsoft.com/en-us/office/vba/api/visio.connect.topart
  // todo: add connect points to source and target at beginning and end of link and use part 100 for it
  // what's path absolute point vs source/target position ??
  function exportLinkAsConnects(link, visioShapeJXON, elementShapesMap) {
    var sheetId = visioShapeJXON['@ID'].toString();
    var source = link.source();
    var sourceShape = elementShapesMap.get(source.id);
    var target = link.target();
    var targetShape = elementShapesMap.get(target.id);
    return [{
      '@FromSheet': sheetId,
      '@FromCell': VisioCellName.BeginX,
      '@FromPart': '3',
      '@ToSheet': sourceShape ? sourceShape['@ID'].toString() : sheetId,
      '@ToCell': sourceShape ? VisioCellName.PinX : VisioCellName.EndX,
      '@ToPart': sourceShape ? '3' : '9'
    }, {
      '@FromSheet': sheetId,
      '@FromCell': VisioCellName.EndX,
      '@FromPart': '3',
      '@ToSheet': targetShape ? targetShape['@ID'].toString() : sheetId,
      '@ToCell': targetShape ? VisioCellName.PinX : VisioCellName.BeginX,
      '@ToPart': targetShape ? '3' : '9'
    }];
  }
  function getBaseShape(vel) {
    var type = vel.tagName() === 'G' ? VisioShapeType.Group : VisioShapeType.Shape;

    // defaults
    var shape = {
      '@ID': jointjs.util.uniqueId(),
      '@LineStyle': '3',
      '@Type': type,
      Cell: [{
        '@N': VisioCellName.ResizeMode,
        '@V': '0'
      }],
      Section: [],
      Shapes: {
        Shape: []
      }
    };
    return shape;
  }
  function getBaseShapeFromConnection(linkView, bbox) {
    var vel = linkView.vel,
      sourcePoint = linkView.sourcePoint,
      targetPoint = linkView.targetPoint,
      paper = linkView.paper;
    var shape = getBaseShape(vel);
    var _paper$getArea = paper.getArea(),
      height = _paper$getArea.height;

    // adjust to Visio coordinate space
    var begin = new jointjs.g.Point(sourcePoint);
    begin.y = height - begin.y;
    var end = new jointjs.g.Point(targetPoint);
    end.y = height - end.y;

    // add 1-D specific Visio Cells
    shape.Cell.unshift({
      '@N': VisioCellName.BeginX,
      '@V': "".concat(pixelsToInches(begin.x)),
      '@F': '_WALKGLUE(BegTrigger,EndTrigger,WalkPreference)'
    }, {
      '@N': VisioCellName.BeginY,
      '@V': "".concat(pixelsToInches(begin.y)),
      '@F': '_WALKGLUE(BegTrigger,EndTrigger,WalkPreference)'
    }, {
      '@N': VisioCellName.EndX,
      '@V': "".concat(pixelsToInches(end.x)),
      '@F': '_WALKGLUE(EndTrigger,BegTrigger,WalkPreference)'
    }, {
      '@N': VisioCellName.EndY,
      '@V': "".concat(pixelsToInches(end.y)),
      '@F': '_WALKGLUE(EndTrigger,BegTrigger,WalkPreference)'
    }, {
      '@N': VisioCellName.Width,
      '@V': "".concat(pixelsToInches(end.x - begin.x)),
      '@F': 'GUARD(EndX-BeginX)'
    }, {
      '@N': VisioCellName.Height,
      '@V': "".concat(pixelsToInches(bbox.height)),
      '@F': "GUARD(".concat(pixelsToInches(bbox.height), ")")
    }, {
      '@N': VisioCellName.Angle,
      '@V': '0',
      '@F': 'GUARD(0 deg)'
    }, {
      '@N': VisioCellName.PinX,
      '@V': "".concat(pixelsToInches((begin.x + end.x) / 2)),
      '@F': 'GUARD((BeginX+EndX)/2))'
    }, {
      '@N': VisioCellName.PinY,
      '@V': "".concat(pixelsToInches((begin.y + end.y) / 2)),
      '@F': 'GUARD((BeginY+EndY)/2)'
    }, {
      '@N': VisioCellName.LocPinX,
      '@V': "".concat(pixelsToInches((end.x - begin.x) / 2)),
      '@F': 'GUARD(Width*0.5)'
    }, {
      '@N': VisioCellName.LocPinY,
      '@V': "".concat(pixelsToInches(bbox.height / 2)),
      '@F': 'GUARD(Height*0.5)'
    }, {
      '@N': VisioCellName.FlipX,
      '@V': '0',
      '@F': 'GUARD(FALSE)'
    }, {
      '@N': VisioCellName.FlipY,
      '@V': '0',
      '@F': 'GUARD(FALSE)'
    });
    return shape;
  }
  function getBaseShapeFromNode(vel, bbox, parentBBox, _ref) {
    var _ref$transformation = _ref.transformation,
      transformation = _ref$transformation === void 0 ? {} : _ref$transformation,
      _ref$origin = _ref.origin,
      origin = _ref$origin === void 0 ? new jointjs.g.Point(0, 0) : _ref$origin;
    var _transformation$trans = transformation.translateX,
      translateX = _transformation$trans === void 0 ? 0 : _transformation$trans,
      _transformation$trans2 = transformation.translateY,
      translateY = _transformation$trans2 === void 0 ? 0 : _transformation$trans2,
      _transformation$rotat = transformation.rotation,
      rotation = _transformation$rotat === void 0 ? 0 : _transformation$rotat,
      _transformation$scale = transformation.scaleX,
      scaleX = _transformation$scale === void 0 ? 1 : _transformation$scale,
      _transformation$scale2 = transformation.scaleY,
      scaleY = _transformation$scale2 === void 0 ? 1 : _transformation$scale2;
    var width = bbox.width,
      height = bbox.height;
    var center = bbox.center();
    if (scaleX !== 1 || scaleY !== 1) {
      center.scale(scaleX, scaleY);
      width *= scaleX;
      height *= scaleY;
    }
    if (rotation !== 0) {
      center.rotate(origin, -rotation);
    }
    var locPin = new jointjs.g.Point(width / 2, height / 2);
    var pin = new jointjs.g.Point(translateX + center.x, parentBBox.height - (center.y + translateY));
    var shape = getBaseShape(vel);
    shape.Cell.unshift({
      '@N': VisioCellName.PinX,
      '@V': "".concat(pixelsToInches(pin.x))
    }, {
      '@N': VisioCellName.PinY,
      '@V': "".concat(pixelsToInches(pin.y))
    }, {
      '@N': VisioCellName.Width,
      '@V': "".concat(pixelsToInches(width))
    }, {
      '@N': VisioCellName.Height,
      '@V': "".concat(pixelsToInches(height))
    }, {
      '@N': VisioCellName.LocPinX,
      '@V': "".concat(pixelsToInches(locPin.x))
    }, {
      '@N': VisioCellName.LocPinY,
      '@V': "".concat(pixelsToInches(locPin.y))
    }, {
      '@N': VisioCellName.Angle,
      '@V': "".concat(jointjs.g.toRad(-rotation))
    });
    return shape;
  }

  function convertPaperToVisioShapes(_x, _x2, _x3, _x4, _x5, _x6) {
    return _convertPaperToVisioShapes.apply(this, arguments);
  }
  function _convertPaperToVisioShapes() {
    _convertPaperToVisioShapes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(paper, jxon, page, pageRels, exportElement, exportLink) {
      var graph, elementShapesMap, elements, isCustomElementExport, templates, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, element, elementView, shapeJXON, linkShapes, linkConnects, links, isCustomLinkExport, _iteratorAbruptCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, link, linkView, linkJXON, connects;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              graph = paper.model; // ELEMENTS
              // convert joint Elements into Visio Shapes
              elementShapesMap = new Map();
              elements = graph.getElements();
              isCustomElementExport = typeof exportElement === 'function';
              templates = {
                fromConnection: function () {
                  var _fromConnection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(linkView) {
                    return _regeneratorRuntime().wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            return _context.abrupt("return", defaultLinkExport(linkView, elementShapesMap));
                          case 1:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  }));
                  function fromConnection(_x17) {
                    return _fromConnection.apply(this, arguments);
                  }
                  return fromConnection;
                }(),
                fromNodes: function () {
                  var _fromNodes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(cellView) {
                    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            return _context2.abrupt("return", defaultElementExport(cellView, pageRels));
                          case 1:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  }));
                  function fromNodes(_x18) {
                    return _fromNodes.apply(this, arguments);
                  }
                  return fromNodes;
                }()
              };
              _iteratorAbruptCompletion = false;
              _didIteratorError = false;
              _context3.prev = 7;
              _iterator = _asyncIterator(elements);
            case 9:
              _context3.next = 11;
              return _iterator.next();
            case 11:
              if (!(_iteratorAbruptCompletion = !(_step = _context3.sent).done)) {
                _context3.next = 30;
                break;
              }
              element = _step.value;
              elementView = element.findView(paper);
              shapeJXON = void 0;
              if (!isCustomElementExport) {
                _context3.next = 21;
                break;
              }
              _context3.next = 18;
              return customElementExport(elementView, page, exportElement, templates);
            case 18:
              shapeJXON = _context3.sent;
              _context3.next = 24;
              break;
            case 21:
              _context3.next = 23;
              return defaultElementExport(elementView, pageRels);
            case 23:
              shapeJXON = _context3.sent;
            case 24:
              if (shapeJXON) {
                _context3.next = 26;
                break;
              }
              return _context3.abrupt("continue", 27);
            case 26:
              elementShapesMap.set(element.id, shapeJXON);
            case 27:
              _iteratorAbruptCompletion = false;
              _context3.next = 9;
              break;
            case 30:
              _context3.next = 36;
              break;
            case 32:
              _context3.prev = 32;
              _context3.t0 = _context3["catch"](7);
              _didIteratorError = true;
              _iteratorError = _context3.t0;
            case 36:
              _context3.prev = 36;
              _context3.prev = 37;
              if (!(_iteratorAbruptCompletion && _iterator["return"] != null)) {
                _context3.next = 41;
                break;
              }
              _context3.next = 41;
              return _iterator["return"]();
            case 41:
              _context3.prev = 41;
              if (!_didIteratorError) {
                _context3.next = 44;
                break;
              }
              throw _iteratorError;
            case 44:
              return _context3.finish(41);
            case 45:
              return _context3.finish(36);
            case 46:
              // LINKS
              // convert joint Links into Visio Shapes & Connects
              linkShapes = [];
              linkConnects = [];
              links = graph.getLinks();
              isCustomLinkExport = typeof exportLink === 'function';
              _iteratorAbruptCompletion2 = false;
              _didIteratorError2 = false;
              _context3.prev = 52;
              _iterator2 = _asyncIterator(links);
            case 54:
              _context3.next = 56;
              return _iterator2.next();
            case 56:
              if (!(_iteratorAbruptCompletion2 = !(_step2 = _context3.sent).done)) {
                _context3.next = 75;
                break;
              }
              link = _step2.value;
              linkView = link.findView(paper);
              linkJXON = void 0;
              if (!isCustomLinkExport) {
                _context3.next = 66;
                break;
              }
              _context3.next = 63;
              return customLinkExport(linkView, page, exportLink, templates);
            case 63:
              linkJXON = _context3.sent;
              _context3.next = 67;
              break;
            case 66:
              linkJXON = defaultLinkExport(linkView, elementShapesMap);
            case 67:
              if (linkJXON) {
                _context3.next = 69;
                break;
              }
              return _context3.abrupt("continue", 72);
            case 69:
              connects = exportLinkAsConnects(link, linkJXON, elementShapesMap);
              linkConnects.push.apply(linkConnects, _toConsumableArray(connects));
              linkShapes.push(linkJXON);
            case 72:
              _iteratorAbruptCompletion2 = false;
              _context3.next = 54;
              break;
            case 75:
              _context3.next = 81;
              break;
            case 77:
              _context3.prev = 77;
              _context3.t1 = _context3["catch"](52);
              _didIteratorError2 = true;
              _iteratorError2 = _context3.t1;
            case 81:
              _context3.prev = 81;
              _context3.prev = 82;
              if (!(_iteratorAbruptCompletion2 && _iterator2["return"] != null)) {
                _context3.next = 86;
                break;
              }
              _context3.next = 86;
              return _iterator2["return"]();
            case 86:
              _context3.prev = 86;
              if (!_didIteratorError2) {
                _context3.next = 89;
                break;
              }
              throw _iteratorError2;
            case 89:
              return _context3.finish(86);
            case 90:
              return _context3.finish(81);
            case 91:
              // JXON

              jxon.Shapes = {
                Shape: [].concat(_toConsumableArray(elementShapesMap.values()), linkShapes)
              };
              jxon.Connects = {
                Connect: [].concat(linkConnects)
              };
              return _context3.abrupt("return", jxon);
            case 94:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, null, [[7, 32, 36, 46], [37,, 41, 45], [52, 77, 81, 91], [82,, 86, 90]]);
    }));
    return _convertPaperToVisioShapes.apply(this, arguments);
  }
  function customElementExport(_x7, _x8, _x9, _x10) {
    return _customElementExport.apply(this, arguments);
  }
  function _customElementExport() {
    _customElementExport = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(elementView, page, exportElement, templates) {
      var vsdShape;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return exportElement(elementView, page, templates);
            case 2:
              vsdShape = _context4.sent;
              if (vsdShape) {
                _context4.next = 5;
                break;
              }
              return _context4.abrupt("return", null);
            case 5:
              return _context4.abrupt("return", vsdShape.jxon);
            case 6:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));
    return _customElementExport.apply(this, arguments);
  }
  function defaultElementExport(_x11, _x12) {
    return _defaultElementExport.apply(this, arguments);
  }
  function _defaultElementExport() {
    _defaultElementExport = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(elementView, pageRels) {
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              return _context5.abrupt("return", exportCellViewAsShape(elementView, pageRels));
            case 1:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));
    return _defaultElementExport.apply(this, arguments);
  }
  function customLinkExport(_x13, _x14, _x15, _x16) {
    return _customLinkExport.apply(this, arguments);
  }
  function _customLinkExport() {
    _customLinkExport = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(linkView, page, exportLink, templates) {
      var vsdShape, linkJXON, defaultConnectShape, overrideCells;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return exportLink(linkView, page, templates);
            case 2:
              vsdShape = _context6.sent;
              if (vsdShape) {
                _context6.next = 5;
                break;
              }
              return _context6.abrupt("return", null);
            case 5:
              linkJXON = vsdShape.jxon; // override begin/end cells in case source or target is missing
              // in that case Visio will need a point to set for source/target of link
              defaultConnectShape = exportLinkViewAsConnectShape(linkView);
              overrideCells = ['BeginX', 'BeginY', 'EndX', 'EndY'];
              overrideCells.forEach(function (cellName) {
                var defaultCell = defaultConnectShape.Cell.find(function (cell) {
                  return cell['@N'] === cellName;
                });
                if (defaultCell) {
                  var originalIndex = linkJXON.Cell.findIndex(function (cell) {
                    return cell['@N'] === cellName;
                  });
                  if (originalIndex > -1) {
                    linkJXON.Cell.splice(originalIndex, 1, defaultCell);
                  } else {
                    linkJXON.Cell.push(defaultCell);
                  }
                }
              });
              return _context6.abrupt("return", linkJXON);
            case 10:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }));
    return _customLinkExport.apply(this, arguments);
  }
  function defaultLinkExport(linkView, elementShapesMap) {
    var link = linkView.model;
    var linkJXON = exportLinkViewAsConnectShape(linkView);
    linkJXON['@Type'] = VisioShapeType.Shape;
    var source = link.source();
    var target = link.target();
    var sourceShape = elementShapesMap.get(source.id);
    var targetShape = elementShapesMap.get(target.id);
    var sourceRef = "".concat(sourceShape ? 'Sheet' : 'Dynamic connector', ".").concat(sourceShape ? sourceShape['@ID'] : linkJXON['@ID']);
    var targetRef = "".concat(targetShape ? 'Sheet' : 'Dynamic connector', ".").concat(targetShape ? targetShape['@ID'] : linkJXON['@ID']);
    linkJXON.Cell.push({
      '@N': VisioCellName.BegTrigger,
      '@V': sourceShape ? '2' : '1',
      '@F': "_XFTRIGGER(".concat(sourceRef, "!EventXFMod)")
    }, {
      '@N': VisioCellName.EndTrigger,
      '@V': targetShape ? '2' : '1',
      '@F': "_XFTRIGGER(".concat(targetRef, "!EventXFMod)")
    }, {
      '@N': VisioCellName.ObjType,
      '@V': '2'
    });
    return linkJXON;
  }

  var ArchiveEntityType = {
    XML: 'xml',
    IMAGE: 'image'
  };

  // Rappid paper is being converted into a map of entities that will be
  // added to the Visio archive
  function paperToArchiveEntries(_x, _x2) {
    return _paperToArchiveEntries.apply(this, arguments);
  }
  function _paperToArchiveEntries() {
    _paperToArchiveEntries = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(paper, page) {
      var _ref,
        exportElement,
        exportLink,
        map,
        archive,
        pageRels,
        pageFileName,
        contentTypes,
        deferredImages,
        _iterator,
        _step,
        _loop,
        _args = arguments;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _ref = _args.length > 2 && _args[2] !== undefined ? _args[2] : {}, exportElement = _ref.exportElement, exportLink = _ref.exportLink;
              // [key:fileArchivePath]: { type: ArchiveEntityType, content: string | Blob }
              map = {};
              archive = page.archive; // pageRels hold raw relationship data for Rel elements as well as
              // data used to build a static file in the archive
              pageRels = {
                data: [],
                jxon: {
                  Relationship: []
                }
              };
              _context.t0 = ArchiveEntityType.XML;
              _context.next = 7;
              return buildCustomPropsXML(archive);
            case 7:
              _context.t1 = _context.sent;
              map['docProps/custom.xml'] = {
                type: _context.t0,
                content: _context.t1
              };
              pageFileName = page.fileName; // pageXML - currently the only project page with all shapes
              _context.t2 = ArchiveEntityType.XML;
              _context.next = 13;
              return buildPageXML(paper, page, pageRels, exportElement, exportLink);
            case 13:
              _context.t3 = _context.sent;
              map["visio/pages/".concat(pageFileName, ".xml")] = {
                type: _context.t2,
                content: _context.t3
              };
              _context.t4 = ArchiveEntityType.XML;
              _context.next = 18;
              return buildPagesXML(paper, page, archive);
            case 18:
              _context.t5 = _context.sent;
              map['visio/pages/pages.xml'] = {
                type: _context.t4,
                content: _context.t5
              };
              _context.t6 = ArchiveEntityType.XML;
              _context.next = 23;
              return buildPageRelsXML(pageRels.jxon);
            case 23:
              _context.t7 = _context.sent;
              map["visio/pages/_rels/".concat(pageFileName, ".xml.rels")] = {
                type: _context.t6,
                content: _context.t7
              };
              _context.next = 27;
              return archive.getJxonAsync('[Content_Types].xml');
            case 27:
              contentTypes = _context.sent;
              map['[Content_Types].xml'] = {
                type: ArchiveEntityType.XML,
                content: buildContentTypesXML(contentTypes)
              };

              // convert all images into blobs and push them to the entity map
              deferredImages = [];
              _iterator = _createForOfIteratorHelper(pageRels.data);
              try {
                _loop = function _loop() {
                  var entry = _step.value;
                  deferredImages.push(new Promise(function (resolve, reject) {
                    jointjs.util.imageToDataUri(entry.url, function (err, dataURI) {
                      if (err) {
                        // todo: what should be done if it failed?
                        reject();
                      }
                      var blob;
                      try {
                        blob = jointjs.util.dataUriToBlob(dataURI);
                      } catch (e) {
                        debug.log("Can not convert an image to blob: ".concat(e));
                      }
                      if (blob) {
                        map["visio/media/".concat(entry.name)] = {
                          type: ArchiveEntityType.IMAGE,
                          content: blob
                        };
                      }
                      resolve();
                    });
                  }));
                };
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  _loop();
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
              return _context.abrupt("return", Promise.all(deferredImages).then(function () {
                return map;
              }));
            case 33:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _paperToArchiveEntries.apply(this, arguments);
  }
  function buildCustomPropsXML(_x3) {
    return _buildCustomPropsXML.apply(this, arguments);
  } // todo: abstract and unify buildXML(jxon, schema, qualifiedName, doctype)
  function _buildCustomPropsXML() {
    _buildCustomPropsXML = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(archive) {
      var jxon, pidMax, recalcProp, baseXML, xml, docString;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return archive.getJxonAsync('docProps/custom.xml');
            case 2:
              jxon = _context2.sent;
              pidMax = Math.max.apply(Math, jxon.property.map(function (prop) {
                return Number.parseInt(prop['@pid']);
              })); // where does this ID come from?
              recalcProp = {
                '@fmtid': '{D5CDD505-2E9C-101B-9397-08002B2CF9AE}',
                '@pid': (pidMax + 1).toString(),
                '@name': 'RecalcDocument',
                'vt:bool': {
                  keyValue: 'true'
                }
              };
              jxon.property.push(recalcProp);
              baseXML = document.implementation.createDocument(XmlSchema.CustomProperties, 'Properties', null);
              xml = jxon2Xml(jxon, baseXML, {
                vt: XmlSchema.DocPropsVTypes
              });
              docString = new XMLSerializer().serializeToString(xml);
              return _context2.abrupt("return", '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + docString);
            case 10:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _buildCustomPropsXML.apply(this, arguments);
  }
  function buildContentTypesXML(_x4) {
    return _buildContentTypesXML.apply(this, arguments);
  }
  function _buildContentTypesXML() {
    _buildContentTypesXML = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(jxon) {
      var extensions, defaultExtensions, contentTypesXML, xml, docString;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              extensions = jxon.Default.map(function (type) {
                return type['@Extension'];
              }); // todo: how to properly attach svg?
              defaultExtensions = [{
                name: 'emf',
                type: 'image/x-emf'
              }, {
                name: 'png',
                type: 'image/png'
              }, {
                name: 'gif',
                type: 'image/gif'
              }, {
                name: 'jpeg',
                type: 'image/jpeg'
              }, {
                name: 'svg',
                type: 'image/svg+xml'
              }];
              defaultExtensions.forEach(function (defaultExtension) {
                if (extensions.indexOf(defaultExtension.name) === -1) {
                  jxon.Default.unshift({
                    '@Extension': defaultExtension.name,
                    '@ContentType': defaultExtension.type
                  });
                }
              });
              contentTypesXML = document.implementation.createDocument(XmlSchema.ContentTypes, 'Types', null);
              xml = jxon2Xml(jxon, contentTypesXML, {
                xmlns: XmlSchema.ContentTypes
              });
              docString = new XMLSerializer().serializeToString(xml);
              return _context3.abrupt("return", '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + docString);
            case 7:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _buildContentTypesXML.apply(this, arguments);
  }
  function buildPageRelsXML(jxon) {
    var pageRelsXML = document.implementation.createDocument(XmlSchema.Relationships, 'Relationships', null);
    var xml = jxon2Xml(jxon, pageRelsXML, {
      xmlns: XmlSchema.Relationships
    });
    var docString = new XMLSerializer().serializeToString(xml);
    return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + docString;
  }

  // todo: resize all pages to paper size
  function buildPagesXML(_x5, _x6, _x7) {
    return _buildPagesXML.apply(this, arguments);
  }
  function _buildPagesXML() {
    _buildPagesXML = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(paper, page, archive) {
      var jxon, realPaperSize, pageJxon, cells, widthIndex, heightIndex, widthCell, heightCell, emptyXML, xml, serializer, docString;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return archive.getJxonAsync('visio/pages/pages.xml');
            case 2:
              jxon = _context4.sent;
              realPaperSize = paper.getArea();
              if (!Array.isArray(jxon.Page)) {
                jxon.Page = [jxon.Page];
              }
              pageJxon = jxon.Page.find(function (p) {
                return p['@ID'] === page.id.toString();
              });
              if (pageJxon) {
                cells = pageJxon.PageSheet.Cell;
                widthIndex = cells.findIndex(function (cell) {
                  return cell['@N'] === VisioCellName.PageWidth;
                });
                heightIndex = cells.findIndex(function (cell) {
                  return cell['@N'] === VisioCellName.PageHeight;
                });
                widthCell = {
                  '@N': VisioCellName.PageWidth,
                  '@V': pixelsToInches(realPaperSize.width).toString()
                };
                if (!Number.isNaN(widthIndex)) {
                  cells[widthIndex] = widthCell;
                } else {
                  cells.push(widthCell);
                }
                heightCell = {
                  '@N': VisioCellName.PageHeight,
                  '@V': pixelsToInches(realPaperSize.height).toString()
                };
                if (!Number.isNaN(heightIndex)) {
                  cells[heightIndex] = heightCell;
                } else {
                  cells.push(heightCell);
                }
              } else {
                debug.log("Page with id ".concat(page.id, " was not found."));
              }
              emptyXML = document.implementation.createDocument(XmlSchema.Main, 'Pages', null);
              xml = jxon2Xml(jxon, emptyXML, {
                xmlns: XmlSchema.Main,
                r: XmlSchema.DocumentRelationships
              });
              serializer = new XMLSerializer();
              docString = serializer.serializeToString(xml);
              return _context4.abrupt("return", '<?xml version="1.0" encoding="utf-8"?>' + docString);
            case 12:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));
    return _buildPagesXML.apply(this, arguments);
  }
  function buildPageXML(_x8, _x9, _x10, _x11, _x12) {
    return _buildPageXML.apply(this, arguments);
  }
  function _buildPageXML() {
    _buildPageXML = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(paper, page, pageRels, exportElement, exportLink) {
      var jxonBase, jxon, emptyXML, xml, serializer, docString;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return page.archive.getJxonAsync(page.xmlPath);
            case 2:
              jxonBase = _context5.sent;
              _context5.next = 5;
              return convertPaperToVisioShapes(paper, jxonBase, page, pageRels, exportElement, exportLink);
            case 5:
              jxon = _context5.sent;
              emptyXML = document.implementation.createDocument(XmlSchema.Main, 'PageContents', null);
              xml = jxon2Xml(jxon, emptyXML, {
                xmlns: XmlSchema.Main,
                r: XmlSchema.DocumentRelationships
              });
              serializer = new XMLSerializer();
              docString = serializer.serializeToString(xml).replace(/(<cp IX="0")(?: textPlaceholder="(.*?)")(\/>)/gm, function () {
                var _arguments = Array.prototype.slice.call(arguments),
                  cp = _arguments[1],
                  text = _arguments[2],
                  closeTag = _arguments[3];
                return cp + closeTag + text;
              });
              return _context5.abrupt("return", '<?xml version="1.0" encoding="utf-8"?>' + docString);
            case 11:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));
    return _buildPageXML.apply(this, arguments);
  }

  var _excluded$2 = ["pageSheet"];
  var VisioPage = /*#__PURE__*/function (_VisioRelObject) {
    _inherits(VisioPage, _VisioRelObject);
    var _super = _createSuper(VisioPage);
    function VisioPage() {
      var init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, VisioPage);
      return _super.call(this, init, new Set([
      // underscore prefixed (later)
      VisioAttribute.pages,
      // parent
      VisioAttribute.shapes, VisioAttribute.connects, VisioAttribute.foreignShapes, VisioAttribute.background, VisioAttribute.backPage]));
    }
    _createClass(VisioPage, [{
      key: "getDefaultAttributes",
      value: function getDefaultAttributes() {
        return _objectSpread2(_objectSpread2({}, _get(_getPrototypeOf(VisioPage.prototype), "getDefaultAttributes", this).call(this)), {}, {
          /** @type {Map<number, Shape>} */
          shapes: new Map(),
          /** @type {Map<number, Connect>} */
          connects: new Map(),
          /** @type {Pages} */
          pages: null,
          /** @type {Map<number, Shape>} */
          foreignShapes: new Map(),
          /** @type {Map<number, Shape>} */
          allShapes: new Map(),
          /** @type {Map<string, Object>} */
          cache: new Map()
        });
      }
    }, {
      key: "setAttributes",
      value: function setAttributes(_ref) {
        var pageSheet = _ref.pageSheet,
          attributes = _objectWithoutProperties(_ref, _excluded$2);
        _get(_getPrototypeOf(VisioPage.prototype), "setAttributes", this).call(this, _objectSpread2({
          pageSheet: pageSheet
        }, attributes));
        if (pageSheet) {
          this.referenceInCells();
        }
      }
    }, {
      key: "referenceInCells",
      value: function referenceInCells() {
        var pageSheet = this.pageSheet,
          archive = this.archive;
        if (!pageSheet || !pageSheet.cells) return;
        pageSheet.cells.parent = archive.document.pageSheet;
      }

      // public API
    }, {
      key: "getContent",
      value: function () {
        var _getContent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          var opts,
            pageContent,
            _args = arguments;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  opts = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};
                  pageContent = new VisioPageContent(this);
                  _context.next = 4;
                  return pageContent.loadAsync(opts);
                case 4:
                  return _context.abrupt("return", pageContent);
                case 5:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));
        function getContent() {
          return _getContent.apply(this, arguments);
        }
        return getContent;
      }() /**
           * Parse all masters related to this page
           * @returns {Promise<*>}
           */
    }, {
      key: "getMastersFromRelsAsync",
      value: function () {
        var _getMastersFromRelsAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
          var archive, document, masters, mastersRelsMap;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  archive = this.archive;
                  document = archive.document;
                  masters = document.masters; // this page has no relations
                  if (this.rels) {
                    _context2.next = 5;
                    break;
                  }
                  return _context2.abrupt("return", null);
                case 5:
                  mastersRelsMap = this.rels.get(VisioRelationType.Master);
                  if (!mastersRelsMap) {
                    _context2.next = 9;
                    break;
                  }
                  _context2.next = 9;
                  return masters.loadMasters(mastersRelsMap);
                case 9:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));
        function getMastersFromRelsAsync() {
          return _getMastersFromRelsAsync.apply(this, arguments);
        }
        return getMastersFromRelsAsync;
      }()
    }, {
      key: "background",
      get: function get() {
        return Boolean(this._background);
      }
    }, {
      key: "backPage",
      get: function get() {
        var _backPage = this._backPage;
        if (_backPage === undefined) return null;
        return _backPage;
      }
    }, {
      key: "width",
      get: function get() {
        return this.pageSheet.cells.pageWidth;
      }
    }, {
      key: "height",
      get: function get() {
        return this.pageSheet.cells.pageHeight;
      }
    }, {
      key: "pages",
      get: function get() {
        return this._pages;
      }
    }, {
      key: "fileName",
      get: function get() {
        var _exec = /^visio\/pages\/(.*)\.xml$/gm.exec(this.xmlPath),
          _exec2 = _slicedToArray(_exec, 2),
          fileName = _exec2[1];
        return fileName;
      }
    }, {
      key: "fromPaper",
      value: function () {
        var _fromPaper = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(paper) {
          var _ref2,
            _ref2$exportElement,
            exportElement,
            _ref2$exportLink,
            exportLink,
            files,
            _args3 = arguments;
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _ref2 = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {}, _ref2$exportElement = _ref2.exportElement, exportElement = _ref2$exportElement === void 0 ? null : _ref2$exportElement, _ref2$exportLink = _ref2.exportLink, exportLink = _ref2$exportLink === void 0 ? null : _ref2$exportLink;
                  _context3.next = 3;
                  return paperToArchiveEntries(paper, this, {
                    exportElement: exportElement,
                    exportLink: exportLink
                  });
                case 3:
                  files = _context3.sent;
                  // each entry is a file that has to be added to the final zip archive
                  this.archive.addEntries(files);
                case 5:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));
        function fromPaper(_x) {
          return _fromPaper.apply(this, arguments);
        }
        return fromPaper;
      }()
    }, {
      key: "printerPaperSize",
      get: function get() {
        var pageSheetCells = this.pageSheet.cells;
        var paperKind = pageSheetCells.paperKind,
          printPageOrientation = pageSheetCells.printPageOrientation;
        var _this$constructor$get = this.constructor.getPrinterPaperSize(paperKind),
          width = _this$constructor$get.width,
          height = _this$constructor$get.height;
        if (printPageOrientation === 2) {
          return {
            width: height,
            height: width
          };
        } else {
          return {
            width: width,
            height: height
          };
        }
      }
    }], [{
      key: "getPrinterPaperSize",
      value: function getPrinterPaperSize(vsdPaperKind) {
        var mm = function mm(_mm) {
          return toPixels(_mm, VisioUnitType.MM);
        };
        var inches = function inches(_inches) {
          return toPixels(_inches, VisioUnitType.IN);
        };
        switch (vsdPaperKind) {
          default:
          case 0: /* DMPAPER_FIRST */
          case 1:
            /* Letter 8 1/2 x 11 in               (DMPAPER_LETTER) */
            return {
              width: inches(8.5),
              height: inches(11)
            };
          case 2:
            /* Letter Small 8 1/2 x 11 in         (DMPAPER_LETTERSMALL) */
            return {
              width: inches(8.5),
              height: inches(11)
            };
          case 3:
            /* Tabloid 11 x 17 in                 (DMPAPER_TABLOID) */
            return {
              width: inches(11),
              height: inches(17)
            };
          case 4:
            /* Ledger 17 x 11 in                  (DMPAPER_LEDGER) */
            return {
              width: inches(17),
              height: inches(11)
            };
          case 5:
            /* Legal 8 1/2 x 14 in                (DMPAPER_LEGAL) */
            return {
              width: inches(8.5),
              height: inches(14)
            };
          case 6:
            /* Statement 5 1/2 x 8 1/2 in         (DMPAPER_STATEMENT) */
            return {
              width: inches(5.5),
              height: inches(8.5)
            };
          case 7:
            /* Executive 7 1/4 x 10 1/2 in        (DMPAPER_EXECUTIVE) */
            return {
              width: inches(7.25),
              height: inches(10.5)
            };
          case 8:
            /* A3 297 x 420 mm                    (DMPAPER_A3) */
            return {
              width: mm(297),
              height: mm(420)
            };
          case 9:
            /* A4 210 x 297 mm                    (DMPAPER_A4) */
            return {
              width: mm(210),
              height: mm(297)
            };
          case 10:
            /* A4 Small 210 x 297 mm              (DMPAPER_A4SMALL) */
            return {
              width: mm(210),
              height: mm(297)
            };
          case 11:
            /* A5 148 x 210 mm                    (DMPAPER_A5) */
            return {
              width: mm(148),
              height: mm(210)
            };
          case 12:
            /* B4 (JIS) 250 x 354                 (DMPAPER_B4) */
            return {
              width: mm(250),
              height: mm(354)
            };
          case 13:
            /* B5 (JIS) 182 x 257 mm              (DMPAPER_B5) */
            return {
              width: mm(182),
              height: mm(257)
            };
          case 14:
            /* Folio 8 1/2 x 13 in                (DMPAPER_FOLIO) */
            return {
              width: inches(8.5),
              height: inches(13)
            };
          case 15:
            /* Quarto 215 x 275 mm                (DMPAPER_QUARTO) */
            return {
              width: mm(215),
              height: mm(275)
            };
          case 16:
            /* 10x14 in                           (DMPAPER_10X14) */
            return {
              width: inches(10),
              height: inches(14)
            };
          case 17:
            /* 11x17 in                           (DMPAPER_11X17) */
            return {
              width: inches(11),
              height: inches(17)
            };
          case 18:
            /* Note 8 1/2 x 11 in                 (DMPAPER_NOTE) */
            return {
              width: inches(2),
              height: inches(11)
            };
          case 19:
            /* Envelope #9 3 7/8 x 8 7/8          (DMPAPER_ENV_9) */
            return {
              width: inches(3.875),
              height: inches(8.875)
            };
          case 20:
            /* Envelope #10 4 1/8 x 9 1/2         (DMPAPER_ENV_10) */
            return {
              width: inches(4.125),
              height: inches(9.5)
            };
          case 21:
            /* Envelope #11 4 1/2 x 10 3/8        (DMPAPER_ENV_11) */
            return {
              width: inches(4.5),
              height: inches(10.375)
            };
          case 22:
            /* Envelope #12 4.75 x 11           (DMPAPER_ENV_12) */
            //TODO check value
            return {
              width: inches(4),
              height: inches(11)
            };
          case 23:
            /* Envelope #14 5 x 11 1/2            (DMPAPER_ENV_14) */
            return {
              width: inches(5),
              height: inches(11.5)
            };
          case 24:
            /* C size sheet                       (DMPAPER_CSHEET) */
            //TODO C0?
            return {
              width: mm(917),
              height: mm(1297)
            };
          case 25:
            /* D size sheet                       (DMPAPER_DSHEET) */
            //TODO D0?
            return {
              width: mm(771),
              height: mm(1090)
            };
          case 26:
            /* E size sheet                       (DMPAPER_ESHEET) */
            //TODO E0?
            return {
              width: mm(878),
              height: mm(1242)
            };
          case 27:
            /* Envelope DL 110 x 220mm            (DMPAPER_ENV_DL) */
            return {
              width: mm(110),
              height: mm(220)
            };
          case 28:
            /* Envelope C5 162 x 229 mm           (DMPAPER_ENV_C5) */
            return {
              width: mm(162),
              height: mm(229)
            };
          case 29:
            /* Envelope C3  324 x 458 mm          (DMPAPER_ENV_C3) */
            return {
              width: mm(324),
              height: mm(458)
            };
          case 30:
            /* Envelope C4  229 x 324 mm          (DMPAPER_ENV_C4) */
            return {
              width: mm(229),
              height: mm(324)
            };
          case 31:
            /* Envelope C6  114 x 162 mm          (DMPAPER_ENV_C6) */
            return {
              width: mm(114),
              height: mm(162)
            };
          case 32:
            /* Envelope C65 114 x 229 mm          (DMPAPER_ENV_C65) */
            return {
              width: mm(114),
              height: mm(229)
            };
          case 33:
            /* Envelope B4  250 x 353 mm          (DMPAPER_ENV_B4) */
            return {
              width: mm(250),
              height: mm(353)
            };
          case 34:
            /* Envelope B5  176 x 250 mm          (DMPAPER_ENV_B5) */
            return {
              width: mm(176),
              height: mm(250)
            };
          case 35:
            /* Envelope B6  176 x 125 mm          (DMPAPER_ENV_B6) */
            return {
              width: mm(176),
              height: mm(125)
            };
          case 36:
            /* Envelope 110 x 230 mm              (DMPAPER_ENV_ITALY) */
            return {
              width: mm(110),
              height: mm(230)
            };
          case 37:
            /* Envelope Monarch 3.875 x 7.5 in    (DMPAPER_ENV_MONARCH) */
            return {
              width: inches(3.875),
              height: inches(7.5)
            };
          case 38:
            /* 6 3/4 Envelope 3 5/8 x 6 1/2 in    (DMPAPER_ENV_PERSONAL) */
            return {
              width: inches(3.625),
              height: inches(6.5)
            };
          case 39:
            /* US Std Fanfold 14 7/8 x 11 in      (DMPAPER_FANFOLD_US) */
            return {
              width: inches(14.875),
              height: inches(11)
            };
          case 40:
            /* German Std Fanfold 8 1/2 x 12 in   (DMPAPER_FANFOLD_STD_GERMAN) */
            return {
              width: inches(8.5),
              height: inches(12)
            };
          case 41:
            /* German Legal Fanfold 8 1/2 x 13 in (DMPAPER_FANFOLD_LGL_GERMAN) */
            return {
              width: inches(8.5),
              height: inches(13)
            };
          case 42:
            /* B4 (ISO) 250 x 353 mm              (DMPAPER_ISO_B4) */
            return {
              width: mm(250),
              height: mm(353)
            };
          case 43:
            /* Japanese Postcard 100 x 148 mm     (DMPAPER_JAPANESE_POSTCARD) */
            return {
              width: mm(100),
              height: mm(148)
            };
          case 44:
            /* 9 x 11 in                          (DMPAPER_9X11) */
            return {
              width: inches(9),
              height: inches(11)
            };
          case 45:
            /* 10 x 11 in                         (DMPAPER_10X11) */
            return {
              width: inches(10),
              height: inches(11)
            };
          case 46:
            /* 15 x 11 in                         (DMPAPER_15X11) */
            return {
              width: inches(15),
              height: inches(11)
            };
          case 47:
            /* Envelope Invite 220 x 220 mm       (DMPAPER_ENV_INVITE) */
            return {
              width: inches(220),
              height: inches(220)
            };
          // 48:  /* RESERVED--DO NOT USE               (DMPAPER_RESERVED_48) */
          // 49:  /* RESERVED--DO NOT USE               (DMPAPER_RESERVED_49) */
          case 50:
            /* Letter Extra 9.5 x 12 in        (DMPAPER_LETTER_EXTRA) */
            return {
              width: inches(9),
              height: inches(12)
            };
          case 51:
            /* Legal Extra 9.5 x 15 in         (DMPAPER_LEGAL_EXTRA) */
            return {
              width: inches(9),
              height: inches(15)
            };
          case 52:
            /* Tabloid Extra 11.69 x 18 in        (DMPAPER_TABLOID_EXTRA) */
            return {
              width: inches(11.69),
              height: inches(18)
            };
          case 53:
            /* A4 Extra 9.27 x 12.69 in           (DMPAPER_A4_EXTRA) */
            return {
              width: inches(9.27),
              height: inches(12.69)
            };
          case 54:
            /* Letter Transverse 8 x 11 in   (DMPAPER_LETTER_TRANSVERSE) */
            //TODO check value
            return {
              width: inches(8),
              height: inches(11)
            };
          case 55:
            /* A4 Transverse 210 x 297 mm         (DMPAPER_A4_TRANSVERSE) */
            return {
              width: mm(210),
              height: mm(297)
            };
          case 56:
            /* Letter Extra Transverse 9 x 12 in (DMPAPER_LETTER_EXTRA_TRANSVERSE) */
            return {
              width: inches(9),
              height: inches(12)
            };
          //TODO miky check value
          case 57:
            /* SuperA/SuperA/A4 227 x 356 mm      (DMPAPER_A_PLUS) */
            return {
              width: mm(227),
              height: mm(356)
            };
          case 58:
            /* SuperB/SuperB/A3 305 x 487 mm      (DMPAPER_B_PLUS) */
            return {
              width: mm(305),
              height: mm(487)
            };
          case 59:
            /* Letter Plus 8.5 x 12.69 in         (DMPAPER_LETTER_PLUS) */
            return {
              width: inches(8.5),
              height: inches(12.69)
            };
          case 60:
            /* A4 Plus 210 x 330 mm               (DMPAPER_A4_PLUS) */
            return {
              width: mm(210),
              height: mm(330)
            };
          case 61:
            /* A5 Transverse 148 x 210 mm         (DMPAPER_A5_TRANSVERSE) */
            return {
              width: mm(148),
              height: mm(210)
            };
          case 62:
            /* B5 (JIS) Transverse 182 x 257 mm   (DMPAPER_B5_TRANSVERSE) */
            return {
              width: mm(182),
              height: mm(257)
            };
          case 63:
            /* A3 Extra 322 x 445 mm              (DMPAPER_A3_EXTRA) */
            return {
              width: mm(322),
              height: mm(445)
            };
          case 64:
            /* A5 Extra 174 x 235 mm              (DMPAPER_A5_EXTRA) */
            return {
              width: mm(174),
              height: mm(235)
            };
          case 65:
            /* B5 (ISO) Extra 201 x 276 mm        (DMPAPER_B5_EXTRA) */
            return {
              width: mm(201),
              height: mm(276)
            };
          case 66:
            /* A2 420 x 594 mm                    (DMPAPER_A2) */
            return {
              width: mm(420),
              height: mm(594)
            };
          case 67:
            /* A3 Transverse 297 x 420 mm         (DMPAPER_A3_TRANSVERSE) */
            return {
              width: mm(297),
              height: mm(420)
            };
          case 68:
            /* A3 Extra Transverse 322 x 445 mm   (DMPAPER_A3_EXTRA_TRANSVERSE) */
            return {
              width: mm(322),
              height: mm(445)
            };
        }
      }
    }]);
    return VisioPage;
  }(VisioRelObject);

  // Corresponding XML files.
  // const references = jxonMap['visio/pages/_rels/pages.xml.rels'];
  // const pagesJXON = jxonMap['visio/pages/pages.xml'];
  // const pageJXON = jxonMap['visio/pages/page1.xml'];

  function pageFactoryFromJxonAsync(_x, _x2) {
    return _pageFactoryFromJxonAsync.apply(this, arguments);
  }
  function _pageFactoryFromJxonAsync() {
    _pageFactoryFromJxonAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(pageJxon, pages) {
      var structurePathBase,
        jxonType,
        structurePath,
        parsedPageJxon,
        rels,
        relId,
        pageAbsolutePath,
        page,
        _args = arguments;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              structurePathBase = _args.length > 2 && _args[2] !== undefined ? _args[2] : [];
              jxonType = VisioJxonType.Page;
              structurePath = structurePathBase.concat(getStructurePathFragment(jxonType, pageJxon, structurePathBase));
              _context.next = 5;
              return parseJxon.call(this, pageJxon, jxonType, structurePath);
            case 5:
              parsedPageJxon = _context.sent;
              rels = pages.rels.get(VisioJxonType.Page);
              relId = parsedPageJxon._rel; // if (rels && rels.has(relId))
              pageAbsolutePath = rels.get(relId).targetFile.absolutePath;
              page = new VisioPage(_objectSpread2({
                archive: this,
                pages: pages,
                xmlPath: pageAbsolutePath
              }, parsedPageJxon));
              return _context.abrupt("return", page);
            case 11:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));
    return _pageFactoryFromJxonAsync.apply(this, arguments);
  }

  var _excluded$3 = ["shapes"];
  var VisioMasterShape = /*#__PURE__*/function (_VisioObject) {
    _inherits(VisioMasterShape, _VisioObject);
    var _super = _createSuper(VisioMasterShape);
    function VisioMasterShape(init) {
      var prefixList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();
      _classCallCheck(this, VisioMasterShape);
      prefixList.add('cells');
      prefixList.add('sections');
      return _super.call(this, init, prefixList);
    }
    _createClass(VisioMasterShape, [{
      key: "setAttributes",
      value: function setAttributes(_ref) {
        var shapes = _ref.shapes,
          init = _objectWithoutProperties(_ref, _excluded$3);
        _get(_getPrototypeOf(VisioMasterShape.prototype), "setAttributes", this).call(this, init);
        if (shapes) this.master.initMasterSubshapes(shapes, this);
      }
    }, {
      key: "cells",
      get: function get() {
        return this._cells;
      },
      set: function set(cells) {
        this._cells = cells;
      }
    }, {
      key: "sections",
      get: function get() {
        return this._sections;
      },
      set: function set(sections) {
        this._sections = sections;
      }
    }]);
    return VisioMasterShape;
  }(VisioObject);

  var _excluded$4 = ["shapes"],
    _excluded2$1 = ["id"];
  var VisioMaster = /*#__PURE__*/function (_VisioRelObject) {
    _inherits(VisioMaster, _VisioRelObject);
    var _super = _createSuper(VisioMaster);
    function VisioMaster(init) {
      var prefixList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();
      _classCallCheck(this, VisioMaster);
      prefixList.add('cells');
      prefixList.add('sections');
      prefixList.add('id');
      prefixList.add('name');
      prefixList.add('icon');
      return _super.call(this, init, prefixList);
    }
    _createClass(VisioMaster, [{
      key: "setAttributes",
      value: function setAttributes(_ref) {
        var parsedMasterShapes = _ref.shapes,
          init = _objectWithoutProperties(_ref, _excluded$4);
        _get(_getPrototypeOf(VisioMaster.prototype), "setAttributes", this).call(this, init);
        if (init.cells) this.referenceMasterShapeInsideCellsDeep(this);
        if (parsedMasterShapes) this.initMasterSubshapes(parsedMasterShapes, this);
      }
    }, {
      key: "setMasterContents",
      value: function setMasterContents(parsedMasterContent) {
        // different behavior for one or more sub-shapes
        // http://localhost/MS-VSDX.pdf#page=41&zoom=100,92,226
        // 2.2.5.4.1 Master-to-Shape Inheritance
        // If a master has one top-level shape, a shape that inherits from that master
        // inherits the descendant elements of that master shape. If a master has more
        // than one master shape, a shape that inherits from that master inherits
        // those master shapes as subshapes.

        var shapes = parsedMasterContent.shapes;

        // decide if attributes or subshapes
        if (shapes.size > 1) {
          this.initMasterSubshapes(shapes, this);
          return;
        }

        // use single element directly
        var singleShape = _toConsumableArray(shapes.values())[0];
        var shapeId = singleShape.id,
          initMaster = _objectWithoutProperties(singleShape, _excluded2$1);
        this.setAttributes(_objectSpread2({
          masterAndShape: true,
          shapeId: shapeId
        }, initMaster));
        this.masterContentsSet = true;
      }

      /**
       * @param {Map<VisioMasterShape>} masterShapes - parsed object
       * @param {Master|MasterShape} parent
       */
    }, {
      key: "initMasterSubshapes",
      value: function initMasterSubshapes(masterShapes, parent) {
        var _this = this;
        if (!parent.masterShapes) parent.masterShapes = new Map();
        if (!this.masterShapesMap) this.masterShapesMap = new Map();
        masterShapes.forEach(function (parsedMasterShape, masterShapeId) {
          // recursion (if more levels)
          var masterShape = new VisioMasterShape(_objectSpread2({
            archive: _this.archive,
            master: _this,
            masterId: _this.id
          }, parsedMasterShape));
          _this.referenceMasterShapeInsideCellsDeep(masterShape);

          // parent (master or deeper structure recursively)
          parent.masterShapes.set(masterShapeId, masterShape);

          // flat shapes map
          _this.masterShapesMap.set(masterShapeId, masterShape);
        });
      }
    }, {
      key: "referenceMasterShapeInsideCellsDeep",
      value: function referenceMasterShapeInsideCellsDeep(masterShape) {
        var _this2 = this;
        // important - don't use getters - use directly

        if (masterShape._cells) this.referenceMasterShapeInsideCells(masterShape._cells, masterShape);
        if (this._sections) {
          this._sections.forEach(function (sectionsArray) {
            sectionsArray.forEach(function (section) {
              if (section.rows) section.rows.forEach(function (row) {
                if (row.cells) _this2.referenceMasterShapeInsideCells(row.cells, masterShape);
              });
            });
          });
        }
      }
    }, {
      key: "referenceMasterShapeInsideCells",
      value: function referenceMasterShapeInsideCells(cells, masterShape) {
        cells.masterShape = masterShape;
      }
    }, {
      key: "cells",
      get: function get() {
        return this._cells;
      },
      set: function set(cells) {
        this._cells = cells;
      }
    }, {
      key: "sections",
      get: function get() {
        return this._sections;
      },
      set: function set(sections) {
        this._sections = sections;
      }
    }, {
      key: "id",
      get: function get() {
        return this._id;
      }
    }, {
      key: "name",
      get: function get() {
        return this._name;
      }
    }, {
      key: "getIconBase64",
      value: function getIconBase64() {
        if (!this._icon || !this._icon.base64) return null;
        return "data:image/png;base64,".concat(this._icon.base64);
      }
    }]);
    return VisioMaster;
  }(VisioRelObject);

  var VisioMasters = /*#__PURE__*/function (_VisioRelObject) {
    _inherits(VisioMasters, _VisioRelObject);
    var _super = _createSuper(VisioMasters);
    function VisioMasters(init, prefixList) {
      var _this;
      _classCallCheck(this, VisioMasters);
      _this = _super.call(this, init, prefixList);

      /** @type {Map.<number, VisioMaster>} */
      _this.map = new Map();
      return _this;
    }

    /**
     * @param {VisioMaster} parsedMaster
     * @return {VisioMaster}
     */
    _createClass(VisioMasters, [{
      key: "add",
      value: function add(parsedMaster) {
        var masterId = parsedMaster.id;
        var relId = parsedMaster._rel;
        var rel = this.getRelById(relId);

        // enrich relation with "real" masterId (from parsed master{n}.xml)
        // masters.xml has only basic attributes & rel to path
        rel.masterId = masterId;
        var xmlPath = rel.targetFile.absolutePath;
        var master = new VisioMaster(_objectSpread2({
          archive: this.archive,
          masters: this,
          xmlPath: xmlPath,
          masterContentsSet: false
        }, parsedMaster));
        this.map.set(masterId, master);
        return master;
      }
    }, {
      key: "getRelById",
      value: function getRelById(relId) {
        return this.rels.get(VisioJxonType.Master).get(relId);
      }

      /**
       * Second phase
       *
       * @param {number} masterId
       * @param {VisioMaster} parsedMasterContent
       */
    }, {
      key: "addIntoById",
      value: function addIntoById(masterId, parsedMasterContent) {
        var master = this.map.get(masterId);
        master.setMasterContents(_objectSpread2({}, parsedMasterContent));
      }
    }, {
      key: "getIdByPath",
      value: function getIdByPath(masterAbsolutePath) {
        var masterRels = this.rels.get(VisioJxonType.Master);
        var relsArray = _toConsumableArray(masterRels.values());
        var rel = relsArray.find(function (rel) {
          return rel.targetFile.absolutePath === masterAbsolutePath;
        });
        if (!rel) debug.log('Unknown master');
        return rel.masterId;
      }

      /**
       * @param {number} id
       * @returns {VisioMaster}
       */
    }, {
      key: "get",
      value: function get(id) {
        var master = this.map.get(id);
        return master;
      }
    }, {
      key: "loadMasters",
      value: function () {
        var _loadMasters = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(mastersRelsMap) {
          var archive, _iterator, _step, _step$value, masterRelation, masterPath, masterId, master, masterJxon, parsedMasterContent;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  archive = this.archive; // this rel id of master is misleading !!! (find right one in mastersRels)
                  // this id is only page related
                  _iterator = _createForOfIteratorHelper(mastersRelsMap.entries());
                  _context.prev = 2;
                  _iterator.s();
                case 4:
                  if ((_step = _iterator.n()).done) {
                    _context.next = 20;
                    break;
                  }
                  _step$value = _slicedToArray(_step.value, 2), masterRelation = _step$value[1];
                  masterPath = masterRelation.targetFile.absolutePath;
                  masterId = this.getIdByPath(masterPath);
                  master = this.get(masterId); // already loaded
                  if (!master.masterContentsSet) {
                    _context.next = 11;
                    break;
                  }
                  return _context.abrupt("continue", 18);
                case 11:
                  _context.next = 13;
                  return archive.getJxonAsync(masterPath);
                case 13:
                  masterJxon = _context.sent;
                  _context.next = 16;
                  return parseJxon.call(archive, masterJxon, VisioJxonType.Master, [], {
                    structurePathEnrichObject: {
                      masterId: masterId
                    }
                  });
                case 16:
                  parsedMasterContent = _context.sent;
                  master.setMasterContents(parsedMasterContent);
                case 18:
                  _context.next = 4;
                  break;
                case 20:
                  _context.next = 25;
                  break;
                case 22:
                  _context.prev = 22;
                  _context.t0 = _context["catch"](2);
                  _iterator.e(_context.t0);
                case 25:
                  _context.prev = 25;
                  _iterator.f();
                  return _context.finish(25);
                case 28:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this, [[2, 22, 25, 28]]);
        }));
        function loadMasters(_x) {
          return _loadMasters.apply(this, arguments);
        }
        return loadMasters;
      }()
    }]);
    return VisioMasters;
  }(VisioRelObject);

  /**
   * @this {VisioArchive}
   * @param [topRelationsMap]
   * @param [documentRelationsMap]
   * @param getJxonAsync
   * @returns {Promise<Document>}
   */
  function documentFactory() {
    return _documentFactory.apply(this, arguments);
  }
  function _documentFactory() {
    _documentFactory = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var _this = this;
      var _ref,
        _ref$topRelationsMap,
        topRelationsMap,
        _ref$documentRelation,
        documentRelationsMap,
        _ref$getJxonAsync,
        getJxonAsync,
        documentJxon,
        structurePath,
        colorsJxon,
        initNonColors,
        pagesXmlPath,
        pagesJxon,
        pagesJxonsArray,
        _iterator,
        _step,
        pageJxon,
        page,
        mastersXmlPath,
        masters,
        mastersJxon,
        mastersJxonsArray,
        _iterator2,
        _step2,
        masterJxon,
        master,
        _args = arguments;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _ref = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, _ref$topRelationsMap = _ref.topRelationsMap, topRelationsMap = _ref$topRelationsMap === void 0 ? this.topRelationsMap : _ref$topRelationsMap, _ref$documentRelation = _ref.documentRelationsMap, documentRelationsMap = _ref$documentRelation === void 0 ? this.documentRelationsMap : _ref$documentRelation, _ref$getJxonAsync = _ref.getJxonAsync, getJxonAsync = _ref$getJxonAsync === void 0 ? function () {
                return _this.getJxonAsync.apply(_this, arguments);
              } : _ref$getJxonAsync;
              _context.next = 3;
              return getJxonAsync(getSingleRecordPath(topRelationsMap, VisioRelationType.document));
            case 3:
              documentJxon = _context.sent;
              expectedSchema(documentJxon, XmlSchemaKey.Main);
              structurePath = [getStructurePathFragment(VisioJxonType.Document, documentJxon, [])]; //     ,--.                                                ,--.
              //   ,-|  | ,---.  ,---.,--.,--.,--,--,--. ,---. ,--,--, ,-'  '-.
              //  ' .-. || .-. || .--'|  ||  ||        || .-. :|      \'-.  .-'
              //  \ `-' |' '-' '\ `--.'  ''  '|  |  |  |\   --.|  ||  |  |  |
              //   `---'  `---'  `---' `----' `--`--`--' `----'`--''--'  `--'
              this.document = new VisioDocument({
                archive: this
              });

              // colors separately - needed as dependency when parseJxon(styleSheets)
              colorsJxon = documentJxon[VisioJxonDocumentKey.Colors];
              if (colorsJxon) this.document.setAttributes({
                colors: parseColors(colorsJxon)
              }, new Set([VisioAttribute.colors]));
              _context.next = 11;
              return parseJxon.call(this, documentJxon, VisioJxonType.Document, []);
            case 11:
              initNonColors = _context.sent;
              // delete initNonColors.colors;
              this.document.setAttributes(initNonColors);
              this.document.pageSheet = {
                debug: 'dummyPageSheet',
                cells: this.document.styleSheets.get(0).cells
              };

              // TODO parse windows
              // const windows = await this.getJxonAsync(
              //     getSingleRecordPath(documentRelationsMap, VisioRelationType.Windows)
              // );

              //   ,---.  ,--,--. ,---.  ,---.  ,---.
              //  | .-. |' ,-.  || .-. || .-. :(  .-'
              //  | '-' '\ '-'  |' '-' '\   --..-'  `)
              //  |  |-'  `--`--'.`-  /  `----'`----'
              //  `--'           `---'
              pagesXmlPath = getSingleRecordPath(documentRelationsMap, VisioRelationType.Pages);
              this.document.pages = new VisioPages({
                archive: this,
                xmlPath: pagesXmlPath
              });

              // pages must have _rels by design
              // prepare immediately
              _context.next = 18;
              return this.document.pages.getRelsMapCachedAsync();
            case 18:
              _context.next = 20;
              return getJxonAsync(pagesXmlPath);
            case 20:
              pagesJxon = _context.sent;
              pagesJxonsArray = toArray(pagesJxon.Page);
              _iterator = _createForOfIteratorHelper(pagesJxonsArray);
              _context.prev = 23;
              _iterator.s();
            case 25:
              if ((_step = _iterator.n()).done) {
                _context.next = 33;
                break;
              }
              pageJxon = _step.value;
              _context.next = 29;
              return pageFactoryFromJxonAsync.call(this, pageJxon, this.document.pages);
            case 29:
              page = _context.sent;
              this.document.pages.add(page);
            case 31:
              _context.next = 25;
              break;
            case 33:
              _context.next = 38;
              break;
            case 35:
              _context.prev = 35;
              _context.t0 = _context["catch"](23);
              _iterator.e(_context.t0);
            case 38:
              _context.prev = 38;
              _iterator.f();
              return _context.finish(38);
            case 41:
              //                            ,--.
              //  ,--,--,--. ,--,--. ,---.,-'  '-. ,---. ,--.--. ,---.
              //  |        |' ,-.  |(  .-''-.  .-'| .-. :|  .--'(  .-'
              //  |  |  |  |\ '-'  |.-'  `) |  |  \   --.|  |   .-'  `)
              //  `--`--`--' `--`--'`----'  `--'   `----'`--'   `----'
              // masters.xml
              // (master{n}.xml parsed when reading exact page)
              mastersXmlPath = getSingleRecordPath(documentRelationsMap, VisioRelationType.Masters);
              if (!mastersXmlPath) {
                _context.next = 69;
                break;
              }
              masters = this.document.masters = new VisioMasters({
                archive: this,
                xmlPath: mastersXmlPath
              }); // masters.xml has rels by design
              _context.next = 46;
              return this.document.masters.getRelsMapCachedAsync();
            case 46:
              _context.next = 48;
              return getJxonAsync(mastersXmlPath);
            case 48:
              mastersJxon = _context.sent;
              mastersJxonsArray = toArray(mastersJxon.Master);
              _iterator2 = _createForOfIteratorHelper(mastersJxonsArray);
              _context.prev = 51;
              _iterator2.s();
            case 53:
              if ((_step2 = _iterator2.n()).done) {
                _context.next = 61;
                break;
              }
              masterJxon = _step2.value;
              _context.next = 57;
              return parseJxon.call(this, masterJxon, VisioJxonType.Master,
              // empty structure path (master is not real part of document)
              []);
            case 57:
              master = _context.sent;
              masters.add(master);
            case 59:
              _context.next = 53;
              break;
            case 61:
              _context.next = 66;
              break;
            case 63:
              _context.prev = 63;
              _context.t1 = _context["catch"](51);
              _iterator2.e(_context.t1);
            case 66:
              _context.prev = 66;
              _iterator2.f();
              return _context.finish(66);
            case 69:
              return _context.abrupt("return", this.document);
            case 70:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[23, 35, 38, 41], [51, 63, 66, 69]]);
    }));
    return _documentFactory.apply(this, arguments);
  }

  var VSDX_MIME_TYPE = 'application/vnd-ms-visio.drawing;charset=utf-8';
  var ExportType = {
    array: 'array',
    arraybuffer: 'arraybuffer',
    base64: 'base64',
    binarystring: 'binarystring',
    blob: 'blob',
    uint8array: 'uint8array'
  };
  var VisioArchive = /*#__PURE__*/function () {
    function VisioArchive() {
      _classCallCheck(this, VisioArchive);
      this.document = null;
      this.source = null;
      this.zip = null;
      this.jxonAsync = null;
      this.topRelationsMap = null;
      this.documentRelationsMap = null;
    }
    _createClass(VisioArchive, [{
      key: "load",
      value: function () {
        var _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(arrayBuffer) {
          var jsZip, zip;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!(arrayBuffer instanceof ArrayBuffer)) {
                    _context.next = 18;
                    break;
                  }
                  jsZip = new jszip();
                  _context.next = 4;
                  return jsZip.loadAsync(arrayBuffer);
                case 4:
                  zip = _context.sent;
                  this.source = arrayBuffer;
                  this.zip = zip;
                  this.jxonAsync = new JxonAsync(zip);
                  _context.next = 10;
                  return getTopRelationsMap.call(this);
                case 10:
                  this.topRelationsMap = _context.sent;
                  _context.next = 13;
                  return getDocumentRelationsMap.call(this);
                case 13:
                  this.documentRelationsMap = _context.sent;
                  _context.next = 16;
                  return documentFactory.call(this);
                case 16:
                  _context.next = 19;
                  break;
                case 18:
                  throw new Error('Not an instance of ArrayBuffer.');
                case 19:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));
        function load(_x) {
          return _load.apply(this, arguments);
        }
        return load;
      }()
    }, {
      key: "getJxonAsync",
      value: function () {
        var _getJxonAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(path) {
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  return _context2.abrupt("return", this.jxonAsync.getJxonAsync(path));
                case 1:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));
        function getJxonAsync(_x2) {
          return _getJxonAsync.apply(this, arguments);
        }
        return getJxonAsync;
      }()
    }, {
      key: "getImageAsync",
      value: function () {
        var _getImageAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(path) {
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  return _context3.abrupt("return", this.jxonAsync.getImageAsync(path));
                case 1:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));
        function getImageAsync(_x3) {
          return _getImageAsync.apply(this, arguments);
        }
        return getImageAsync;
      }()
    }, {
      key: "toVSDX",
      value: function () {
        var _toVSDX = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
          var options,
            _options$type,
            type,
            exportType,
            support,
            modernType,
            _args4 = arguments;
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  options = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {};
                  _options$type = options.type, type = _options$type === void 0 ? 'blob' : _options$type;
                  exportType = type;
                  if (type && ExportType[type]) {
                    // some features of certain export types might not be supported by user browser
                    support = jszip.support;
                    modernType = support.hasOwnProperty(type);
                    if (modernType && support[type] || !modernType) {
                      exportType = ExportType[type];
                    } else {
                      debug.log("Browser does not support export type: \"".concat(type, "\", using Blob as fallback."));
                    }
                  }
                  return _context4.abrupt("return", this.zip.generateAsync(_objectSpread2(_objectSpread2({}, options), {}, {
                    type: exportType
                  })));
                case 5:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));
        function toVSDX() {
          return _toVSDX.apply(this, arguments);
        }
        return toVSDX;
      }()
    }, {
      key: "addEntries",
      value: function addEntries(files) {
        for (var path in files) {
          if (files.hasOwnProperty(path)) {
            this.zip.file(path, files[path].content);
          }
        }
      }
    }], [{
      key: "fromURL",
      value: function () {
        var _fromURL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(url) {
          var _this = this;
          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  if (!(typeof url !== 'string' || url === '')) {
                    _context5.next = 2;
                    break;
                  }
                  throw new Error('Missing parameter');
                case 2:
                  return _context5.abrupt("return", new Promise(function (resolve, reject) {
                    var request = new XMLHttpRequest();
                    request.open('GET', url, true);
                    request.setRequestHeader('Content-Type', VSDX_MIME_TYPE);
                    request.responseType = 'blob';
                    request.onerror = function () {
                      reject(new Error("Failed to load file ".concat(url, ", status: ").concat(request.status, " (").concat(request.statusText, ")")));
                    };
                    request.onload = function () {
                      if (request.status === 200) {
                        var reader = new FileReader();
                        reader.onload = function (evt) {
                          var buffer = evt.target.result;
                          resolve(_this.fromArrayBuffer(buffer));
                        };
                        reader.onerror = function () {
                          reject(new Error("Error occurred reading file: ".concat(url)));
                        };
                        reader.readAsArrayBuffer(request.response);
                      } else {
                        reject(new Error("Failed to load file ".concat(url, ", status: ").concat(request.status, " (").concat(request.statusText, ")")));
                      }
                    };
                    request.send();
                  }));
                case 3:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5);
        }));
        function fromURL(_x4) {
          return _fromURL.apply(this, arguments);
        }
        return fromURL;
      }()
    }, {
      key: "fromArrayBuffer",
      value: function () {
        var _fromArrayBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(arrayBuffer) {
          var archive;
          return _regeneratorRuntime().wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  archive = new this();
                  _context6.next = 3;
                  return archive.load(arrayBuffer);
                case 3:
                  return _context6.abrupt("return", archive);
                case 4:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6, this);
        }));
        function fromArrayBuffer(_x5) {
          return _fromArrayBuffer.apply(this, arguments);
        }
        return fromArrayBuffer;
      }()
    }, {
      key: "fromBase64",
      value: function () {
        var _fromBase = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(base64) {
          return _regeneratorRuntime().wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  return _context7.abrupt("return", this.fromArrayBuffer(base64toArrayBuffer(base64)));
                case 1:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, this);
        }));
        function fromBase64(_x6) {
          return _fromBase.apply(this, arguments);
        }
        return fromBase64;
      }()
    }]);
    return VisioArchive;
  }();
  function base64toArrayBuffer(source) {
    return new Uint8Array(_toConsumableArray(atob(source)).map(function (_char) {
      return _char.charCodeAt(0);
    }));
  }

  var util = {
    fromPixels: fromPixels,
    toPixels: toPixels,
    isFontAvailable: isFontAvailable
  };
  var types = {
    VisioRowType: VisioRowType,
    VisioSectionType: VisioSectionType,
    VisioCellName: VisioCellName,
    VisioUnitType: VisioUnitType
  };

  exports.VisioArchive = VisioArchive;
  exports.VisioConnect = VisioConnect;
  exports.VisioDocument = VisioDocument;
  exports.VisioElement = VisioElement;
  exports.VisioIndexedSection = VisioIndexedSection;
  exports.VisioLink = VisioLink;
  exports.VisioNamedSection = VisioNamedSection;
  exports.VisioPage = VisioPage;
  exports.VisioPageContent = VisioPageContent;
  exports.VisioPages = VisioPages;
  exports.VisioRow = VisioRow;
  exports.VisioSection = VisioSection;
  exports.VisioShape = VisioShape;
  exports.VisioSheetObject = VisioSheetObject;
  exports.config = config;
  exports.debug = debug;
  exports.types = types;
  exports.util = util;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
